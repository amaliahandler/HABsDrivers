---
title: "drivers_analysis"
author: "Handler"
date: '2022-11-21'
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
library(usethis)
library(devtools)
library(spmodel)
library(sf)
library(mapview)
library(dplyr)
library(tidyr)

# Detailed guide to spmodel
# https://rdrr.io/cran/spmodel/f/inst/doc/guide.pdf
```


Load the data and create some composite variables


```{r}
# Load all data and functions from HABsDrivers package
load_all()

# Filter to only include first visits and most recent samples so that we have an independent set of data
# habs_ind <- habs %>%
#   filter(VISIT_NO == 1) %>%
#   group_by(UNIQUE_ID) %>%
#   filter(DSGN_CYCLE == max(DSGN_CYCLE))

# Create some composite variables of land use, note that 2006 NLCD is associated with 2007 NLA, but 2011 NLCD is associated with 2012 and 2017 NLA.
habs <- habs %>%
  mutate(urban = case_when(DSGN_CYCLE == 2007 ~ PctUrbOp2006Ws + 
                             PctUrbLo2006Ws + PctUrbMd2006Ws + PctUrbHi2006Ws,
                           TRUE ~ PctUrbOp2011Ws + PctUrbLo2011Ws + 
                             PctUrbMd2011Ws + PctUrbHi2011Ws),
         wetland = case_when(DSGN_CYCLE == 2007 ~ PctWdWet2006Ws + PctHbWet2006Ws,
                            TRUE ~ PctWdWet2011Ws + PctHbWet2011Ws),
         forest = case_when(DSGN_CYCLE == 2007 ~ PctDecid2006Ws + PctConif2006Ws + PctMxFst2006Ws,
                            TRUE ~ PctDecid2011Ws + PctConif2011Ws + PctMxFst2011Ws),
         agriculture = case_when(DSGN_CYCLE == 2007 ~ PctHay2006Ws + PctCrop2006Ws,
                                 TRUE ~ PctHay2011Ws + PctCrop2011Ws))
```


Experiment with some spatial models


```{r}
# Run a few different versions of the model

# Just in-lake data (NARS only) to compare spatial covariance types
# mod_lake_exp <- splm(log10(B_G_DENS + 1) ~ NTL + PTL + DOC + TURB + PH + TEMPERATURE, data = drop_na(habs, NTL, PTL, DOC, TURB, PH, TEMPERATURE), spcov_type = "exponential")
# 
# mod_lake_sph <- splm(log10(B_G_DENS + 1) ~ NTL + PTL + DOC + TURB + PH + TEMPERATURE, data = habs_ind, spcov_type = "spherical")
# 
# mod_lake_gau <- splm(log10(B_G_DENS + 1) ~ NTL + PTL + DOC + TURB + PH + TEMPERATURE, data = habs_ind, spcov_type = "gaussian")

# glances(mod_lake_exp, mod_lake_sph, mod_lake_gau)
# Exponential and spherical spatial covariance performs the same according to AIC, gaussian performs worse

# NARS and watershed data
# mod_lake_land <- splm(log10(B_G_DENS + 1) ~ NTL + PTL + DOC + TURB + PH + TEMPERATURE + urban + wetland + forest + agriculture, data = habs_ind, spcov_type = "exponential")
# 
# glances(mod_lake_exp, mod_lake_land)
# Adding more variables does not substantially increase the variation explained

# Compare with random effects and without random effects

# Model without random effects
# Random effect for survey year and lake, not nested
mod_no_re <- splm(
  log10(B_G_DENS + 1) ~ NTL + PTL + DOC + TURB + PH + TEMPERATURE + urban + wetland + forest + agriculture + lakemorpho_depth + Precip_Minus_EVTWs + Tmean8110Ws + ElevWs + SlopeWs, 
  data = drop_na(habs, NTL, PTL, DOC, TURB, PH, TEMPERATURE, urban, wetland, forest, agriculture, lakemorpho_depth, Precip_Minus_EVTWs, Tmean8110Ws, ElevWs, SlopeWs), 
  spcov_type = "exponential", 
  local = TRUE) 

# Random effect for survey year and lake, not nested
mod_re_unnested <- splm(
  log10(B_G_DENS + 1) ~ NTL + PTL + DOC + TURB + PH + TEMPERATURE + urban + wetland + forest + agriculture + lakemorpho_depth + Precip_Minus_EVTWs + Tmean8110Ws + ElevWs + SlopeWs, 
  data = drop_na(habs, NTL, PTL, DOC, TURB, PH, TEMPERATURE, urban, wetland, forest, agriculture, lakemorpho_depth, Precip_Minus_EVTWs, Tmean8110Ws, ElevWs, SlopeWs), 
  random = ~ DSGN_CYCLE + UNIQUE_ID, 
  spcov_type = "exponential", 
  local = TRUE) 

# Random effect for survey year and lake nested within survey year (revisits) 
mod_re_nested <- splm(
  log10(B_G_DENS + 1) ~ NTL + PTL + DOC + TURB + PH + TEMPERATURE + urban + wetland + forest + agriculture + lakemorpho_depth + Precip_Minus_EVTWs + Tmean8110Ws + ElevWs + SlopeWs, 
  data = drop_na(habs, NTL, PTL, DOC, TURB, PH, TEMPERATURE, urban, wetland, forest, agriculture, lakemorpho_depth, Precip_Minus_EVTWs, Tmean8110Ws, ElevWs, SlopeWs), 
  random = ~ (DSGN_CYCLE / UNIQUE_ID), 
  spcov_type = "exponential", 
  local = TRUE) 

# Compare models
glances(mod_no_re, mod_re_unnested, mod_re_nested)
# AIC: random effects nested < no random effects < random effects not nested

# Check model performance by loocv
# These take a very long time to run. Running the nested model went for 1.25 hours and didn't finish. Should maybe explore doing a k-folds cross validation.
loocv(mod_re_nested, local = T)
loocv(mod_re_unnested, local = T)

# The error in LOOCV seems to be related to the random effect. Does it still fail for a model run without a random effect?
mod_no_re <- splm(log10(B_G_DENS + 1) ~ NTL + PTL + DOC + TURB + PH + TEMPERATURE + urban + wetland + forest + agriculture + lakemorpho_depth + Precip_Minus_EVTWs + Tmean8110Ws + ElevWs + SlopeWs, data = habs, spcov_type = "exponential", local = TRUE) 

loocv(mod_no_re, local = T)
# This runs

# Split data into training and predictor sets
habs_train <- habs[1:500,]
habs_pred  <- habs[501:600,]

train_mod_re_nested <- splm(log10(B_G_DENS + 1) ~ NTL + PTL + DOC + TURB + PH + TEMPERATURE + urban + wetland + forest + agriculture + lakemorpho_depth + Precip_Minus_EVTWs + Tmean8110Ws + ElevWs + SlopeWs, data = habs_train, random = ~ (DSGN_CYCLE / UNIQUE_ID), spcov_type = "exponential", local = TRUE)

predict(train_mod_re_nested, newdata = habs_pred, local = TRUE)

# How about with one random effect?
mod_lake_re <- splm(log10(B_G_DENS + 1) ~ NTL + PTL + DOC + TURB + PH + TEMPERATURE + urban + wetland + forest + agriculture + lakemorpho_depth + Precip_Minus_EVTWs + Tmean8110Ws + ElevWs + SlopeWs, data = habs, random = ~ UNIQUE_ID, spcov_type = "exponential", local = TRUE)

loocv(mod_lake_re, local = T)
# This throws an error
# Seems to be an issue with the inclusion of random effects

# Does a reprex create the same error?
tmp <- data.frame(dep = rnorm(100, mean = 10), 
                  ind = rnorm(100, mean = 1000, sd = 50), 
                  re = rep(c("a","b"),50),
                  xcoord = rnorm(100, mean = 50),
                  ycoord = rnorm(100, mean = 50))

tmp_mod <- splm(dep ~ ind, random = ~ re, xcoord = xcoord, ycoord = ycoord, data = tmp, spcov_type = "exponential")

loocv(tmp_mod)
# This runs
# Okay, there's some problem with my models, but I don't know what it is.

# Visualize the standardized residuals
re_nested_resid <- augment(mod_re_nested)
mapview(re_nested_resid, zcol = ".std.resid", legend = TRUE)

# Filter to just the big residuals
tmp <- filter(re_nested_resid, .std.resid < -2 | .std.resid > 2)
mapview(tmp, zcol = ".std.resid", legend = TRUE)
# Seem fairly randomly distributed across the country

mapview(re_nested_resid, zcol = ".std.resid", at = c(-5.4, -2, 2.6), legend = TRUE)

ggplot(data = re_nested_resid, aes(x = .fitted, y = `log10(B_G_DENS + 1)`)) + 
  geom_point() + 
  geom_abline(intercept = 0, slope = 1)

ggplot(data = re_nested_resid, aes(x = .std.resid)) + 
  geom_histogram() + 

summary(mod_re_nested)
summary(mod_re_unnested)

plot(mod_re_nested)
plot(mod_re_unnested)

# Check that the spatial model performs better than a non-spatial model
mod_nonsp <- splm(log10(B_G_DENS + 1) ~ NTL + PTL + DOC + TURB + PH + TEMPERATURE + urban + wetland + forest + agriculture + lakemorpho_depth + Precip_Minus_EVTWs + Tmean8110Ws + ElevWs + SlopeWs, data = habs, random = ~ (DSGN_CYCLE / UNIQUE_ID), spcov_type = "none", local = TRUE) 

# Compare spatial and non-spatial models with nested random effects
glances(mod_nonsp, mod_re_nested)
# Hmmm, the non-spatial model performs just as well (maybe a little better) than the spatial model

# Is it because there are so many independent variables?
basic_spat <- splm(log10(B_G_DENS + 1) ~ NTL, data = habs, random = ~ (DSGN_CYCLE / UNIQUE_ID), spcov_type = "exponential", local = TRUE) 

basic_nonsp <- splm(log10(B_G_DENS + 1) ~ NTL, data = habs, random = ~ (DSGN_CYCLE / UNIQUE_ID), spcov_type = "none", local = TRUE)

glances(basic_nonsp, basic_spat)
# Reducing the number of independent variables doesn't change the answer. The spatial and non-spatial forms of the model perform about the same

# Try a few different spatial convariance types
gaussian <- splm(log10(B_G_DENS + 1) ~ NTL, data = habs, random = ~ (DSGN_CYCLE / UNIQUE_ID), spcov_type = "gaussian", local = TRUE) 

sphere <- splm(log10(B_G_DENS + 1) ~ NTL, data = habs, random = ~ (DSGN_CYCLE / UNIQUE_ID), spcov_type = "spherical", local = TRUE) 

triangular <- splm(log10(B_G_DENS + 1) ~ NTL, data = habs, random = ~ (DSGN_CYCLE / UNIQUE_ID), spcov_type = "triangular", local = TRUE)

circular <- splm(log10(B_G_DENS + 1) ~ NTL, data = habs, random = ~ (DSGN_CYCLE / UNIQUE_ID), spcov_type = "circular", local = TRUE)

cubic <- splm(log10(B_G_DENS + 1) ~ NTL, data = habs, random = ~ (DSGN_CYCLE / UNIQUE_ID), spcov_type = "cubic", local = TRUE)

glances(basic_nonsp, basic_spat, gaussian, sphere, triangular, circular, cubic)
# Conclusion: Exponential and cubic covariance structure perform the same and only slightly better than other form.

summary(mod_re_nested)
summary(mod_re_unnested)

tidy(mod_re_nested)
glance(mod_re_nested)
plot(mod_re_nested)
plot(mod_re_unnested)

```


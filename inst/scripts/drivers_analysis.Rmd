---
title: "drivers_analysis"
author: "Handler"
date: '2022-11-21'
output: html_document
editor_options: 
  chunk_output_type: console
---

Based on data compiled in drivers_compilation.Rmd

```{r setup, include=FALSE}
library(usethis)
library(devtools)
library(spmodel)
library(sf)
library(mapview)
library(dplyr)
library(tidyr)
library(ggplot2)
library(corrplot)

# Load all data and functions from HABsDrivers package
load_all()

# Detailed guide to spmodel
# https://usepa.github.io/spmodel/articles/guide.html
```


Some additional variables:

```{r}
# Calculate the chlorophyll a associated with cyanobacteria
habs <- mutate(habs, CHLA_CYANO = CHLA_RESULT * BG_BIOVOL/PHYT_BIOVOL, .after = CHLA_RESULT)

# Add a binary 1/0 variable for detect/non-detect of nitrate
habs <- mutate(habs, NITRATE_DET = ifelse(is.na(NITRATE_N), 0, 1), .after = NITRATE_N)

# Replace non-detect values for nitrate with 0
habs <- mutate(habs, NITRATE_N = ifelse(is.na(NITRATE_N), 0, NITRATE_N))

habs <- habs |>
  mutate(n_farm_inputs = N_Fert_Farm + N_CBNF + N_livestock_Waste,
         n_dev_inputs = N_Human_Waste + N_Fert_Urban,
         p_farm_inputs = P_f_fertilizer + P_livestock_Waste,
         p_dev_inputs = P_human_waste_kg + P_nf_fertilizer)

# Create a categorical variable for microcystin detection
habs <- mutate(habs, MICX_DET = factor(ifelse(is.finite(MICX), 1, 0)))

# There is a MAXDEPTH measurement that is close to 1000 m and three lakemorpho observations > 500 m. Need to remove these.
# There are also some extreme values for the nutrient inputs. Could this be an issue with the watershed area?
# In addition, there are three water temperatures that exceed 50 degC, including over 250 degC (!) that should be removed.
habs <- habs|>
  mutate(MAXDEPTH = ifelse(MAXDEPTH > 200, NA, MAXDEPTH),
         lakemorpho_depth = ifelse(lakemorpho_depth > 500, NA, lakemorpho_depth),
         n_farm_inputs = ifelse(n_farm_inputs > 600, NA, n_farm_inputs),
         p_farm_inputs = ifelse(p_farm_inputs > 100, NA, p_farm_inputs),
         n_dev_inputs = ifelse(n_dev_inputs > 300, NA, n_dev_inputs),
         p_dev_inputs = ifelse(p_dev_inputs > 100, NA, p_dev_inputs),
         N_Surplus = ifelse(N_Surplus > 3000, NA, N_Surplus),
         TEMPERATURE = ifelse(TEMPERATURE > 50, NA, TEMPERATURE))
```


Examine the predictor data for colinear variables

```{r}
cormat_pred <- cor(st_drop_geometry(select(habs, TEMPERATURE:P_Surplus)), use = "pairwise.complete.obs")

# Trim to just the variables explored in the models
cor_dat <- habs |>
  st_drop_geometry() |>
  select(TEMPERATURE, MAXDEPTH, AMMONIA_N, DOC:NITRATE_N, PH, D_EXCESS, EVAP_INFL, fst_ws, wet_ws, precip_mean_month, temp_mean_month, lakemorpho_fetch, BFIWs, KffactWs:Precip_Minus_EVTWs, Precip8110Ws, Tmean8110Ws, N_Total_Deposition, n_farm_inputs:p_dev_inputs) |>
  relocate(NTL, PTL, NITRATE_N, AMMONIA_N, DOC, PH, TEMPERATURE, TURB, D_EXCESS, EVAP_INFL, fst_ws, wet_ws, KffactWs, n_farm_inputs, p_farm_inputs, n_dev_inputs, p_dev_inputs, N_Total_Deposition, precip_mean_month, temp_mean_month, Precip8110Ws, Tmean8110Ws, Precip_Minus_EVTWs, RunoffWs, BFIWs, MAXDEPTH, lakemorpho_fetch)

var_names <- c("Total N", 
               "Total P",   
               "Nitrate", 
               "Ammonia", 
               "DOC", 
               "pH", 
               "Water Temp",
               "Turbidity",
               "Evaporation",
               "Evaporation/Inflow",
               "Forest Cover", 
               "Wetland Cover",
               "Soil Erodability",
               "Farm N",
               "Farm P",
               "Developed N", 
               "Developed P",
               "Deposition N", 
               "Monthly Precip",
               "Monthly Temp",
               "Annual Precip", 
               "Annual Air Temp",
               "Annual Precip-ET",
               "Runoff", 
               "Baseflow Index",
               "Lake Depth",
               "Lake Fetch")

cormat_pred <- cor(cor_dat, use = "pairwise.complete.obs", method = "spearman")

colnames(cormat_pred) <- var_names
rownames(cormat_pred) <- var_names

# Square plot
corrplot.mixed(cormat_pred, upper = "ellipse", diag = "n", tl.pos = "lt", tl.col = "black", tl.srt = 45)

# Lower triangle plot
cor_drivers <- corrplot(cormat_pred, method = "ellipse", type = "lower", tl.col = "black", tl.srt = 45)

# Save the plot
png(filename = "./figures/Correlation Matrix of Major Drivers.png", height = 6, width = 6, units = "in", bg = "transparent", res = 600)
corrplot(cormat_pred, method = "ellipse", type = "lower", tl.col = "black", tl.srt = 45)
dev.off()

```


How much of the variation in the response variables is potentially explainable based on the spatial versus temporal variation?


```{r}
# Assess spatial (signal) to temporal (noise) in response variables
do.call(rbind, lapply(c("MICX", "B_G_DENS", "CHLA_RESULT", "CHLA_CYANO"), function(x){
  form <- as.formula(paste(x, " ~ 1 + (1|SITE_ID)"))
  df   <- habs
  
  if(x == "MICX"){
    df <- drop_na(df, MICX)
  }
  
  if(x == "B_G_DENS" | x == "MICX"){
    form <- as.formula(paste("log10(", x, "+ 1) ~ 1 + (1|SITE_ID)"))
  }
  
  if(x == "CHLA_RESULT"){
    form <- as.formula(paste("log10(", x, ") ~ 1 + (1|SITE_ID)"))
  }
  
  if(x == "CHLA_CYANO"){
    form <- as.formula(paste("log10(", x, ") ~ 1 + (1|SITE_ID)"))
  }
  
  mod         <- lme4::lmer(form, data = df, REML = T, verbose = F)
  site.var    <- as.numeric(lme4::VarCorr(mod)) 
  visit.var   <- attr(lme4::VarCorr(mod), "sc")^2
  sn          <- site.var / visit.var
  maxR2       <- sn/(sn + 1)
  return(data.frame(variable = x, maxR2))
}))

```


Find the constant to add to the cyanobacteria cell count. Since this variable should be log-transformed and there are zeros in the data that are real.


```{r cyano models}

# Find a constant to add to the cyano for the log transformation

# function to find c
find_c <- function(par, formula, data) {
  const <- exp(par)
  mf <- model.frame(formula, data)
  data$.y <- log(model.response(mf) + const)
  new_formula <- update(formula, .y ~ .)
  lmod <- lm(new_formula, data)
  resids <- residuals(lmod)
  sigma <- summary(lmod)$sigma
  n <- NROW(data)
  ratio <- resids/sigma
  g1 <- sum(ratio^3) / n
  g2p <- sum(ratio^4) / n - 3
  g2 <- g2p + 6 / (lmod$df.residual + 2)
  g0 <- abs(g1) + abs(g2)
  g0
}

set.seed(1)

# example data
dat <- data.frame(x = rnorm(10), y = rnorm(10, mean = 10))

# HABs data
dat <- st_drop_geometry(drop_na(select(habs, B_G_DENS, NTL, NITRATE_N, NITRATE_DET, AMMONIA_N, DOC, PH, TURB, Precip8110Ws, Tmean8110Ws, EVAP_INFL, MAXDEPTH, lakemorpho_fetch, AG_ECO3)))

# finds the c for log(y + c) (note that y should be on the original scale for
# the purposes of this function, as I take the log inside)
out <- optim(0, 
             fn = find_c, 
             # formula = y ~ x,
             formula = B_G_DENS ~ NTL, NITRATE_N, NITRATE_DET, AMMONIA_N, DOC, PH, TURB, Precip8110Ws, Tmean8110Ws, EVAP_INFL, MAXDEPTH, lakemorpho_fetch, AG_ECO3 + MAXDEPTH * NTL, 
             data = dat, 
             method = "Brent", 
             lower = -10, upper = 10)
c_value <- exp(out$par)
print(c_value)

```

### Cyanobacteria, With Lake Data

```{r}

# Construct the model
dep_var  <- "B_G_DENS"
const    <- 1000

# Set the western mountains to the base group
habs <- mutate(habs, AG_ECO3 = factor(AG_ECO3, levels = c("WMTNS", "PLNLOW", "EHIGH")))

# Filter to the same set of observations for model comparison
habs_mod <- habs |>
  select(B_G_DENS, NTL, PTL, NITRATE_N, NITRATE_DET, AMMONIA_N, DOC, PH, TURB, Precip8110Ws, Tmean8110Ws, precip_mean_month, temp_mean_month, EVAP_INFL, MAXDEPTH, lakemorpho_fetch, AG_ECO3, UNIQUE_ID, DSGN_CYCLE) |>
  drop_na()

# Function to run the cyano models for model comparison.
run_cyano_ml <- function(mod_vars, interact){
  splm(create_formula(dep_var, mod_vars, log = T, const = const, interact),
              data = habs_mod,
              spcov_type = "exponential",
              random = ~ DSGN_CYCLE + UNIQUE_ID,
              estmethod = "ml",
              local = F)
}

# Model comparison

# Does TN or TP fit better?
cy1 <- run_cyano_ml(mod_vars = c("NTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "TURB", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch"), interact = NULL)

cy2 <- run_cyano_ml(mod_vars = c("PTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "TURB", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch"), interact = NULL)

# Monthly mean temperature and precipitation or climate normals?
cy3 <- run_cyano_ml(mod_vars = c("NTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "TURB", "precip_mean_month", "temp_mean_month", "EVAP_INFL", "MAXDEPTH"), interact = NULL)

# Are there ecoregional differences?
cy4 <- run_cyano_ml(mod_vars = c("NTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "TURB", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3"), interact = NULL)

# Do interactions improve the model?
cy5 <- run_cyano_ml(mod_vars = c("NTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "TURB", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch"), interact = "MAXDEPTH * NTL")

cy6 <- run_cyano_ml(mod_vars = c("NTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "TURB", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3"), interact = "AG_ECO3 * NTL")

# Make a table of the model comparison

# Variables common to all models
com_vars <- c("NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "TURB", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch")

# Which models are included in the table?
cy_list <- list(cy1, cy2, cy3, cy4, cy5, cy6)

# Get the fixed effects that are different between the models
dif_vars <- sapply(cy_list, function(mod){
  coef_names <- names(mod$coefficients$fixed)
  coef_names <- coef_names[!coef_names %in% c("(Intercept)", com_vars)]
  paste(coef_names, collapse = ", ")
})

# Get the loocv to get the R^2 between observed and fit
cymods_ml_loocv <- do.call(rbind, lapply(cy_list, loocv))

# Put it all together into a table
cy_res_table <- glances(cy1, cy2, cy3, cy4, cy5, cy6) |>
  arrange(model) |>
  select(model, n, p, npar, AIC, AICc, BIC) |>
  cbind(cymods_ml_loocv) |>
  mutate(distinct_vars = dif_vars,
         common_vars = paste(com_vars, collapse = ", ")) |>
  arrange(BIC) |>
  tibble()

# Run the best fit model, cy5, without spatial correlation for comparison
mod_vars <- c("NTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "TURB", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch")
interact <- "MAXDEPTH * NTL"

# Set the initial covariance to be small. This produces results identical to glm()
spcov_init <- spcov_initial("none", ie = 1e-4, known = "ie")

cmod_final_withlake_nsp <- splm(create_formula(dep_var, mod_vars, log = T, const = const, interact),
                              data = habs_mod,
                              random = ~ DSGN_CYCLE + UNIQUE_ID,
                              spcov_initial = spcov_init,
                              local = F)
  
# Evaluate fit of non-spatial model
cyano_withlake_nsp_loocv <- loocv(cmod_final_nolake)


# Visual the fit of the final spatial model
cyano_withlake_sp_loocv <- loocv(cy5, cv_predict = TRUE)
habs_mod$preds        <- cyano_withlake_sp_loocv$cv_predict

max_val <- max(log10(habs_mod$B_G_DENS + const), habs_mod$preds)

fig <- ggplot(data = habs_mod, aes(x = preds, y = log10(B_G_DENS + const))) +
  geom_hex(bins = 60) +
  scale_fill_continuous(type = "viridis") +
  xlim(2.8, max_val) + ylim(2.8, max_val) +
  ylab("Observed") +
  xlab("Fitted") +
  ggtitle(paste0("Log10(Cyanobacteria + ", const,")"))
ggsave(paste0("./inst/figures/cyano_withlake_sp_final_fitted_preds.png"), fig, height = 4, width = 5, bg = "transparent", dpi = 400, units = "in")

# Save the model
# saveRDS(c4, "./inst/model_objects/model_cyano_nolakedata.rds")

# Map of fitted values
conus <- st_transform(AOI::aoi_get(state = "conus"), 5072)
ggplot() + 
  geom_sf(data = conus, fill = "#e2e2e2", color = "white", lwd = 1) +
  geom_sf(data = arrange(habs_mod, preds), 
          aes(fill = preds), pch = 21, size = 2) +
  scale_fill_gradientn(colors = RColorBrewer::brewer.pal(9, 'YlOrRd'),
                       name = "Log10(Cyanobacteria + 1000)") +
  theme_void()
ggsave("./inst/figures/cyano_withlake_sp_final_fitted_preds_map.png", width = 7, height = 3.5, units = "in", dpi = 600)

# Save the model
# saveRDS(cymod_final_withlake, "./inst/model_objects/model_cyano_withlakedata.rds")
```


### Cyanobacteria, No Lake Data

```{r}
# Construct the model
dep_var  <- "B_G_DENS"
const    <- 1000

# Set the western mountains to the base group
habs <- mutate(habs, AG_ECO3 = factor(AG_ECO3, levels = c("WMTNS", "PLNLOW", "EHIGH")))

# Filter to the same set of observations for model comparison
habs_mod <- habs |>
  select(B_G_DENS, Precip8110Ws, Tmean8110Ws, precip_mean_month, temp_mean_month, BFIWs, MAXDEPTH, lakemorpho_fetch, p_dev_inputs, p_farm_inputs, n_farm_inputs, fst_ws, AG_ECO3, UNIQUE_ID, DSGN_CYCLE) |>
  drop_na()

# Function to run the cyano models for model comparison. Figured out that these models should be run with local = F for more stable AIC/BIC comparison. These don't take much longer to run than local = T models.
run_cyano_ml <- function(mod_vars, interact){
  splm(create_formula(dep_var, mod_vars, log = T, const = const, interact),
              data = habs_mod,
              spcov_type = "exponential",
              random = ~ DSGN_CYCLE + UNIQUE_ID,
              estmethod = "ml",
              local = F)
}


# Base model
c1 <- run_cyano_ml(mod_vars = c("n_farm_inputs", "p_dev_inputs", "Precip8110Ws", "Tmean8110Ws", "BFIWs", "MAXDEPTH", "lakemorpho_fetch"), interact = NULL)

# Additional land cover
c2 <- run_cyano_ml(mod_vars = c("n_farm_inputs", "p_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "BFIWs", "MAXDEPTH", "lakemorpho_fetch"), interact = NULL)

# Climate normals versus monthly precip and temp
c3 <- run_cyano_ml(mod_vars = c("n_farm_inputs", "p_dev_inputs", "fst_ws", "precip_mean_month", "temp_mean_month", "BFIWs", "MAXDEPTH", "lakemorpho_fetch"), interact = NULL)

# Ecoregions
c4 <- run_cyano_ml(mod_vars = c("n_farm_inputs", "p_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "BFIWs", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3"), interact = NULL)

# Interactions
c5 <- run_cyano_ml(mod_vars = c("n_farm_inputs", "p_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "BFIWs", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3"), interact = "MAXDEPTH * n_farm_inputs")

c6 <- run_cyano_ml(mod_vars = c("n_farm_inputs", "p_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "BFIWs", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3"), interact = "AG_ECO3 * n_farm_inputs")

# Variables common to all models
com_vars <- c("n_farm_inputs", "p_dev_inputs", "BFIWs", "MAXDEPTH", "lakemorpho_fetch")

# Which models are included in the table?
cy_list <- list(c1, c2, c3, c4, c5, c6)

# Get the fixed effects that are different between the models
dif_vars <- sapply(cy_list, function(mod){
  coef_names <- names(mod$coefficients$fixed)
  coef_names <- coef_names[!coef_names %in% c("(Intercept)", com_vars)]
  paste(coef_names, collapse = ", ")
})

# Get the loocv to get the R^2 between observed and fit
cmods_ml_loocv <- do.call(rbind, lapply(cy_list, loocv))

# Put it all together into a table
cmods_ml_nolake <- glances(c1, c2, c3, c4, c5, c6) |>
  arrange(model) |>
  select(model, n, p, npar, AIC, AICc, BIC) |>
  cbind(cmods_ml_loocv) |>
  mutate(distinct_vars = dif_vars,
         common_vars = paste(com_vars, collapse = ", ")) |>
  arrange(BIC) |>
  tibble()
  
# Run the best fit model, cy4, without spatial correlation for comparison
mod_vars <- c("n_farm_inputs", "p_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "BFIWs", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3")
interact <- NULL

# Set the initial covariance to be small. This produces results identical to glm()
spcov_init <- spcov_initial("none", ie = 1e-4, known = "ie")

cmod_final_nolake_nsp <- splm(create_formula(dep_var, mod_vars, log = T, const = const, interact),
                              data = habs_mod,
                              random = ~ DSGN_CYCLE + UNIQUE_ID,
                              spcov_initial = spcov_init,
                              local = F)
  
# Evaluate fit of non-spatial model
cyano_nolake_nsp_loocv <- loocv(cmod_final_nolake)


# Visual the fit of the final spatial model
cyano_nolake_sp_loocv <- loocv(c4, cv_predict = TRUE)
habs_mod$preds        <- cyano_nolake_sp_loocv$cv_predict

max_val <- max(log10(habs_mod$B_G_DENS + const), habs_mod$preds)
min_val <- min(log10(habs_mod$B_G_DENS + const), habs_mod$preds)

fig <- ggplot(data = habs_mod, aes(x = preds, y = log10(B_G_DENS + const))) +
  geom_hex(bins = 60) +
  scale_fill_continuous(type = "viridis") +
  xlim(min_val, max_val) + ylim(min_val, max_val) +
  ylab("Observed") +
  xlab("Fitted") +
  ggtitle(paste0("Log10(Cyanobacteria + ", const,")"))
ggsave(paste0("./inst/figures/cyano_sp_final_fitted_preds.png"), fig, height = 4, width = 5, bg = "transparent", dpi = 400, units = "in")

# Save the model
# saveRDS(c4, "./inst/model_objects/model_cyano_nolakedata.rds")

# Map of fitted values
conus <- st_transform(AOI::aoi_get(state = "conus"), 5072)
ggplot() + 
  geom_sf(data = conus, fill = "#e2e2e2", color = "white", lwd = 1) +
  geom_sf(data = arrange(habs_mod, preds), 
          aes(fill = preds), pch = 21, size = 2) +
  scale_fill_gradientn(colors = RColorBrewer::brewer.pal(9, 'YlOrRd'),
                       name = "Log10(Cyanobacteria + 1000)") +
  theme_void()
ggsave("./inst/figures/cyano_sp_final_fitted_preds_map.png", width = 7, height = 3.5, units = "in", dpi = 600)

# Map of standardized residuals
cyano_aug <- augment(c4)
breaks <- c(-2, 0, 2, 3, 4)
cols <- rev(RColorBrewer::brewer.pal(6, "Spectral"))
ggplot() + 
  geom_sf(data = conus, fill = "#e2e2e2", color = "white", lwd = 1) +
  geom_sf(data = arrange(cyano_aug, .std.resid), 
          aes(fill = .std.resid), pch = 21, size = 1.5) +
  scale_fill_stepsn(colors = cols,
                    breaks = breaks,
                    name = "Standardized \nResiduals") +
  theme_void()
ggsave("./inst/figures/cyano_nolake_stdresiduals_map.png", width = 7, height = 3.5, units = "in", dpi = 600)

# Biplot of fitted versus observed data colored by the standardized residuals 
cyano_aug$preds <- cyano_nolake_sp_loocv$cv_predict
ggplot(data = cyano_aug, aes(x = preds, y = `log10(B_G_DENS + 1000)`, fill = .std.resid)) +
  geom_point(pch = 21) +
  # scale_fill_continuous(type = "viridis",
  #                       name = "Standardized \nResidual") +
  scale_fill_stepsn(colors = cols,
                    breaks = breaks,
                    name = "Standardized \nResiduals") +
  xlim(min_val, max_val) + ylim(min_val, max_val) +
  ylab("Observed") +
  xlab("Fitted") +
  ggtitle(paste0("Log10(Cyanobacteria + ", const,")"))
ggsave(paste0("./inst/figures/cyano_nolake_stdresiduals_biplot.png"), height = 4, width = 5, bg = "transparent", dpi = 400, units = "in")

```


## Microcystin Detection Models

### Microcystin, With Lake Data

```{r}

# Set the dependent variable
dep <- "MICX_DET"

# First conduct model comparison with independent error models. We do this because fitting spatial models is computationally expensive to do so in a way that models can be compared.

# Comparing AIC/BIC between models requires the same set of observations be used for all models. Trim the dataset to include just the variables that will be investigated as potential fixed effects in the model.
dat_micx_lake <- habs |>
  select(# Dependent variable and random effects
         MICX_DET, UNIQUE_ID, DSGN_CYCLE, 
         # Climate fixed effects
         Precip8110Ws, Tmean8110Ws, precip_mean_month, 
         # Setting fixed effects
         AG_ECO3, 
         # Lake morphology fixed effects
         MAXDEPTH, lakemorpho_fetch, 
         # Nutrient input fixed effects
         p_farm_inputs, 
         # Lake water fixed effects
         NTL, NITRATE_DET, NITRATE_N, DOC, TEMPERATURE, EVAP_INFL) |> 
  mutate(AG_ECO3 = factor(AG_ECO3, levels = c("WMTNS", "PLNLOW", "EHIGH"))) |>
  drop_na()

# Function to run independent error models

# Set the initial covariance to be small. This produces results identical to glm()
spcov_init <- spcov_initial("none", ie = 1e-4, known = "ie")

run_micx_ie <- function(mod_vars, int = NULL){
  spglm(create_formula(dep_var = dep, ind_vars = mod_vars, interact = int),
        family = "binomial",
        data = dat_micx_lake,
        estmethod = "ml",
        spcov_initial = spcov_init,
        random = ~ DSGN_CYCLE + UNIQUE_ID,
        local = T)
}

# Run a few candidate models. Tried to choose a few combinations of fixed effects from the four categories: Nutrient inputs, climate, setting, and lake morphology

# An initial model
mx1 <-run_micx_ie(mod_vars = c("NTL", "DOC", "precip_mean_month", "TEMPERATURE", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch"))

# Do the 30 year climate normal for precipitation fit better?
mx2 <-run_micx_ie(mod_vars = c("NTL", "DOC", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch"))

# Do dissolved N species improve model fit?
mx3 <-run_micx_ie(mod_vars = c("NTL", "NITRATE_DET", "NITRATE_N", "DOC", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch"))

# What about additional watershed metrics?
mx4 <-run_micx_ie(mod_vars = c("NTL", "NITRATE_DET", "NITRATE_N", "DOC", "p_farm_inputs", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch"))

# What about ecoregion?
mx5 <-run_micx_ie(mod_vars = c("NTL", "NITRATE_DET", "NITRATE_N", "DOC", "p_farm_inputs", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3"))

# What is there an interaction?
mx6 <-run_micx_ie(mod_vars = c("NTL", "NITRATE_DET", "NITRATE_N", "DOC", "p_farm_inputs", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3", int = "NTL * MAXDEPTH"))

# Review model AIC/BIC
glances(mx1, mx2, mx3, mx4, mx5, mx6)

# Make a list of the independent error models to compare
mx_ie_mods <- list(mx1, mx2, mx3, mx4, mx5, mx6)

# Review model AUC
mx_ie_auc <- sapply(micx_ie_mods, AUROC)

# Variables common to all models
com_vars <- c("NTL", "DOC", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch")

# Get the fixed effects that are different between the models
dif_vars <- sapply(mx_ie_mods, function(mod){
  coef_names <- names(mod$coefficients$fixed)
  coef_names <- coef_names[!coef_names %in% c("(Intercept)", com_vars)]
  paste(coef_names, collapse = ", ")
})

# Get any interaction terms

# Put it all together into a table, note that the table is organized by BIC
mx_ie_modcomp <- glances(mx1, mx2, mx3, mx4, mx5, mx6) |>
  arrange(model) |>
  select(-npar, -value, -AICc, -logLik, -pseudo.r.squared) |> 
  mutate(AUC = mx_ie_auc,
         distinct_vars = dif_vars,
         common_vars = paste(com_vars, collapse = ", ")) |>
  arrange(BIC)

# Based on the above analysis, models m4, m5, and m6 have the lower AIC/BIC and will be run with spatial covariance for final model selection

# Function to run spatial models
run_micx_sp <- function(mod_vars, int = NULL){
  spglm(create_formula(dep_var = dep, ind_vars = mod_vars, interact = int),
        family = "binomial",
        data = dat_micx_lake,
        spcov_type = "exponential",
        estmethod = "reml",
        random = ~ DSGN_CYCLE + UNIQUE_ID,
        local = T)
}

# Running with spatial covariance
mx4_sp <-run_micx_sp(mod_vars = c("NTL", "NITRATE_DET", "NITRATE_N", "DOC", "p_farm_inputs", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch"))

mx5_sp <-run_micx_sp(mod_vars = c("NTL", "NITRATE_DET", "NITRATE_N", "DOC", "p_farm_inputs", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3"))

mx6_sp <-run_micx_sp(mod_vars = c("NTL", "NITRATE_DET", "NITRATE_N", "DOC", "p_farm_inputs", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3", int = "NTL * MAXDEPTH"))

# Make a list of the models to compare
mx_lake_sp_mods <- list(mx4_sp, mx5_sp, mx6_sp)

# Review model AUC
mx_lake_sp_auc <- sapply(mx_lake_sp_mods, AUROC)

# Run leave one out cross validation
mx_lake_sp_loocv <- do.call(rbind, lapply(mx_lake_sp_mods, loocv))

# Variables common to all models
com_vars <- c("NTL", "NITRATE_DET", "NITRATE_N", "DOC", "p_farm_inputs", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch")

# Get the fixed effects that are different between the models
dif_vars <- sapply(mx_lake_sp_mods, function(mod){
  coef_names <- names(mod$coefficients$fixed)
  coef_names <- coef_names[!coef_names %in% c("(Intercept)", com_vars)]
  paste(coef_names, collapse = ", ")
})

# Put it all together into a table
mx_lake_sp_modcomp <- mx_lake_sp_loocv |>
  mutate(model = c("mx4_sp", "mx5_sp", "mx6_sp"),
         AUC = mx_lake_sp_auc,
         distinct_vars = dif_vars,
         common_vars = paste(com_vars, collapse = ", ")) |>
  arrange(desc(AUC))

# The final model is model mx5_sp due to the highest AUC and lowest MSPE, though mx4_sp performs virtually identically
# The final model should be run using all available observations and with local = F
mod_vars <- c("NTL", "NITRATE_DET", "NITRATE_N", "DOC", "p_farm_inputs", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3")
int <- NULL
Sys.time()
micx_sp_final_withlake <- spglm(create_formula(dep_var = dep, ind_vars = mod_vars, interact = int),
                                family = "binomial",
                                data = drop_na(habs, all_of(dep_var), all_of(mod_vars)),
                                spcov_type = "exponential",
                                estmethod = "reml",
                                random = ~ DSGN_CYCLE + UNIQUE_ID,
                                local = F)
Sys.time()

# Get AUC of final model
micx_sp_final_nolake_auc <- AUROC(micx_sp_final_withlake)

# Get bias, MSPE
micx_sp_final_nolake_loocv <- loocv(micx_sp_final_withlake)

Sys.time()

# Save the best performing micx model so far
# saveRDS(micx_sp_final_withlake, "./inst/model_objects/model_micx_withlakedata.rds")

# Visualize the results
# Boxplot of probabilities
micx_sp_withlake_aug <- augment(micx_sp_final_withlake, type.predict = "response")
levels(micx_sp_withlake_aug$MICX_DET) <- c("Below Detection", "Above Detection")

ggplot(data = micx_sp_withlake_aug, aes(x = MICX_DET, y = .fitted)) + 
      geom_boxplot(color = "#2A6BA6", alpha=0.3) + 
      xlab("Observed") +
      ylab("Fitted Probability") 
ggsave("./inst/figures/micx_sp_final_withlake_fitted_probs.png", height = 3, width = 3)

# Map of fitted probabilities

conus <- st_transform(AOI::aoi_get(state = "conus"), 5072)
ggplot() + 
  geom_sf(data = conus, fill = "#e2e2e2", color = "white", lwd = 1) +
  geom_sf(data = arrange(micx_sp_withlake_aug, .fitted), aes(fill = .fitted), pch = 21, size = 2) +
  scale_fill_gradientn(colors = RColorBrewer::brewer.pal(9, 'YlOrRd'),
                       name = "Fitted \nProbability") +
  theme_void()
ggsave("./inst/figures/micx_sp_final_withlake_fitted_probs_map.png", width = 5, height = 3.5, units = "in", dpi = 600)

```


### Microcystin, No Lake Data

```{r}
# Set the dependent variable
dep <- "MICX_DET"

# First conduct model comparison with independent error models. We do this because fitting spatial models is computationally expensive to do so in a way that models can be compared.

# Comparing AIC/BIC between models requires the same set of observations be used for all models. Trim the dataset to include just the variables that will be investigated as potential fixed effects in the model.
dat_micx <- habs |>
  select(# Dependent variable and random effects
         MICX_DET, UNIQUE_ID, DSGN_CYCLE, 
         # Climate fixed effects
         Precip8110Ws, Tmean8110Ws, precip_mean_month, temp_mean_month, 
         # Setting fixed effects
         BFIWs, RunoffWs, AG_ECO3, 
         # Lake morphology fixed effects
         MAXDEPTH, lakemorpho_fetch, 
         # Nutrient input fixed effects
         p_dev_inputs, n_dev_inputs, N_Total_Deposition, N_Surplus, p_farm_inputs, n_farm_inputs, fst_ws, wet_ws, KffactWs) |> 
  mutate(AG_ECO3 = factor(AG_ECO3, levels = c("WMTNS", "PLNLOW", "EHIGH"))) |>
  drop_na()

# Function to run independent error models

# Set the initial covariance to be small. This produces results identifcal to glm()
spcov_init <- spcov_initial("none", ie = 1e-4, known = "ie")

run_micx_ie <- function(mod_vars, int = NULL){
  spglm(create_formula(dep_var = dep, ind_vars = mod_vars, interact = int),
        family = "binomial",
        data = dat_micx,
        estmethod = "ml",
        spcov_initial = spcov_init,
        random = ~ DSGN_CYCLE + UNIQUE_ID,
        local = T)
}

# Run a few candidate models. Tried to choose a few combinations of fixed effects from the four categories: Nutrient inputs, climate, setting, and lake morphology

# Initial model
m0 <- run_micx_ie(mod_vars = c("p_farm_inputs", "n_dev_inputs", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs"), int = NULL)

# Does the inclusion of ecoregion improve the model?
m1a <- run_micx_ie(mod_vars = c("p_farm_inputs", "n_dev_inputs", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = NULL)

# Does the inclusion of forest cover improve the model over the initial model?
m1b <- run_micx_ie(mod_vars = c("p_farm_inputs", "n_dev_inputs", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "fst_ws"), int = NULL)

# Does monthly climate data rather than annual MAT/MAP (m1) improve the model?
m2 <- run_micx_ie(mod_vars = c("p_farm_inputs", "n_dev_inputs", "precip_mean_month", "temp_mean_month", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = NULL)

# Would the addition of another variable describing nutrient inputs improve the model?
m3 <- run_micx_ie(mod_vars = c("p_farm_inputs", "n_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = NULL)

# Would interactions improve the model?
m4 <- run_micx_ie(mod_vars = c("p_farm_inputs", "n_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * MAXDEPTH")

m5 <- run_micx_ie(mod_vars = c("p_farm_inputs", "n_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")

# Review model AIC/BIC
glances(m0, m1a, m1b, m2, m3, m4, m5)

# Make a list of the independent error models to compare
micx_ie_mods <- list(m0, m1a, m1b, m2, m3, m4, m5)

# Review model AUC
micx_ie_auc <- sapply(micx_ie_mods, AUROC)

# Run leave one out cross validation
# micx_ie_loocv <- do.call(rbind, lapply(micx_ie_mods, loocv))

# Variables common to all models
com_vars <- c("p_farm_inputs", "n_dev_inputs", "BFIWs", "MAXDEPTH", "lakemorpho_fetch")

# Get the fixed effects that are different between the models
dif_vars <- sapply(micx_ie_mods, function(mod){
  coef_names <- names(mod$coefficients$fixed)
  coef_names <- coef_names[!coef_names %in% c("(Intercept)", com_vars)]
  paste(coef_names, collapse = ", ")
})

# Get any interaction terms

# Put it all together into a table, note that the table is organized by BIC
micx_ie_modcomp <- glances(m0, m1a, m1b, m2, m3, m4, m5) |>
  arrange(model) |>
  # cbind(micx_ie_loocv) |>
  select(-npar, -value, -AICc, -logLik, -pseudo.r.squared) |> 
  mutate(AUC = micx_ie_auc,
         distinct_vars = dif_vars,
         common_vars = paste(com_vars, collapse = ", ")) |>
  # arrange(BIC) |>
  tibble()

# Based on the above analysis, models m3, m4, and m5 have the lower AIC/BIC and will be run with spatial covariance for final model selection

# Function to run spatial models
run_micx_sp <- function(mod_vars, int = NULL){
  spglm(create_formula(dep_var = dep, ind_vars = mod_vars, interact = int),
        family = "binomial",
        data = dat_micx,
        spcov_type = "exponential",
        estmethod = "reml",
        random = ~ DSGN_CYCLE + UNIQUE_ID,
        local = T)
}

# Run the models with spatial covariance
m3_sp <- run_micx_sp(mod_vars = c("p_farm_inputs", "n_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = NULL)

m4_sp <- run_micx_sp(mod_vars = c("p_farm_inputs", "n_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * MAXDEPTH")

m5_sp <- run_micx_sp(mod_vars = c("p_farm_inputs", "n_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")

# Testing without ecoregion
m1a_sp <- run_micx_sp(mod_vars = c("p_farm_inputs", "n_dev_inputs", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = NULL)

m1b_sp <- run_micx_sp(mod_vars = c("p_farm_inputs", "n_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs"), int = NULL)

# Make a list of the models to compare
micx_sp_mods <- list(m1a_sp, m1b_sp, m4_sp, m5_sp)

# Review model AUC
micx_sp_auc <- sapply(micx_sp_mods, AUROC)

# Run leave one out cross validation
micx_sp_loocv <- do.call(rbind, lapply(micx_sp_mods, loocv))

# Variables common to all models
com_vars <- c("p_farm_inputs", "n_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3")

# Get the fixed effects that are different between the models
dif_vars <- sapply(micx_sp_mods, function(mod){
  coef_names <- names(mod$coefficients$fixed)
  coef_names <- coef_names[!coef_names %in% c("(Intercept)", com_vars)]
  paste(coef_names, collapse = ", ")
})

# Get any interaction terms

# Put it all together into a table
micx_sp_modcomp <- micx_sp_loocv |>
  mutate(model = c("m1a_sp", "m1b_sp", "m4_sp", "m5_sp"),
         AUC = micx_sp_auc,
         distinct_vars = dif_vars,
         common_vars = paste(com_vars, collapse = ", ")) |>
  arrange(desc(AUC)) |>
  tibble()

# The final model is model m3_sp due to the highest AUC and lowest MSPE.
# The final model should be run using all available observations and with local = F
mod_vars <- c("p_farm_inputs", "n_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3")
int <- NULL
Sys.time()
micx_sp_final_nolake <- spglm(create_formula(dep_var = dep, ind_vars = mod_vars, interact = int),
                              family = "binomial",
                              data = drop_na(habs, all_of(dep_var), all_of(mod_vars)),
                              spcov_type = "exponential",
                              estmethod = "reml",
                              random = ~ DSGN_CYCLE + UNIQUE_ID,
                              local = F)
Sys.time()

# Get AUC of final model
micx_sp_final_nolake_auc <- AUROC(micx_sp_final_nolake)

# Get bias, MSPE
micx_sp_final_nolake_loocv <- loocv(micx_sp_final_nolake)

Sys.time()

# Save the best performing micx model so far
# saveRDS(micx_sp_final_nolake, "./inst/model_objects/model_micx_nolakedata.rds")

# Visualize the results
# Boxplot of probabilities
micx_sp_nolake_aug <- augment(micx_sp_final_nolake, type.predict = "response")
levels(micx_sp_nolake_aug$MICX_DET) <- c("Below Detection", "Above Detection")

ggplot(data = micx_sp_nolake_aug, aes(x = MICX_DET, y = .fitted)) + 
      geom_boxplot(color = "#2A6BA6", alpha=0.3) + 
      xlab("Observed") +
      ylab("Fitted Probability") 
ggsave("./inst/figures/micx_sp_final_fitted_probs.png", height = 3, width = 3)

# Map of fitted probabilities
conus <- st_transform(AOI::aoi_get(state = "conus"), 5072)
ggplot() + 
  geom_sf(data = conus, fill = "#e2e2e2", color = "white", lwd = 1) +
  geom_sf(data = micx_sp_nolake_aug, aes(fill = .fitted), pch = 21, size = 2) +
  scale_fill_gradientn(colors = RColorBrewer::brewer.pal(9, 'YlOrRd'),
                       name = "Fitted \nProbability") +
  theme_void()
ggsave("./inst/figures/micx_sp_final_fitted_probs_map.png", width = 5, height = 3.5, units = "in", dpi = 600)

# Map of standardized residuals
# Organize the data so that most extreme values are plotted on top
micx_sp_nolake_aug <- micx_sp_nolake_aug|>
  mutate(plot_order = factor(case_when(.std.resid < -2 ~ "L2",
                                  .std.resid > 2 ~ "L1",
                                  .std.resid < -1 & .std.resid >= -2 ~ "L3",
                                  TRUE ~ "L4"),
                        levels = c("L1", "L2", "L3", "L4"))) |>
  arrange(desc(plot_order))

breaks <- c(-2, -1, 0, 1, 2)
cols <- rev(RColorBrewer::brewer.pal(length(breaks) + 1, "Spectral"))

ggplot() + 
  geom_sf(data = conus, fill = "#e2e2e2", color = "white", lwd = 1) +
  geom_sf(data = micx_sp_nolake_aug, 
          aes(fill = .std.resid), pch = 21, size = 1.5) +
  scale_fill_stepsn(colors = cols,
                    breaks = breaks,
                    name = "Standardized \nResiduals") +
  theme_void()
ggsave("./inst/figures/micx_nolake_stdresiduals_map_NoEcoregion.png", width = 7, height = 3.5, units = "in", dpi = 600)

```

Visuals for Merkley visit

```{r}
# Get the area for the PNW
pnw <- AOI::aoi_get(state = c("OR", "WA", "ID"))

# Retrieve model
micx_sp_final_nolake <- readRDS("./inst/model_objects/model_micx_nolakedata.rds")

# Filter data to just the PWN
pnw_micx <- micx_sp_final_nolake |>
  augment(type.predict = "response") |>
  st_transform(st_crs(pnw)) |>
  st_intersection(pnw) |>
  arrange(.fitted)

# Map of the PNW
ggplot() + 
  geom_sf(data = pnw, fill = "#e2e2e2", color = "black", lwd = 1) +
  geom_sf(data = pnw_micx, aes(fill = .fitted), pch = 21, size = 2) +
  scale_fill_gradientn(colors = RColorBrewer::brewer.pal(9, 'YlOrRd'),
                       name = "Estimated \nProbability") +
  # theme_void() +
  ggtitle("Fitted Probability of Microcystin Detection")+
  theme(plot.title = element_text(hjust = 0.5, vjust = 1, size = 12))
ggsave("./figures/FittedProbMap_Micx_PNW.png", width = 5, height = 3.5, units = "in", dpi = 600)

# Interactive map version
mapview::mapview(pnw_micx, z = ".fitted")

```



Models for microcystin concentration, when present


```{r}
dep_var  <- "MICX"

run_micxlm <- function(mod_vars, int = NULL){
  splm(create_formula(dep_var, mod_vars, log = T, interact = int),
                data = drop_na(habs, all_of(dep_var), all_of(mod_vars)),
                spcov_type = "exponential",
                random = ~ DSGN_CYCLE + UNIQUE_ID,
                local = F)
}

# Lessons learned
# Similarly to cyanobacteria cell counts, TP only becomes important when TN is removed as a covariate, signaling that these are colinear. But interesting that turbidity is important with this model in addition to TN. Would have expected these variables to be colinear so as not to overlay with each other.

# E/I has a better relationship to microcystin than d-excess.

# The addition of detected and concentration of nitrate improves the model pseudo R2, but only concentration appears to be important. Also the AIC is lower with inclusion of these variables. The addition of ammonia doesn't improve the model. Similar result with TP. TP was also negatively, which is counterintuitive. When nitrate isn't in the model and TP replaces TN, TP has a positive relationship. 

micxlm1 <- run_micxlm(mod_vars = c("NTL","PTL", "DOC", "PH", "wet_ws", "agr_ws", "precip_mean_month", "TEMPERATURE", "BFIWs", "RunoffWs", "EVAP_INFL", "MAXDEPTH", "lakemorpho_shoreline.length", "AG_ECO3"))

micxlm2 <- run_micxlm(mod_vars = c("NTL","PTL", "DOC", "PH", "wet_ws", "agr_ws", "precip_mean_month", "TEMPERATURE", "BFIWs", "RunoffWs", "EVAP_INFL", "MAXDEPTH", "lakemorpho_shoreline.length", "AG_ECO3"), int = "NTL*AG_ECO3")

micxlm3 <- run_micxlm(mod_vars = c("NTL","PTL", "DOC", "PH", "wet_ws", "agr_ws", "precip_mean_month", "TEMPERATURE", "BFIWs", "RunoffWs", "EVAP_INFL", "MAXDEPTH", "lakemorpho_shoreline.length", "AG_ECO3"), int = "PTL*AG_ECO3")

micxlm4 <- run_micxlm(mod_vars = c("NTL", "DOC", "PH", "wet_ws", "agr_ws", "precip_mean_month", "TEMPERATURE", "BFIWs", "RunoffWs", "EVAP_INFL", "MAXDEPTH", "lakemorpho_shoreline.length", "AG_ECO3"))

micxlm5 <- run_micxlm(mod_vars = c("PTL", "DOC", "PH", "wet_ws", "agr_ws", "precip_mean_month", "TEMPERATURE", "BFIWs", "RunoffWs", "EVAP_INFL", "MAXDEPTH", "lakemorpho_shoreline.length", "AG_ECO3"))

micxlm6 <- run_micxlm(mod_vars = c("NTL", "DOC", "PH", "agr_ws", "precip_mean_month", "TEMPERATURE", "BFIWs", "RunoffWs", "EVAP_INFL", "MAXDEPTH", "lakemorpho_shoreline.length", "AG_ECO3"))

micxlm7 <- run_micxlm(mod_vars = c("NTL", "DOC", "PH", "agr_ws", "precip_mean_month", "TEMPERATURE", "BFIWs", "EVAP_INFL", "MAXDEPTH", "lakemorpho_shoreline.length"))

micxlm8 <- run_micxlm(mod_vars = c("NTL", "DOC", "PH", "agr_ws", "precip_mean_month", "TEMPERATURE", "BFIWs", "EVAP_INFL", "MAXDEPTH"))

micxlm9 <- run_micxlm(mod_vars = c("NTL", "DOC", "PH", "agr_ws", "precip_mean_month", "Tmean8110Ws", "BFIWs", "EVAP_INFL", "MAXDEPTH"))

micxlm10 <- run_micxlm(mod_vars = c("NTL", "DOC", "PH", "agr_ws", "precip_mean_month", "Tmean8110Ws", "BFIWs", "EVAP_INFL", "lakemorpho_fetch"))

micxlm11 <- run_micxlm(mod_vars = c("NTL", "DOC", "PH", "agr_ws", "precip_mean_month", "Tmean8110Ws", "EVAP_INFL"))

# Best fit model with TN onlu
micxlm12 <- run_micxlm(mod_vars = c("NTL", "DOC", "PH", "TURB", "agr_ws", "precip_mean_month", "Tmean8110Ws", "EVAP_INFL"))

# Other experiments
micxlm13 <- run_micxlm(mod_vars = c("NTL", "DOC", "PH", "TURB", "agr_ws", "precip_mean_month", "Tmean8110Ws", "D_EXCESS"))

# Best fit model with TN + nitrate
micxlm14 <- run_micxlm(mod_vars = c("NTL", "NITRATE_DET", "NITRATE_N", "DOC", "PH", "TURB", "agr_ws", "precip_mean_month", "Tmean8110Ws", "EVAP_INFL"))

micxlm15 <- run_micxlm(mod_vars = c("NTL", "NITRATE_DET", "NITRATE_N", "AMMONIA_N", "DOC", "PH", "TURB", "agr_ws", "precip_mean_month", "Tmean8110Ws", "EVAP_INFL"))

micxlm16 <- run_micxlm(mod_vars = c("NTL", "NITRATE_DET", "NITRATE_N", "PTL", "DOC", "PH", "TURB", "agr_ws", "precip_mean_month", "Tmean8110Ws", "EVAP_INFL"))

micxlm17 <- run_micxlm(mod_vars = c("PTL", "NITRATE_DET", "NITRATE_N", "DOC", "PH", "TURB", "agr_ws", "precip_mean_month", "Tmean8110Ws", "EVAP_INFL"))

micxlm18 <- run_micxlm(mod_vars = c("NTL", "NITRATE_DET", "NITRATE_N", "DOC", "PH", "TURB", "agr_ws", "precip_mean_month", "Tmean8110Ws", "D_EXCESS"))

# Run with local = F
# micxlm_local_f <- run_micxlm(mod_vars = c("NTL", "DOC", "PH", "TURB", "agr_ws", "precip_mean_month", "Tmean8110Ws", "EVAP_INFL"))

summary(micxlm14)
varcomp(micxlm18)

# vis_fit(dep_var, micxlm_local_f, file_name = "Model Fit_Micx_Conc.jpg")

mod_vars = c("NTL", "NITRATE_DET", "NITRATE_N", "DOC", "PH", "TURB", "agr_ws", "precip_mean_month", "Tmean8110Ws", "EVAP_INFL")

micx_pred <- filter(drop_na(habs, all_of(dep_var), all_of(mod_vars)))

micx_loocv <- loocv(micxlm14, cv_predict = TRUE)

micx_pred$preds <- micx_loocv$cv_predict

max_val <- max(log10(micx_pred$MICX +1), micx_pred$preds)
min_val <- min(log10(micx_pred$MICX +1), micx_pred$preds)
name <- "Log10(Microcystin)"

fig <- ggplot(data = micx_pred, aes(x = preds, y = log10(MICX))) +
  geom_point(color = "blue", alpha=0.3) +
  xlim(min_val, max_val) + ylim(min_val, max_val) +
  ylab("Observed") +
  xlab("Fitted") +
  ggtitle(name)
ggsave(paste0("./figures/", "Model Fit_Micx Conc.jpg"), height = 4, width = 5, dpi = 400, units = "in")

```



Random forest experimenting

```{r}
# A good tutorial introducing random forest https://uc-r.github.io/random_forests

# Create a binary for microcystin detections
# habs <- mutate(habs, MICX_DET = factor(ifelse(is.finite(MICX), 1, 0)))

# Dependent variable 
dep_var <- "MICX_DET"

# Which set of independent variables will be considered? All available or only those available across CONUS (removing ancillary NLA water phys/chem data)?
ind_vars <- non_nla_vars

# How much missingness is there in the data?
missing_data <- habs |>
  st_drop_geometry() |>
  summarize_all(~sum(is.na(.))) |>
  pivot_longer(SITE_ID:MICX_DET, names_to = "variable", values_to = "num_missing")

# Examine if the error stabilizes with the number of trees
m1 <- randomForest::randomForest(
  formula = create_formula(dep_var, ind_vars),
  data = drop_na(habs, all_of(dep_var), all_of(ind_vars)),
  ntree = 1000
)
plot(m1)

# Tune the mTry parameter
na_free <- drop_na(habs, all_of(dep_var), all_of(ind_vars))

m2 <- randomForest::tuneRF(
  x          = st_drop_geometry(na_free[ind_vars]),
  y          = na_free$B_G_DENS,
  ntreeTry   = 1000,
  mtryStart  = 2,
  stepFactor = 1.5,
  improve    = 0.01,
  trace      = FALSE      # to not show real-time progress 
)

# hyperparameter grid search
hyper_grid <- expand.grid(
  mtry       = seq(10, 30, by = 2),
  node_size  = seq(5, 50, by = 5),
  sampe_size = c(.55, .632, .70, .80),
  OOB_RMSE   = 0
)

for(i in 1:nrow(hyper_grid)) {
  
  # train model
  model <- ranger::ranger(
    formula         = create_formula(dep_var, ind_vars, log = T, const = 1000),
    data            = st_drop_geometry(drop_na(habs, all_of(dep_var), all_of(ind_vars))), 
    num.trees       = 1000,
    mtry            = hyper_grid$mtry[i],
    min.node.size   = hyper_grid$node_size[i],
    sample.fraction = hyper_grid$sampe_size[i],
    seed            = 123
  )
  
  # add OOB error to grid
  hyper_grid$OOB_RMSE[i] <- sqrt(model$prediction.error)
}

# Which set of parameters yields the lowest OOB RMSE?
hyper_grid %>% 
  dplyr::arrange(OOB_RMSE) %>%
  head(10)

# Check expected error for optimal set of hyperparameters
OOB_RMSE <- vector(mode = "numeric", length = 200)

for(i in seq_along(OOB_RMSE)) {

  optimal_ranger <- ranger::ranger(
    formula         = create_formula(dep_var, ind_vars, log = T, const = 1000),
    data            = st_drop_geometry(drop_na(habs, all_of(dep_var), all_of(ind_vars))), 
    num.trees       = 1000,
    mtry            = 28,
    min.node.size   = 50,
    sample.fraction = .8,
    importance      = 'impurity'
  )
  
  OOB_RMSE[i] <- sqrt(optimal_ranger$prediction.error)
}

hist(OOB_RMSE, breaks = 20)

imp <- tibble(var = names(optimal_ranger$variable.importance), var_imp = optimal_ranger$variable.importance)

imp %>% 
  dplyr::arrange(desc(var_imp)) %>%
  ggplot(aes(x = reorder(var, var_imp), y = var_imp)) +
  geom_col() +
  coord_flip() +
  xlab("Variable") + ylab("Variable Importance") +
  ggtitle("Variables available for CONUS (non-NLA)")

# ggsave("./figures/Variable importance_NLA'07,'12,'17_non-NLA vars.png", dpi = 300, width = 5, height = 5)


# Given the parameter tuning, now pass the data to spmodel
modRF <- splmRF(create_formula(dep_var, ind_vars),
                data = drop_na(habs, all_of(dep_var), all_of(ind_vars)),
                spcov_type = "exponential",
                family = "binomial",
                random = ~ DSGN_CYCLE,
                local = TRUE,
                num.trees       = 1000,
                mtry            = 28,
                min.node.size   = 50,
                sample.fraction = .8,
                importance = "impurity")

modRF.imp <- tibble(var = names(modRF$ranger$variable.importance), var_imp = modRF$ranger$variable.importance)

modRF.imp %>% 
  dplyr::arrange(desc(var_imp)) %>%
  dplyr::top_n(25) %>%
  ggplot(aes(x = reorder(var, var_imp), y = var_imp)) +
  geom_col() +
  coord_flip() +
  xlab("Variable") + ylab("Variable Importance")

# ggsave("./figures/Variable importance_spMod_NLA'07,'12,'17_all.png", dpi = 300, width = 5, height = 5)

obs <- habs |>
  drop_na(all_of(dep_var), all_of(ind_vars)) |>
  st_drop_geometry() |>
  mutate(obs = log10(B_G_DENS + 1000)) |>
  pull(obs)

plot(optimal_ranger$predictions, obs)
cor.test(optimal_ranger$predictions, obs)

mod <- modRF$ranger$predictions

plot(obs, mod, ylim = c(3, max(mod, obs)), xlim = c(3, max(mod, obs)))
cor.test(mod, obs)

  
```

Experiment for the lake random effect

```{r}
# Find 50 random observations to hold out
# Make sure that site that have revisit data isn't included. Want the 50 observations to be unobserved locations in the training set.
# Since there is a lot of missing data, should pre-filter the dataset to observations that will be included for both

# Variables used in the most recent models for cyanos and microcystin detection
vars <- unique(c("BFIWs", "Tmean8110Ws", "Precip8110Ws", "n_farm_inputs", "n_dev_inputs", "p_farm_inputs", "lake_dep", "lakemorpho_fetch", "AG_ECO3", "p_farm_inputs", "N_Surplus", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"))

single_obs <- habs |>
  st_drop_geometry() |>
  drop_na(all_of(c("B_G_DENS", "MICX_DET")), all_of(vars)) |>
  group_by(UNIQUE_ID) |>
  summarise(obs_count = n()) |>
  filter(obs_count == 1) |>
  pull(UNIQUE_ID)

# The above df is organized by UNIQUE ID which is categorized by state. Taking an observation at regular intervals should give good spatial coverage of the US
length(single_obs)/50

hold_out <- sapply(1:50, function(x){single_obs[21*x]})

# Divide data into training and test sets
test  <- filter(habs, UNIQUE_ID %in% hold_out)
train <- filter(habs, !(UNIQUE_ID %in% hold_out))

# Run the models with and without a random effect for lake

# Cyanobacteria
mod_vars <- c("BFIWs", "Tmean8110Ws", "Precip8110Ws", "n_farm_inputs", "n_dev_inputs", "p_farm_inputs", "lake_dep", "lakemorpho_fetch", "AG_ECO3")

cyano_lakere <- splm(create_formula("B_G_DENS", mod_vars, log = T, const = 1000, 
                             interact = "n_farm_inputs * AG_ECO3"),
              data = filter(drop_na(train, all_of("B_G_DENS"), all_of(mod_vars))),
              spcov_type = "exponential",
              random = ~ DSGN_CYCLE + UNIQUE_ID,
              local = T)

cyano_re_nonsp <- splm(create_formula("B_G_DENS", mod_vars, log = T, const = 1000, 
                             interact = "n_farm_inputs * AG_ECO3"),
              data = filter(drop_na(train, all_of("B_G_DENS"), all_of(mod_vars))),
              spcov_type = "none",
              random = ~ DSGN_CYCLE + UNIQUE_ID,
              local = T)

cyano_nolakere <- splm(create_formula("B_G_DENS", mod_vars, log = T, const = 1000, 
                             interact = "n_farm_inputs * AG_ECO3"),
              data = filter(drop_na(train, all_of("B_G_DENS"), all_of(mod_vars))),
              spcov_type = "exponential",
              random = ~ DSGN_CYCLE,
              local = T)

cyano_nore <- splm(create_formula("B_G_DENS", mod_vars, log = T, const = 1000, 
                             interact = "n_farm_inputs * AG_ECO3"),
              data = filter(drop_na(train, all_of("B_G_DENS"), all_of(mod_vars))),
              spcov_type = "exponential",
              # random = ~ DSGN_CYCLE,
              local = T)

cyano_nonsp <- splm(create_formula("B_G_DENS", mod_vars, log = T, const = 1000, 
                             interact = "n_farm_inputs * AG_ECO3"),
              data = filter(drop_na(train, all_of("B_G_DENS"), all_of(mod_vars))),
              spcov_type = "none",
              # random = ~ DSGN_CYCLE,
              local = T)

# Compare model fit
glances(cyano_lakere, cyano_nolakere)
lakere_loocv   <- loocv(cyano_lakere)
nolakere_loocv <- loocv(cyano_nolakere)

# Predict for the training set
test$cyano_relake_preds   <- predict(cyano_lakere, newdata = test)
test$cyano_re_nonsp_preds <- predict(cyano_re_nonsp, newdata = test)
test$cyano_norelake_preds <- predict(cyano_nolakere, newdata = test)
test$cyano_nore_preds     <- predict(cyano_nore, newdata = test)
test$cyano_nonsp_preds    <- predict(cyano_nonsp, newdata = test)

# Correlations
cor(test$cyano_relake_preds, log10(test$B_G_DENS + 1000))
cor(test$cyano_re_nonsp_preds, log10(test$B_G_DENS + 1000))
cor(test$cyano_norelake_preds, log10(test$B_G_DENS + 1000))
cor(test$cyano_nore_preds, log10(test$B_G_DENS + 1000))
cor(test$cyano_nonsp_preds, log10(test$B_G_DENS + 1000))


# Plot it out
ggplot(data = test) +
  geom_point(aes(x = cyano_relake_preds, y = log10(B_G_DENS + 1000)), color = "blue") +
  geom_point(aes(x = cyano_norelake_preds, y = log10(B_G_DENS + 1000)), color = "red")


# Detection of microcystin
mod_vars <- c("p_farm_inputs", "N_Surplus", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3")
int <- "p_farm_inputs * AG_ECO3 + N_Surplus * lake_dep"

micx_lakere <- spglm(create_formula(dep_var = "MICX_DET", ind_vars = mod_vars, interact = int),
                     family = "binomial",
                     data = drop_na(train, all_of(dep_var), all_of(mod_vars)),
                     spcov_type = "exponential",
                     random = ~ DSGN_CYCLE + UNIQUE_ID,
                     local = T)

micx_nonsp <- spglm(create_formula(dep_var = "MICX_DET", ind_vars = mod_vars, interact = int),
                     family = "binomial",
                     data = drop_na(train, all_of(dep_var), all_of(mod_vars)),
                     spcov_type = "none",
                     random = ~ DSGN_CYCLE + UNIQUE_ID,
                     local = T)

micx_nolakere <- spglm(create_formula(dep_var = "MICX_DET", ind_vars = mod_vars, interact = int),
                     family = "binomial",
                     data = drop_na(train, all_of(dep_var), all_of(mod_vars)),
                     spcov_type = "exponential",
                     random = ~ DSGN_CYCLE,
                     local = T)

micx_nore <- spglm(create_formula(dep_var = "MICX_DET", ind_vars = mod_vars, interact = int),
                     family = "binomial",
                     data = drop_na(train, all_of(dep_var), all_of(mod_vars)),
                     spcov_type = "exponential",
                     # random = ~ DSGN_CYCLE,
                     local = T)

micx_nore_nonsp <- spglm(create_formula(dep_var = "MICX_DET", ind_vars = mod_vars, interact = int),
                     family = "binomial",
                     data = drop_na(train, all_of(dep_var), all_of(mod_vars)),
                     spcov_type = "none",
                     # random = ~ DSGN_CYCLE,
                     local = T)

aug_lakere     <- augment(micx_lakere, newdata = test)
aug_nonsp      <- augment(micx_nonsp, newdata = test)
aug_nolakere   <- augment(micx_nolakere, newdata = test)
aug_nore       <- augment(micx_nore, newdata = test)
aug_nore_nonsp <- augment(micx_nore_nonsp, newdata = test)

pROC::auc(aug_lakere$MICX_DET, aug_lakere$.fitted)
pROC::auc(aug_nonsp$MICX_DET, aug_nonsp$.fitted)
pROC::auc(aug_nolakere$MICX_DET, aug_nolakere$.fitted)
pROC::auc(aug_nore$MICX_DET, aug_nore$.fitted)
pROC::auc(aug_nore_nonsp$MICX_DET, aug_nore_nonsp$.fitted)


pROC::auc(with(aug_nonsp, MICX_DET, .fitted))
pROC::auc(with(aug_nolakere, MICX_DET, .fitted))
pROC::auc(with(aug_nore, MICX_DET, .fitted))
pROC::auc(with(aug_nore_nonsp, MICX_DET, .fitted))


test$lakere <- predict(micx_lakere, newdata = test)
test$nonsp <- predict(micx_nonsp, newdata = test)
test$nolakere <- predict(micx_nolakere, newdata = test)
test$nolakere <- predict(micx_nolakere, newdata = test)


```



Try random forest with large collection of data from Robert Sabo


```{r}
# All data from Robert (untransformed)
nni <- readr::read_csv("NLA07-12_NutrientInventory_Data.csv")

# Have to break out the month and day of the compiled HABs data
comp <- habs |>
  mutate(Month = as.numeric(format(as.Date(DATE_COL, format = "%m/%d/%Y"), "%m")),
         Day = as.numeric(format(as.Date(DATE_COL, format = "%m/%d/%Y"), "%d")),
         Year = as.numeric(as.character(DSGN_CYCLE))) |>
  # select(SITE_ID, Year, Month, Day, B_G_DENS, TEMPERATURE, DOC, TURB, PH, EVAP_INFL, lakemorpho_depth, ElevWs, SlopeWs) 
  # Remove redundant variables
  select(-NTL, -PTL, -RunoffWs, -LAT_DD83, -LON_DD83, -DATE_COL, -DSGN_CYCLE, -VISIT_NO, -COMID, -MICX, -CHLA_RESULT, -CYLSPER, -UNIQUE_ID)

# Merge with cyanobacteria counts
comp <- left_join(nni, comp, by = c("SITE_ID", "Year", "Month", "Day"))

# Create a vector of the independent variables
nni_vars <- colnames(comp)[c(9:91,93:(length(colnames(comp))-1))] #

# Examine if the error stabilizes with the number of trees
m1 <- randomForest::randomForest(
  formula = create_formula(dep_var, nni_vars, log = T),
  data = drop_na(comp, all_of(dep_var), all_of(nni_vars))
)
plot(m1)

# Tune the mTry parameter
na_free <- drop_na(comp, all_of(dep_var), all_of(nni_vars))

m2 <- randomForest::tuneRF(
  x          = st_drop_geometry(na_free[nni_vars]),
  y          = log10(na_free$B_G_DENS + 1),
  ntreeTry   = 500,
  mtryStart  = 4,
  stepFactor = 1.5,
  improve    = 0.01,
  trace      = FALSE      # to not show real-time progress 
)

# hyperparameter grid search
hyper_grid <- expand.grid(
  mtry       = seq(25, 35, by = 2),
  node_size  = seq(3, 9, by = 2),
  sampe_size = c(.55, .632, .70, .80),
  OOB_RMSE   = 0
)

for(i in 1:nrow(hyper_grid)) {
  
  # train model
  model <- ranger::ranger(
    formula         = create_formula(dep_var, nni_vars, log = T),
    data            = st_drop_geometry(drop_na(comp, all_of(dep_var), all_of(nni_vars))), 
    num.trees       = 500,
    mtry            = hyper_grid$mtry[i],
    min.node.size   = hyper_grid$node_size[i],
    sample.fraction = hyper_grid$sampe_size[i],
    seed            = 123,
    num.threads     = 8
  )
  
  # add OOB error to grid
  hyper_grid$OOB_RMSE[i] <- sqrt(model$prediction.error)
}

# Which set of parameters yields the lowest OOB RMSE?
hyper_grid %>% 
  dplyr::arrange(OOB_RMSE) %>%
  head(15)

# Check expected error for optimal set of hyperparameters
OOB_RMSE <- vector(mode = "numeric", length = 100)

for(i in seq_along(OOB_RMSE)) {

  optimal_ranger <- ranger::ranger(
    formula         = create_formula(dep_var, nni_vars, log = T),
    data            = st_drop_geometry(drop_na(comp, all_of(dep_var), all_of(nni_vars))), 
    num.trees       = 500,
    mtry            = 29,
    min.node.size   = 3,
    sample.fraction = .8,
    num.threads     = 8, 
    importance      = 'impurity'
  )
  
  OOB_RMSE[i] <- sqrt(optimal_ranger$prediction.error)
}

hist(OOB_RMSE, breaks = 20)

optimal_ranger <- ranger::ranger(
  formula         = create_formula(dep_var, nni_vars, log = T),
  data            = drop_na(comp, all_of(dep_var), all_of(nni_vars)), 
  num.trees       = 500,
  mtry            = 29,
  min.node.size   = 3,
  sample.fraction = .8,
  num.threads     = 8, 
  importance      = 'impurity')

imp <- tibble(var = names(optimal_ranger$variable.importance), var_imp = optimal_ranger$variable.importance)

imp %>% 
  dplyr::arrange(desc(var_imp)) %>%
  dplyr::top_n(25) %>%
  ggplot(aes(x = reorder(var, var_imp), y = var_imp)) +
  geom_col() +
  coord_flip() +
  xlab("Variable") + ylab("Variable Importance") +
  ggtitle("NLA '07,'12_All Variables")

ggsave("./figures/Variable importance_NLA'07,'12_all.png", dpi = 300, width = 5, height = 5)

########################################################

# Have to break out the month and day of the compiled HABs data
comp <- habs |>
  mutate(Month = as.numeric(format(as.Date(DATE_COL, format = "%m/%d/%Y"), "%m")),
         Day = as.numeric(format(as.Date(DATE_COL, format = "%m/%d/%Y"), "%d")),
         Year = as.numeric(as.character(DSGN_CYCLE))) |>
  select(-NTL, -PTL, -RunoffWs) |>
  right_join(nni, by = c("SITE_ID", "Year", "Month", "Day")) # |>
  # filter(!duplicated(UNIQUE_ID)) # If running with unique observations

# Investigate how the year random effect interacts with some data that is specific to the sample year
nni_sub <- c(all_vars, "LSTAnomaly_YrMean", "NPP_YrMean", "Precip_YrMean", "Tmean_YrMean")

nni_no_re_no_sp <- splm(create_formula(dep_var, nni_sub, log = T),
                     data = drop_na(comp, all_of(dep_var), all_of(nni_sub)),
                     spcov_type = "none", 
                     local = TRUE)

nni_no_re <- splm(create_formula(dep_var, nni_sub, log = T),
                     data = drop_na(comp, all_of(dep_var), all_of(nni_sub)),
                     spcov_type = "exponential", 
                     local = TRUE)

nni_re_site <- splm(create_formula(dep_var, nni_sub, log = T),
                         data = drop_na(comp, all_of(dep_var), all_of(nni_sub)),
                         spcov_type = "exponential",
                         random = ~  UNIQUE_ID,
                         local = TRUE)

nni_re_year <- splm(create_formula(dep_var, nni_sub, log = T),
                         data = drop_na(comp, all_of(dep_var), all_of(nni_sub)),
                         spcov_type = "exponential",
                         random = ~  DSGN_CYCLE,
                         local = TRUE)

nni_unnest_re <- splm(create_formula(dep_var, nni_sub, log = T),
                       data = drop_na(comp, all_of(dep_var), all_of(nni_sub)),
                       spcov_type = "exponential",
                       random = ~ DSGN_CYCLE + UNIQUE_ID,
                       local = TRUE)

nni_nest_re <- splm(create_formula(dep_var, nni_sub, log = T),
                       data = drop_na(comp, all_of(dep_var), all_of(nni_sub)),
                       spcov_type = "exponential",
                       random = ~ (DSGN_CYCLE / UNIQUE_ID),
                       local = TRUE)

# Compare model with no spatial component, with spatial component, random effect for site alone, random effect for year along, random effect for site and year unnested, random effect for site nested within year.
# How does the AIC and R2 change with these model configurations
glances(nni_no_re_no_sp,
        nni_no_re,
        nni_re_site,
        nni_re_year,
        nni_unnest_re,
        nni_nest_re)
# Nested random effects had the lowest AIC and R2 followed by unnested random effects
# About the same amount of variation is explained with no random effects

optimal_ranger <- ranger::ranger(
  formula         = create_formula(dep_var, nni_sub, log = T),
  data            = drop_na(comp, all_of(dep_var), all_of(nni_sub)), 
  num.trees       = 500,
  mtry            = 8,
  min.node.size   = 3,
  sample.fraction = .8,
  num.threads     = 8, 
  importance      = 'impurity')

imp <- tibble(var = names(optimal_ranger$variable.importance), var_imp = optimal_ranger$variable.importance)

imp %>% 
  dplyr::arrange(desc(var_imp)) %>%
  dplyr::top_n(25) %>%
  ggplot(aes(x = reorder(var, var_imp), y = var_imp)) +
  geom_col() +
  coord_flip() +
  xlab("Variable") + ylab("Variable Importance") +
  ggtitle("NLA '07,'12_All Variables")

ggsave("./figures/Variable importance_NLA'07,'12_with annual.png", dpi = 300, width = 5, height = 5)


```



---
title: "drivers_analysis"
author: "Handler"
date: '2022-11-21'
output: html_document
editor_options: 
  chunk_output_type: console
---

Based on data compiled in drivers_compilation.Rmd

```{r setup, include=FALSE}
library(usethis)
library(devtools)
library(spmodel)
library(sf)
library(mapview)
library(dplyr)
library(tidyr)
library(ggplot2)
library(corrplot)

# Load all data and functions from HABsDrivers package
load_all()

# Detailed guide to spmodel
# https://usepa.github.io/spmodel/articles/guide.html
```


Some additional variables:

```{r}
# Calculate the chlorophyll a associated with cyanobacteria
habs <- mutate(habs, CHLA_CYANO = CHLA_RESULT * BG_BIOVOL/PHYT_BIOVOL, .after = CHLA_RESULT)

# Add a binary 1/0 variable for detect/non-detect of nitrate
habs <- mutate(habs, NITRATE_DET = ifelse(is.na(NITRATE_N), 0, 1), .after = NITRATE_N)

# Replace non-detect values for nitrate with 0
habs <- mutate(habs, NITRATE_N = ifelse(is.na(NITRATE_N), 0, NITRATE_N))

habs <- habs |>
  # Robert suggested using agricultural inputs rather than land cover
  mutate(n_farm_inputs = N_Fert_Farm + N_CBNF + N_livestock_Waste,
         n_dev_inputs = N_Human_Waste + N_Fert_Urban,
         p_farm_inputs = P_f_fertilizer + P_livestock_Waste,
         p_dev_inputs = P_human_waste_kg + P_nf_fertilizer) |> # ,
         # nfarm_inputs_pres = ifelse(n_farm_inputs == 0, 0, 1),
  # Creating a categorical variable for lake depth
  mutate(lake_dep = ifelse(MAXDEPTH <= 10, "shallow", "deep"))

# Create a categorical variable for microcystin detection
habs <- mutate(habs, MICX_DET = factor(ifelse(is.finite(MICX), 1, 0)))

# There is a MAXDEPTH measurement that is close to 1000 m and three lakemorpho observations > 500 m. Need to remove these.
# There are also some extreme values for the nutrient inputs. Could this be an issue with the watershed area?
# In addition, there are three water temperatures that exceed 50 degC, including over 250 degC (!) that should be removed.
habs <- habs|>
  mutate(MAXDEPTH = ifelse(MAXDEPTH > 200, NA, MAXDEPTH),
         lakemorpho_depth = ifelse(lakemorpho_depth > 500, NA, lakemorpho_depth),
         n_farm_inputs = ifelse(n_farm_inputs > 600, NA, n_farm_inputs),
         p_farm_inputs = ifelse(p_farm_inputs > 100, NA, p_farm_inputs),
         n_dev_inputs = ifelse(n_dev_inputs > 100, NA, n_dev_inputs),
         p_dev_inputs = ifelse(p_dev_inputs > 100, NA, p_dev_inputs),
         N_Surplus = ifelse(N_Surplus > 3000, NA, N_Surplus),
         TEMPERATURE = ifelse(TEMPERATURE > 50, NA, TEMPERATURE))
```


Examine the predictor data for colinear variables
- TN and DOC
- Precip8110Ws and Precip_Minus_EVTWs and RunoffWs
- nondev_ws and agr_ws
- SlopeWs and ElevWs
- N_Total_Inputs, N_Surplus, P_Surplus (r > 0.90)


```{r}
cormat_pred <- cor(st_drop_geometry(select(habs, TEMPERATURE:P_Surplus)), use = "pairwise.complete.obs")

# Trim to just the variables explored in the models
cor_dat <- habs |>
  st_drop_geometry() |>
  select(TEMPERATURE, MAXDEPTH, AMMONIA_N, DOC:NITRATE_N, PH, D_EXCESS, EVAP_INFL, fst_ws, wet_ws, precip_mean_month, temp_mean_month, lakemorpho_fetch, BFIWs, KffactWs:Precip_Minus_EVTWs, Precip8110Ws, Tmean8110Ws, N_Total_Deposition, n_farm_inputs:p_dev_inputs) |>
  relocate(NTL, PTL, NITRATE_N, AMMONIA_N, DOC, PH, TEMPERATURE, TURB, D_EXCESS, EVAP_INFL, fst_ws, wet_ws, KffactWs, n_farm_inputs, p_farm_inputs, n_dev_inputs, p_dev_inputs, N_Total_Deposition, precip_mean_month, temp_mean_month, Precip8110Ws, Tmean8110Ws, Precip_Minus_EVTWs, RunoffWs, BFIWs, MAXDEPTH, lakemorpho_fetch)

var_names <- c("Total N", 
               "Total P",   
               "Nitrate", 
               "Ammonia", 
               "DOC", 
               "pH", 
               "Water Temp",
               "Turbidity",
               "Evaporation",
               "Evaporation/Inflow",
               "Forest Cover", 
               "Wetland Cover",
               "Soil Erodability",
               "Farm N",
               "Farm P",
               "Developed N", 
               "Developed P",
               "Deposition N", 
               "Monthly Precip",
               "Monthly Temp",
               "Annual Precip", 
               "Annual Air Temp",
               "Annual Precip-ET",
               "Runoff", 
               "Baseflow Index",
               "Lake Depth",
               "Lake Fetch")

cormat_pred <- cor(cor_dat, use = "pairwise.complete.obs", method = "spearman")

colnames(cormat_pred) <- var_names
rownames(cormat_pred) <- var_names

# Square plot
corrplot.mixed(cormat_pred, upper = "ellipse", diag = "n", tl.pos = "lt", tl.col = "black", tl.srt = 45)

# Lower triangle plot
cor_drivers <- corrplot(cormat_pred, method = "ellipse", type = "lower", tl.col = "black", tl.srt = 45)

# Save the plot
png(filename = "./figures/Correlation Matrix of Major Drivers.png", height = 6, width = 6, units = "in", bg = "transparent", res = 600)
corrplot(cormat_pred, method = "ellipse", type = "lower", tl.col = "black", tl.srt = 45)
dev.off()

```


How much of the variation in the response variables is potentially explainable based on the spatial versus temporal variation?


```{r}
# Assess spatial (signal) to temporal (noise) in response variables
do.call(rbind, lapply(c("MICX", "B_G_DENS", "CHLA_RESULT", "CHLA_CYANO"), function(x){
  form <- as.formula(paste(x, " ~ 1 + (1|SITE_ID)"))
  df   <- habs
  
  if(x == "MICX"){
    df <- drop_na(df, MICX)
  }
  
  if(x == "B_G_DENS" | x == "MICX"){
    form <- as.formula(paste("log10(", x, "+ 1) ~ 1 + (1|SITE_ID)"))
  }
  
  if(x == "CHLA_RESULT"){
    form <- as.formula(paste("log10(", x, ") ~ 1 + (1|SITE_ID)"))
  }
  
  if(x == "CHLA_CYANO"){
    form <- as.formula(paste("log10(", x, ") ~ 1 + (1|SITE_ID)"))
  }
  
  mod         <- lme4::lmer(form, data = df, REML = T, verbose = F)
  site.var    <- as.numeric(lme4::VarCorr(mod)) 
  visit.var   <- attr(lme4::VarCorr(mod), "sc")^2
  sn          <- site.var / visit.var
  maxR2       <- sn/(sn + 1)
  return(data.frame(variable = x, maxR2))
}))

```

Model setup

```{r model setup}
# Create variable groups
all_vars     <- colnames(habs)[match("TEMPERATURE", colnames(habs)):match("P_nf_fertilizer", colnames(habs))]
# Add in ecoregion
all_vars     <- c(all_vars, "AG_ECO3", "AG_ECO9_NM")
dep_vars     <- c("B_G_DENS", "MICX", "CYLSPER", "CHLA_RESULT", "CHLA_CYANO", "BG_BIOVOL", "PHYT_BIOVOL")
all_ind_vars <- all_vars[!all_vars %in% dep_vars]

# Dropping non-developed area of the watershed due to issues of colinearity with developed area. Also dropping nitrate data since it is missing for a large number of observations.
# all_ind_vars <- all_ind_vars[!all_ind_vars %in% c("nondev_ws", "NITRATE_N")]
# Dropping non-developed area of the watershed due to issues of colinearity with developed area.
all_ind_vars <- all_ind_vars[!all_ind_vars == "nondev_ws"]

# NLA water variables
nla_ind_vars <- c("TEMPERATURE", "MAXDEPTH", "STRATIFIED", "AMMONIA_N", "DO_SURF", "DOC", "NTL", "PTL", "TURB", "NITRATE_N", "NITRATE_DET", "PH", "EVAP_INFL", "D_EXCESS")
  
# All non-NLA variables
non_nla_vars <- all_ind_vars[!all_ind_vars %in% nla_ind_vars]

# All nutrient inventory variables
nni_vars <- colnames(habs)[match("N_CBNF", colnames(habs)):match("P_nf_fertilizer", colnames(habs))]

```

Helper to visualize fitted versus observed values from the model results

```{r}
vis_fit <- function(dep_var, splm_obj, file_name = NULL, width = 5, height = 4, dpi = 400){
  
  # Augment the splm object with the .fitted data
  aug <- augment(splm_obj) |>
    rename(obs = 1)
  
  # Title the figure according to response variable modeled
  name <- "Log10(Cyanobacteria + 1)"
  
  if(dep_var == "MICX_DET"){name = "Probability Microcystin Presence/Absence"}
  if(dep_var == "MICX"){name = "Log10(Microcystin Concentration)"}
  
  fig <- NULL
  
  # Construct the figure, continuous case
  if(dep_var == "MICX" | dep_var == "B_G_DENS"){
    
    # Max values for the axes
    max_val <- max(pull(aug, obs), pull(aug, .fitted))
    
    fig <- ggplot(data = aug, aes(x = obs, y = .fitted)) + 
      geom_point(color = "blue", alpha=0.3) + 
      xlim(0, max_val) + ylim(0, max_val) +
      xlab("Observed") +
      ylab("Fitted") +
      ggtitle(name)
  }
  
  # Binary case
  if(dep_var == "MICX_DET"){
    levels(aug$obs) <- c("Absent", "Present")
    
    fig <- ggplot(data = aug, aes(x = obs, y = .fitted)) + 
      geom_boxplot(color = "#2A6BA6", alpha=0.3) + 
      xlab("Observed") +
      ylab("Fitted") +
      ggtitle(name)
  }
  
  # Save the figure
  if(is.null(file_name) == FALSE){ggsave(paste0("./figures/", file_name), height = height, width = width, dpi = dpi, units = "in")}
  
  # Print a correlation test
  fit_test <- NULL
  if(dep_var == "MICX_DET"){fit_test = pROC::auc(aug$obs, aug$.fitted)}
  if((dep_var == "MICX" | dep_var == "B_G_DENS")){fit_test = cor.test(pull(aug, obs), pull(aug, .fitted))}
  
  print(fit_test)
  
  return(fig)
}

```


Experiment with some spatial models


```{r cyano models}

# Find a constant to add to the cyano for the log transformation

# function to find c
find_c <- function(par, formula, data) {
  const <- exp(par)
  mf <- model.frame(formula, data)
  data$.y <- log(model.response(mf) + const)
  new_formula <- update(formula, .y ~ .)
  lmod <- lm(new_formula, data)
  resids <- residuals(lmod)
  sigma <- summary(lmod)$sigma
  n <- NROW(data)
  ratio <- resids/sigma
  g1 <- sum(ratio^3) / n
  g2p <- sum(ratio^4) / n - 3
  g2 <- g2p + 6 / (lmod$df.residual + 2)
  g0 <- abs(g1) + abs(g2)
  g0
}

set.seed(1)

# example data
dat <- data.frame(x = rnorm(10), y = rnorm(10, mean = 10))

# HABs data
dat <- st_drop_geometry(drop_na(select(habs, B_G_DENS, NTL, NITRATE_N, NITRATE_DET, AMMONIA_N, DOC, PH, TURB, Precip8110Ws, Tmean8110Ws, EVAP_INFL, MAXDEPTH, lakemorpho_fetch, AG_ECO3)))

# finds the c for log(y + c) (note that y should be on the original scale for
# the purposes of this function, as I take the log inside)
out <- optim(0, fn = find_c, formula = B_G_DENS ~ NTL, NITRATE_N, NITRATE_DET, AMMONIA_N, DOC, PH, TURB, Precip8110Ws, Tmean8110Ws, EVAP_INFL, MAXDEPTH, lakemorpho_fetch, AG_ECO3 + MAXDEPTH * NTL, data = dat, method = "Brent", lower = -10, upper = 10)
c_value <- exp(out$par)
print(c_value)

# 2024-01-24 Models on cyanobacteria cell counts using all available explanatory variables

# Lessons learned: 

# There is a lot of missing biovolume data. Enough that I switched back to cyano count data. Will need to check with Karen about why so much data is missing for this parameter.

# TP isn't important unless TN is removed from the model. These two variables are likely highly colinear. Both TN and TP come out as important in the model if one of them has an interaction with three aggregated ecoregions. With TN*AG_ECO3, both the plains and western mountains come out as important plus the interaction between the plains and TN. With TP*AG_ECO3, the plains are important alone and there is an interaction between the plains and the western mountains and TP. When the interaction term is present between TN and the ecoregions, the effect of precipitation 30 yr normals and EVAP/INFL is lessened. However, the model with the lowest AIC lacks the interaction term. 

# Watershed mean slope and elevation were coming out as highly related to cyanos, but the effect diminished with the addition of the ecoregional data as a categorical variable. It's likely that slope and elevation were acting as proxies for the western mountain and xeric ecoregions that have much lower cyanos compared to other regions. Therefore, decided to include just the three aggregated ecoregions. 

# Also, the ecoregions are included as a fixed rather than a random effect now since the effect seems to be important and not an artifact of the NLA design. 

# Might consider playing around with having an ecoregional interaction term with some of the variables. This seemed promising when there was an interaction between ecoregion and TN, but not with any other variables (tried temp and agriculture). 

# The 30-year climate normals for temp and precip always outperformed the monthly means in which the sample was collected and the water temperature at the time of sampling. This is likely at least in part to the inclusion of a survey year random effect, but when survey year is removed and monthly means included, the model performs substantially worse.

# Note that in some preliminary tests the spatial regression models are explianing ~40-55% of the variation cyano count data while the random forest model explains ~28%.

# Experimenting with including nitrate in the models. Nitrate detection and concentration are negatively associated with cyanobacteria. TN, nitrate detected, and nitrate concentration can all be included in the same model. These three variables can also be included with TP and it comes out as important, though negatively correlated with cyanos which is confusing. Note that the addition of nitrate and ammonium variables increases the AIC relative to a model that only includes TN.

# Switched out E/I for d-excess following a conversation with Renee Brooks. D-excess is a measure of how much how evaporated the water is. When water is still, there is a higher evaporation rate. So d-excess can be thought of as a proxy for how long water has been sitting around evaporating. When d-excess is low, the water is more evaporated. It seems to have a stronger relationship with cyanos.

# Tried running the model as both Poisson and negative bionomial. Fits did not meaningfully change and interpretation is much more challenging. Decided to stick with a linear model for the time-being.

# Ran the code from Mike to identify an appropriate value of a constant to add to the cyano data in order to log transform. The constan

# Now that I am adding an optimized constant (1000) to the model, the effect of the ecoregion has disappeared. Now, when both TN and TP are in the model, they can both be important; although TP is less important than TN.

# Playing around with interactions between the ecoregions and TN, TP, and DOC and finding that generally the interaction has a negative coefficient value. I think that means that within a given ecoregion, increases in TN or TP or DOC are associated with a decrease in cyanos. Not sure how to square that with the overall positive realtionship with TN and TP. When there's an interaction between DOC and ecoregion, the direction of the overall relationship switches from negative to positive and then the interaction coefficients are negative.

# When total agricultural N inputs or excess agricultural N inputs are substituted in instead of agricultural cover, there variable is not significantly related and was negatively related to cyanos, which doesn't make sense. 

# Try an interactions between shallow and deep lakes per Jim Carleton's suggestion. Finding that both MAXDEPTH and depth as a categorical variable is important.

# Construct the model
dep_var  <- "B_G_DENS"
const <- 1000

# Function to run the cyano models by only supplying the model vars and the interaction term
run_cyano <- function(mod_vars, interact){
  splm(create_formula(dep_var, mod_vars, log = T, const = const, interact),
              # Edited to run for a unified set of observations for the purposes of model comparison
              data = filter(drop_na(habs, all_of(dep_var), all_of(mod_vars))),
              spcov_type = "exponential",
              random = ~ DSGN_CYCLE + UNIQUE_ID,
              estmethod = "ml",
              local = T)
}

# Model comparison

# Set the western mountains to the base group
habs <- mutate(habs, AG_ECO3 = factor(AG_ECO3, levels = c("WMTNS", "PLNLOW", "EHIGH")))

# Filter to the same set of observations for model comparison
habs_mod <- habs |>
  select(B_G_DENS, NTL, PTL, NITRATE_N, NITRATE_DET, AMMONIA_N, DOC, PH, TURB, Precip8110Ws, Tmean8110Ws, precip_mean_month, temp_mean_month, EVAP_INFL, MAXDEPTH, lakemorpho_fetch, AG_ECO3, UNIQUE_ID, DSGN_CYCLE) |>
  drop_na()

# Does TN or TP fit better?
cy1 <- run_cyano(mod_vars = c("NTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "TURB", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch"), interact = NULL)

cy2 <- run_cyano(mod_vars = c("PTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "TURB", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch"), interact = NULL)

# Monthly mean temperature and precipitation or climate normals?
cy3 <- run_cyano(mod_vars = c("NTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "TURB", "precip_mean_month", "temp_mean_month", "EVAP_INFL", "MAXDEPTH"), interact = NULL)

# Are there ecoregional differences?
cy4 <- run_cyano(mod_vars = c("NTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "TURB", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3"), interact = NULL)

# Do interactions improve the model?
cy5 <- run_cyano(mod_vars = c("NTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "TURB", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch"), interact = "MAXDEPTH * NTL")

cy6 <- run_cyano(mod_vars = c("NTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "TURB", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3"), interact = "AG_ECO3 * NTL")

# Make a table of the model comparison

# Variables common to all models
com_vars <- c("NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "TURB", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch")

# Which models are included in the table?
cy_list <- list(cy1, cy2, cy3, cy4, cy5, cy6)

# Get the fixed effects that are different between the models
dif_vars <- sapply(cy_list, function(mod){
  coef_names <- names(mod$coefficients$fixed)
  coef_names <- coef_names[!coef_names %in% c("(Intercept)", com_vars)]
  paste(coef_names, collapse = ", ")
})

# Get the loocv to get the R^2 between observed and fit
mods_loocv <- do.call(rbind, lapply(cy_list, loocv))

# Put it all together into a table
cy_res_table <- glances(cy1, cy2, cy3, cy4, cy5, cy6) |>
  arrange(model) |>
  select(model, n, p, npar, AIC, AICc, BIC) |>
  cbind(mods_loocv) |>
  mutate(distinct_vars = dif_vars,
         common_vars = paste(com_vars, collapse = ", ")) |>
  arrange(BIC) |>
  tibble()
  
# Evaluate fit of best model
cyano_pred       <- habs_mod
cyano_loocv      <- loocv(cy5, cv_predict = TRUE)
cyano_pred$preds <- cyano_loocv$cv_predict

max_val <- max(log10(cyano_pred$B_G_DENS + const), cyano_pred$preds)
name    <- paste0("Log10(Cyanobacteria + ", const,")")

fig <- ggplot(data = cyano_pred, aes(x = preds, y = log10(B_G_DENS + const))) +
  geom_hex(bins = 60) +
  scale_fill_continuous(type = "viridis") +
  xlim(2.8, max_val) + ylim(2.8, max_val) +
  ylab("Observed") +
  xlab("Fitted") +
  ggtitle(name)
ggsave(paste0("./figures/", "Model Fit_Cyano_With NLA.jpg"), fig, height = 4, width = 5, bg = "transparent", dpi = 400, units = "in")

# Save the model
# saveRDS(cy5, "./inst/model_objects/model_cyano_withlakedata.rds")

### Cyanobacteria models without NLA covariates ###

# *** Turns out I was using mass of N and P inputs rather than area-normalized inputs. This has been updated in the input data. Now N and P inputs are on a per hectare basis and the numbers are more reasonable and not in the billions/millions. ***

# Individual N and P inputs were not really related to cyanos. Only N_CBNF was significantly related to cyanos, but the relationship was negative. Sometimes P_livestock_waste was related and was positive. Total_N_Inputs was negatively related to cyanos. 

# Summarizing N and P inputs into farm and development categories did not result in any of the variables being significantly related to the cyanobacteria counts.

# Piling in non-inventory watershed variables improves the amount of variation explained, but not by much. Agriculture and developed land cover in the watershed is more associated with cyanobacteria that any of the nutrient inventory variables. 

# There are a few extremely high observations of N farm inputs. Perhaps try log-transforming this covariate? Then there are >800 observations with no N farm inputs. So created a variable for the presence/absence of farm inputs. Even still, these variables almost never come out as important.

# On recommendation from Ryan, I tried removing the random effect for the lake ID. It appears that the variation assigned to the lake ID gets reallocated to the spatially dependent error term. 

# There are still a bunch of extreme values for the N and P inputs. Even when these extreme values are removed, it doesn't result in covariates having stronger relationships with the response.

# Baseflow index is more strongly related than runoff.

# Adding N_Rock and N_Total_Dep were related when included together, but N_Rock was negatively related. N_Total_Dep was positively related. 

# Construct the model

# Filter to the same set of observations for model comparison
habs_mod <- habs |>
  select(B_G_DENS, Precip8110Ws, Tmean8110Ws, precip_mean_month, temp_mean_month, BFIWs, MAXDEPTH, lakemorpho_fetch, p_dev_inputs, N_Total_Deposition, p_farm_inputs, n_farm_inputs, fst_ws, AG_ECO3, UNIQUE_ID, DSGN_CYCLE) |>
  drop_na()

# Different combos of nutrient drivers
c2 <- run_cyano(mod_vars = c("n_farm_inputs", "p_dev_inputs", "Precip8110Ws", "Tmean8110Ws", "BFIWs", "MAXDEPTH", "lakemorpho_fetch"), interact = NULL)

c3 <- run_cyano(mod_vars = c("N_Total_Deposition", "p_farm_inputs", "Precip8110Ws", "Tmean8110Ws", "BFIWs", "MAXDEPTH", "lakemorpho_fetch"), interact = NULL)

c4 <- run_cyano(mod_vars = c("n_farm_inputs", "p_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "BFIWs", "MAXDEPTH", "lakemorpho_fetch"), interact = NULL)

# Climate normals versus monthly precip and temp
c5 <- run_cyano(mod_vars = c("n_farm_inputs", "p_dev_inputs", "fst_ws", "precip_mean_month", "temp_mean_month", "BFIWs", "MAXDEPTH", "lakemorpho_fetch"), interact = NULL)

# Ecoregions
c6 <- run_cyano(mod_vars = c("n_farm_inputs", "p_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "BFIWs", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3"), interact = NULL)

# Interactions
c7 <- run_cyano(mod_vars = c("n_farm_inputs", "p_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "BFIWs", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3"), interact = "MAXDEPTH * n_farm_inputs")

c8 <- run_cyano(mod_vars = c("n_farm_inputs", "p_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "BFIWs", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3"), interact = "AG_ECO3 * n_farm_inputs")

# Variables common to all models
com_vars <- c("BFIWs", "MAXDEPTH", "lakemorpho_fetch")

# Which models are included in the table?
cy_list <- list(c2, c3, c4, c5, c6, c7, c8)

# Get the fixed effects that are different between the models
dif_vars <- sapply(cy_list, function(mod){
  coef_names <- names(mod$coefficients$fixed)
  coef_names <- coef_names[!coef_names %in% c("(Intercept)", com_vars)]
  paste(coef_names, collapse = ", ")
})

# Get the loocv to get the R^2 between observed and fit
mods_loocv <- do.call(rbind, lapply(cy_list, loocv))

# Put it all together into a table
cy_res_table <- glances(c2, c3, c4, c5, c6, c7, c8) |>
  arrange(model) |>
  select(model, n, p, npar, AIC, AICc, BIC) |>
  cbind(mods_loocv) |>
  mutate(distinct_vars = dif_vars,
         common_vars = paste(com_vars, collapse = ", ")) |>
  arrange(BIC) |>
  tibble()
  
# Evaluate fit of best model
cyano_pred       <- habs_mod
cyano_loocv      <- loocv(c4, cv_predict = TRUE)
cyano_pred$preds <- cyano_loocv$cv_predict

max_val <- max(log10(cyano_pred$B_G_DENS + const), cyano_pred$preds)
name    <- paste0("Log10(Cyanobacteria + ", const,")")

fig <- ggplot(data = cyano_pred, aes(x = preds, y = log10(B_G_DENS + const))) +
  geom_hex(bins = 60) +
  scale_fill_continuous(type = "viridis") +
  xlim(2.8, max_val) + ylim(2.8, max_val) +
  ylab("Observed") +
  xlab("Fitted") +
  ggtitle(name)
ggsave(paste0("./figures/", "Model Fit_Cyano_No NLA.jpg"), fig, height = 4, width = 5, bg = "transparent", dpi = 400, units = "in")

# Save the model
# saveRDS(c4, "./inst/model_objects/model_cyano_nolakedata.rds")

# Static map
conus <- st_transform(AOI::aoi_get(state = "conus"), 5070)
aug_bins <- c4 |>
  augment() |>
  mutate(bin = case_when(.std.resid < -2 ~ "c1",
                         .std.resid > -2 & .std.resid <= -1 ~ "c2",
                         .std.resid > -1 & .std.resid <= 0 ~ "c3",
                         .std.resid > 0 & .std.resid <= 1 ~ "c4",
                         .std.resid > 1 & .std.resid <= 2 ~ "c5",
                         .std.resid > 2 & .std.resid <= 3 ~ "c6",
                         .std.resid > 3 ~ "c7")) |>
  arrange(abs(.std.resid))
  
ggplot() + 
  geom_sf(data = conus, fill = "#e2e2e2", color = "white", size = 0.5) +
  geom_sf(data = aug_bins, aes(fill = bin), pch = 21) +
  scale_fill_manual(values = c('#7f3b08','#e08214','#fee0b6','#d8daeb','#b2abd2','#8073ac','#2d004b'),
                    name = " ", 
                    breaks = c(paste0("c", 1:7)),
                    labels = (c("< -2", "-2 - -1","-1 - 0","0 - 1","1 - 2","2 - 3", "> 3"))) +
  theme_void() +
  ggtitle("Cyanobacteria: Standardized Residuals") +
  theme(plot.title = element_text(hjust = 0.5, vjust = 1, size = 12))
ggsave("./figures/Cyano_StdResidMap.png", width = 6, height = 3.5, units = "in", dpi = 600)

# Map of fitted probability
# Side-by-side of observed and fitted values
mapper <- aug_bins |>
  rename(Observed = `log10(B_G_DENS + 1000)`,
         Estimated = .fitted) |>
  pivot_longer(cols = c(Observed, Estimated), names_to = "type", values_to = "value")

ggplot() + 
  geom_sf(data = conus, fill = "#e2e2e2", color = "white", size = 0.5) +
  geom_sf(data = arrange(mapper, value), aes(fill = value), pch = 21) +
  facet_wrap(~type) +
  scale_fill_gradientn(colors = RColorBrewer::brewer.pal(9, 'YlOrRd'),
                       name = "Cyanobacteria \n (cells/mL)", 
                       breaks = c(log10(0+1000),log10(10000+1000),log10(10^5+1000), log10(10^6+1000), log10(10^7+1000)),
                       labels = c("0", "10,000", "100,000", "1,000,000", "10,000,000")) +
  theme_void() +
  ggtitle("Cyanobacteria Abundance")+
  theme(plot.title = element_text(hjust = 0.5, vjust = 1, size = 12))
ggsave("./figures/Map_Cyano_EstimatedObserved.png", width = 8, height = 4, units = "in", dpi = 600)

# Map of observed cyanobacteria
ggplot() + 
  geom_sf(data = conus, fill = "#e2e2e2", color = "white", size = 0.5) +
  geom_sf(data = arrange(aug_bins, `log10(B_G_DENS + 1000)`), aes(fill = `log10(B_G_DENS + 1000)`), pch = 21) +
  scale_fill_gradientn(colors = RColorBrewer::brewer.pal(9, 'YlOrRd'),
                       name = "Cyanobacteria \n (cells/mL)", 
                       breaks = c(log10(0+1000),log10(10000+1000),log10(10^5+1000), log10(10^6+1000), log10(10^7+1000)),
                       labels = c("0", "10,000", "100,000", "1,000,000", "10,000,000")) +
  theme_void() +
  ggtitle("Observed Cyanobacteria Abundance")+
  theme(plot.title = element_text(hjust = 0.5, vjust = 1, size = 12))
ggsave("./figures/ObservedMap_Cyano.png", width = 6, height = 3.5, units = "in", dpi = 600)

# NLA lake locations for ASLO presentation
ggplot() + 
  geom_sf(data = conus, fill = "#e2e2e2", color = "white", size = 0.5) +
  geom_sf(data = habs, aes(shape = DSGN_CYCLE), color = "blue", bg = "black", alpha = 0.5) +
  scale_shape(name = "Survey Year") +
  theme_void() 
ggsave("./figures/NLA071217Lakes.png", width = 6, height = 3.5, units = "in", dpi = 600)


```


Models for microcystin detection (presence/absence)


```{r}
# Use binary microcystin variable
dep_var  <- "MICX_DET"

# When running model comparison with an independent error model (no spatial covariance), setting the spcov_type = "none" will only reproduce the results of glm() when the nugget is set to near zero.

spcov_init <- spcov_initial("none", ie = 1e-4, known = "ie")

run_micx <- function(mod_vars, int = NULL){
  spglm(create_formula(dep_var = "MICX_DET", ind_vars = mod_vars, interact = int),
                family = "binomial",
                # Edited to use same set of observations for model comparison
                data = habs_mod, # drop_na(habs, all_of(dep_var), all_of(mod_vars)),
                spcov_type = "exponential",
        estmethod = "reml",
                # spcov_initial = spcov_init,
                random = ~ DSGN_CYCLE + UNIQUE_ID,
                local = T)
}

# Lessons learned
# These models take substantially longer to run than the linear models and the estimated covariates are most unstable when run using approximation methods (local = T).

# The temperature and precip data never seem to be important to this model.

# Soil erodibility (Kf) is inversely associated with microcystin detection?

# These were all run with local = T
micx1 <- run_micx(mod_vars = c("NTL","PTL", "DOC", "PH", "dev_ws", "agr_ws", "KffactWs", "precip_mean_month", "TEMPERATURE", "BFIWs", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch", "AG_ECO3"))

micx2 <- run_micx(mod_vars = c("NTL","PTL", "DOC", "PH", "dev_ws", "agr_ws", "wet_ws", "KffactWs", "precip_mean_month", "temp_mean_month", "BFIWs", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch", "AG_ECO3"), int = "PTL*AG_ECO3")

micx3 <- run_micx(mod_vars = c("NTL","PTL", "DOC", "PH", "dev_ws", "agr_ws", "KffactWs", "precip_mean_month", "temp_mean_month", "BFIWs", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch", "AG_ECO3"), int = "NTL*AG_ECO3")

micx4 <- run_micx(mod_vars = c("NTL", "DOC", "PH", "dev_ws", "agr_ws", "KffactWs", "precip_mean_month", "temp_mean_month", "BFIWs", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch", "AG_ECO3"))

micx5 <- run_micx(mod_vars = c("NTL", "PH", "dev_ws", "agr_ws", "KffactWs", "temp_mean_month", "BFIWs", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch", "AG_ECO3"))

# Set local = F here since it seems like the estimates are changing quite a bit between estimated runs
micx6 <- run_micx(mod_vars = c("NTL", "PH", "dev_ws", "agr_ws", "KffactWs", "temp_mean_month", "BFIWs", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch", "AG_ECO3"))

# Back to local = T
micx7 <- run_micx(mod_vars = c("NTL", "PH", "dev_ws", "agr_ws", "KffactWs", "temp_mean_month", "BFIWs", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch", "RunoffWs", "AG_ECO3"))

# Best fit so far? Hard to know when running models using approximation methods.
micx8 <- run_micx(mod_vars = c("NTL", "PH", "dev_ws", "agr_ws", "KffactWs", "temp_mean_month", "BFIWs", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch", "AG_ECO3"))

# Try with dissolved N species
micx9 <- run_micx(mod_vars = c("NTL","NITRATE_DET","NITRATE_N", "AMMONIA_N", "PH", "dev_ws", "agr_ws", "KffactWs", "temp_mean_month", "BFIWs", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch", "AG_ECO3"))

# Try running with fixed range
micx9a <- run_micx(mod_vars = c("NTL","NITRATE_DET","NITRATE_N", "AMMONIA_N", "PH", "dev_ws", "agr_ws", "KffactWs", "temp_mean_month", "BFIWs", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch", "AG_ECO3"))

# Try with no spatial covariation
micx10 <- run_micx(mod_vars = c("NTL","NITRATE_DET","NITRATE_N", "PH", "dev_ws", "agr_ws", "KffactWs", "temp_mean_month", "BFIWs", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch", "AG_ECO3"))

# Take out developed area and monthly temperature 
micx11 <- run_micx(mod_vars = c("NTL", "PH", "agr_ws", "dev_ws", "KffactWs", "BFIWs", "temp_mean_month", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch", "AG_ECO3"))

# What happens when we replace ag cover with ag N inputs of excess ag inputs?
micx12 <- run_micx(mod_vars = c("NTL", "PH", "p_dev_inputs", "KffactWs", "BFIWs", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch", "AG_ECO3"))

# Best fit model so far with NLA water data
micx11 <- run_micx(mod_vars = c("NTL", "PH", "agr_ws", "dev_ws", "KffactWs", "BFIWs", "temp_mean_month", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch", "AG_ECO3"))

# Save this model
# saveRDS(micx11, "./inst/model_objects/model_micx_withlakedata.rds")

### Microcystin models without NLA lake data ###

# Filter to the same set of observations for model comparison
habs_mod <- habs |>
  select(MICX_DET, Precip8110Ws, Tmean8110Ws, Precip_Minus_EVTWs, precip_mean_month, temp_mean_month, BFIWs, MAXDEPTH, lakemorpho_fetch, p_dev_inputs, n_dev_inputs, N_Total_Deposition, N_Surplus, p_farm_inputs, n_farm_inputs, fst_ws, wet_ws, KffactWs, RunoffWs, AG_ECO3, UNIQUE_ID, DSGN_CYCLE) |>
  drop_na()

# Based on discussions with Mike, we decided that I would do an initial fixed effects model selection using glm() to compare model AUC/BIC. Then I would take the final set of 3-ish models and run with spatial covariance (est_method = "reml") and choose the final model based on AUC and RMSPE. 

# Initial model
m3 <- run_micx(mod_vars = c("p_farm_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = NULL)

# Does N inputs fit better?
m2 <- run_micx(mod_vars = c("n_farm_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = NULL)

# Which climate data?
m4 <- run_micx(mod_vars = c("p_farm_inputs", "fst_ws", "precip_mean_month", "temp_mean_month", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = NULL)

# Runoff or baseflow index?
m5 <- run_micx(mod_vars = c("p_farm_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "RunoffWs", "AG_ECO3"), int = NULL)

# Will another inventory variable fit in the model?
m6 <- run_micx(mod_vars = c("p_farm_inputs", "n_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = NULL)

m7 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = NULL)

m8 <- run_micx(mod_vars = c("p_farm_inputs", "N_Total_Deposition", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = NULL)

# Interactions
m9 <- run_micx(mod_vars = c("p_farm_inputs", "n_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * MAXDEPTH")

m10 <- run_micx(mod_vars = c("p_farm_inputs", "n_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")

# Conclusion: Take m6, m10, and m9 to run as spatial models
glances(m2, m3, m4, m5, m6, m7, m8, m9, m10)
AUROC(m10)
AUROC(m9)
AUROC(m6)


# Run with spatial covariance
m6_sp <- run_micx(mod_vars = c("p_farm_inputs", "n_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = NULL)

m9_sp <- run_micx(mod_vars = c("p_farm_inputs", "n_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * MAXDEPTH")

m10_sp <- run_micx(mod_vars = c("p_farm_inputs", "n_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")

# Which models are included in the table?
m_list <- list(m6_sp, m9_sp, m10_sp)
# m_list <- list(m6, m9, m10)

# Variables common to all models
com_vars <- c("fst_ws", "BFIWs", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3")

# Get the fixed effects that are different between the models
dif_vars <- sapply(m_list, function(mod){
  coef_names <- names(mod$coefficients$fixed)
  coef_names <- coef_names[!coef_names %in% c("(Intercept)", com_vars)]
  paste(coef_names, collapse = ", ")
})

# Augment the data to get fitted values. Note that in the bionomial case, fitted values include fixed and random effects as well as spatial correlation
mods_auc <- sapply(m_list, function(mod){
  aug_mod <- augment(mod)
  pROC::auc(aug_mod$MICX_DET, aug_mod$.fitted)
})

# Run loocv to get the bias and 
micx_loocv <- do.call(rbind, lapply(m_list, loocv))

# Put it all together into a table
cy_res_table <- glances(m6_sp, m9_sp, m10_sp) |>
  mutate(model = factor(model, levels = c("m6_sp", "m9_sp", "m10_sp"))) |>
  arrange(model) |>
  cbind(micx_loocv) |>
  select(model, n, p, npar, bias, MSPE, RMSPE, deviance) |> 
  mutate(AUC = mods_auc) |>
  # mutate(distinct_vars = dif_vars,
  #        common_vars = paste(com_vars, collapse = ", ")) |>
  arrange(AUC) |>
  tibble()

Sys.time()

# Conclusion: m9 model is probably the best fit with an interaction between the p_farm_inputs and the lake depth. It was in the top 4 models based on AUC comparisison with independent models and had the lowest RMSPE when run with spatial correlation. Model m10 had the highest AUC, but also have slightly higher RMSPE. In reality, these models are all pretty close to each other in terms of performance. Mike recommends picking the one with the highest AUC since that is what folks tend to care about the model

# The models do run when replace with the log-transformed N inputs. Guessing that the extreme values make the model difficult to fit.

# Turns out I was working with nutrient inventory numbers that weren't normalized to the watershed area. As a result, there were some extremely high numbers in the data.

# What happens when we replace ag cover with ag N inputs of excess ag inputs?
micx13 <- run_micx(mod_vars = c("NTL", "PH", "n_farm_inputs", "n_dev_inputs", "BFIWs", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch", "AG_ECO3"))

# Just run with the nutrient inventory inputs. Only P farm inputs important. N farm inputs and P developed inputs may be important. When both N and P farm inputs are included, P is more important than N. 
# Adding an interaction between N farm inputs and ecoregion revealed a potential effect of N in the eastern highlands, but nowhere else.
# Adding an interaction between P farm inputs and ecoregion suggests that P farm inputs is only related to MICX detection in the eastern highlands ecoregion.
# Adding two interaction terms helped nothing
# Lake depth does interact with P farm inputs
micx20 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "n_dev_inputs", "p_dev_inputs"))
micx20 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs"))
micx20 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "AG_ECO3"), int = "n_farm_inputs * AG_ECO3")
micx20 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")
micx20 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3 + n_farm_inputs * AG_ECO3")
micx20 <- run_micx(mod_vars = c("p_farm_inputs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")
micx20 <- run_micx(mod_vars = c("p_farm_inputs", "AG_ECO3", "lake_dep"), int = "p_farm_inputs * lake_dep")

# Switching the order of the categorical variables
habs <- mutate(habs, AG_ECO3 = factor(AG_ECO3, levels = c("WMTNS", "PLNLOW", "EHIGH")))
habs <- mutate(habs, lake_dep = factor(lake_dep, levels = c("shallow", "deep")))

# Switched the ordering of the lake depths. Indicated that shallow lakes have a positive relationship with N inputs. Deep lakes may also have a positive relationship, but not substantially different from shallow lakes.
micx21 <- run_micx(mod_vars = c("p_farm_inputs", "AG_ECO3", "lake_dep"), int = "p_farm_inputs * lake_dep")
micx21 <- run_micx(mod_vars = c("p_farm_inputs", "AG_ECO3", "MAXDEPTH"), int = "p_farm_inputs * MAXDEPTH")

# What about other inventory variables? N surplus is positively related. N total inputs was not related. P accumulated agricultural inputs does not fit better/with P farm inputs
# P farm inputs and ecoregion interact in the presence of N surplus
micx22 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus"))
micx22 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus", "P_Accumulated_ag_inputs"))
micx22 <- run_micx(mod_vars = c("N_Surplus", "P_Accumulated_ag_inputs"))
micx22 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus"), int = "p_farm_inputs * AG_ECO3")
micx22 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus"), int = "N_Surplus * AG_ECO3")

# Adding climate info, the monthly means. Temperature important, but not precip
micx21 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "precip_mean_month", "temp_mean_month", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")

# Trying the climate normals. Both temp and precip important
micx22 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "Precip8110Ws", "Tmean8110Ws", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")
micx22 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "Precip8110Ws", "Tmean8110Ws", "AG_ECO3"))

# Add the lake depth. Is the continuous or categorical lake depth a better predictor? Both very important.
micx23 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "Precip8110Ws", "Tmean8110Ws", "AG_ECO3", "MAXDEPTH"), int = "p_farm_inputs * AG_ECO3")

micx24 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "Precip8110Ws", "Tmean8110Ws", "AG_ECO3", "lake_dep"), int = "p_farm_inputs * AG_ECO3")

# Add other variables
# Baseflow index is related
micx25 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "Precip8110Ws", "Tmean8110Ws", "AG_ECO3", "lake_dep", "BFIWs"), int = "p_farm_inputs * AG_ECO3")

# Lake fetch is related
micx26 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "Precip8110Ws", "Tmean8110Ws", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")

# Soil erosion not important. Total or agricultural specific.
micx27 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "Precip8110Ws", "Tmean8110Ws", "lake_dep", "lakemorpho_fetch", "BFIWs", "AgKffactWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")

# Try other land cover types. Developed area important, forested area probably important, but not significantly so.
micx28 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "dev_ws", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")

# N developed inputs are related. P developed input also may be important. Likely variables are highly collinear.
micx29 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "n_dev_inputs", "Precip8110Ws", "Tmean8110Ws", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")
micx30 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "n_dev_inputs", "p_dev_inputs", "Precip8110Ws", "Tmean8110Ws", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")
micx31 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "p_dev_inputs", "Precip8110Ws", "Tmean8110Ws", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")

# Add in forested land cover. Removed temperature. Added precip minus ET (integrated measure of both precipitation and temperature) which seems to be more related.
micx32 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "n_dev_inputs", "fst_ws", "Precip8110Ws", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")
micx33 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "n_dev_inputs", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")
micx34 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "n_dev_inputs", "fst_ws", "Precip_Minus_EVTWs", "RunoffWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")

# Remove N farm inputs
micx34 <- run_micx(mod_vars = c("p_farm_inputs", "n_dev_inputs", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")

micx35 <- run_micx(mod_vars = c("p_farm_inputs", "n_dev_inputs", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * lake_dep + n_dev_inputs * AG_ECO3")

micx35 <- run_micx(mod_vars = c("p_farm_inputs", "n_dev_inputs", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * lake_dep + n_dev_inputs * AG_ECO3")

# Getting close, but need to play around with the final set of interactions
micx36 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")

micx37 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")

# N surplus is related
micx37 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")

# Does N surplus interact? Interaction between N_surplus and lake depth has a negative relationship with shallow lakes and a positive relationship with deep lakes. Does that make sense? This model has slightly lower AIC than a model that does not have an interaction between N_suplus and lake depth.
micx38 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3 + N_Surplus * lake_dep")

# Running with random effect of lake unique ID
micx40 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3 + N_Surplus * lake_dep")

# The interaction exists for the categorical lake depth, but not the continuous variable
micx39 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus", "fst_ws", "Precip_Minus_EVTWs", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3 + N_Surplus * MAXDEPTH")

# Best fit so far?
micx38 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3 + N_Surplus * lake_dep")

# Remove an interaction
micx39 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")
micx40 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "N_Surplus * lake_dep")

# Remove all interactions
micx41 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = NULL)

# Remove the ecoregions
micx42 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs"), int = NULL)

# Try continuous depth, this fits better
micx43 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus", "fst_ws", "Precip_Minus_EVTWs", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = NULL)

# Try climate normals for temp and precip rather than precip-EVT
micx44 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus", "fst_ws", "Tmean8110Ws", "Precip8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = NULL)

# What about other N input types?
micx45 <- run_micx(mod_vars = c("p_farm_inputs", "n_dev_inputs", "fst_ws", "Precip_Minus_EVTWs", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = NULL)
micx46 <- run_micx(mod_vars = c("p_farm_inputs", "N_Total_Deposition", "fst_ws", "Precip_Minus_EVTWs", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = NULL)
micx47 <- run_micx(mod_vars = c("p_farm_inputs", "fst_ws", "Precip_Minus_EVTWs", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = NULL)
micx48 <- run_micx(mod_vars = c("p_farm_inputs", "p_dev_inputs", "fst_ws", "Precip_Minus_EVTWs", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = NULL)

# Add an interaction back in
micx49 <- run_micx(mod_vars = c("p_farm_inputs", "fst_ws", "Precip_Minus_EVTWs", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")

glances(micx38, micx39, micx40, micx41, micx42)

# mixc47 maybe most reasonable fit
summary(micx47)
beepr::beep()

aug_micx <- augment(micx47)
pROC::auc(aug_micx$MICX_DET, aug_micx$.fitted)

micx_loocv <- loocv(micx11, cv_predict = T)

# Save the best performing micx model so far
# saveRDS(micx47, "./inst/model_objects/model_micx_nolakedata.rds")

# Boxplot of estimated probability
vis_fit(dep_var, micx47, file_name = "Model Fit_Micx_Det.jpg")

# Maps for ASLO presentation
ggplot() + 
  geom_sf(data = conus, fill = "#e2e2e2", color = "white", size = 0.5) +
  geom_sf(data = aug_micx, aes(fill = .fitted), pch = 21) +
  scale_fill_gradientn(colors = RColorBrewer::brewer.pal(9, 'YlOrRd'),
                       name = "Estimated \nProbability", 
                       breaks = c(0.25,0.5,0.75,1)) +
  theme_void() +
  ggtitle("Fitted Probability of Microcystin Detection")+
  theme(plot.title = element_text(hjust = 0.5, vjust = 1, size = 12))
ggsave("./figures/FittedProbMap_Micx.png", width = 6, height = 3.5, units = "in", dpi = 600)

ggplot() + 
  geom_sf(data = conus, fill = "#e2e2e2", color = "white", size = 0.5) +
  geom_sf(data = arrange(aug_micx, MICX_DET), aes(fill = MICX_DET), pch = 21) +
  scale_fill_manual(values = c('#ffeda0','#bd0026'), #'#fee0b6','#d8daeb','#b2abd2','#8073ac'
                       name = "Microcystin \nDetected", 
                       breaks = levels(aug_micx$MICX_DET),
                    labels = c("Below Detection", "Detected")) +
  theme_void() +
  ggtitle("Observed Microcystin Detection")+
  theme(plot.title = element_text(hjust = 0.5, vjust = 1, size = 12))
ggsave("./figures/ObservedMap_Micx.png", width = 6, height = 3.5, units = "in", dpi = 600)

```


Models for microcystin concentration, when present


```{r}
dep_var  <- "MICX"

run_micxlm <- function(mod_vars, int = NULL){
  splm(create_formula(dep_var, mod_vars, log = T, interact = int),
                data = drop_na(habs, all_of(dep_var), all_of(mod_vars)),
                spcov_type = "exponential",
                random = ~ DSGN_CYCLE + UNIQUE_ID,
                local = F)
}

# Lessons learned
# Similarly to cyanobacteria cell counts, TP only becomes important when TN is removed as a covariate, signaling that these are colinear. But interesting that turbidity is important with this model in addition to TN. Would have expected these variables to be colinear so as not to overlay with each other.

# E/I has a better relationship to microcystin than d-excess.

# The addition of detected and concentration of nitrate improves the model pseudo R2, but only concentration appears to be important. Also the AIC is lower with inclusion of these variables. The addition of ammonia doesn't improve the model. Similar result with TP. TP was also negatively, which is counterintuitive. When nitrate isn't in the model and TP replaces TN, TP has a positive relationship. 

micxlm1 <- run_micxlm(mod_vars = c("NTL","PTL", "DOC", "PH", "wet_ws", "agr_ws", "precip_mean_month", "TEMPERATURE", "BFIWs", "RunoffWs", "EVAP_INFL", "MAXDEPTH", "lakemorpho_shoreline.length", "AG_ECO3"))

micxlm2 <- run_micxlm(mod_vars = c("NTL","PTL", "DOC", "PH", "wet_ws", "agr_ws", "precip_mean_month", "TEMPERATURE", "BFIWs", "RunoffWs", "EVAP_INFL", "MAXDEPTH", "lakemorpho_shoreline.length", "AG_ECO3"), int = "NTL*AG_ECO3")

micxlm3 <- run_micxlm(mod_vars = c("NTL","PTL", "DOC", "PH", "wet_ws", "agr_ws", "precip_mean_month", "TEMPERATURE", "BFIWs", "RunoffWs", "EVAP_INFL", "MAXDEPTH", "lakemorpho_shoreline.length", "AG_ECO3"), int = "PTL*AG_ECO3")

micxlm4 <- run_micxlm(mod_vars = c("NTL", "DOC", "PH", "wet_ws", "agr_ws", "precip_mean_month", "TEMPERATURE", "BFIWs", "RunoffWs", "EVAP_INFL", "MAXDEPTH", "lakemorpho_shoreline.length", "AG_ECO3"))

micxlm5 <- run_micxlm(mod_vars = c("PTL", "DOC", "PH", "wet_ws", "agr_ws", "precip_mean_month", "TEMPERATURE", "BFIWs", "RunoffWs", "EVAP_INFL", "MAXDEPTH", "lakemorpho_shoreline.length", "AG_ECO3"))

micxlm6 <- run_micxlm(mod_vars = c("NTL", "DOC", "PH", "agr_ws", "precip_mean_month", "TEMPERATURE", "BFIWs", "RunoffWs", "EVAP_INFL", "MAXDEPTH", "lakemorpho_shoreline.length", "AG_ECO3"))

micxlm7 <- run_micxlm(mod_vars = c("NTL", "DOC", "PH", "agr_ws", "precip_mean_month", "TEMPERATURE", "BFIWs", "EVAP_INFL", "MAXDEPTH", "lakemorpho_shoreline.length"))

micxlm8 <- run_micxlm(mod_vars = c("NTL", "DOC", "PH", "agr_ws", "precip_mean_month", "TEMPERATURE", "BFIWs", "EVAP_INFL", "MAXDEPTH"))

micxlm9 <- run_micxlm(mod_vars = c("NTL", "DOC", "PH", "agr_ws", "precip_mean_month", "Tmean8110Ws", "BFIWs", "EVAP_INFL", "MAXDEPTH"))

micxlm10 <- run_micxlm(mod_vars = c("NTL", "DOC", "PH", "agr_ws", "precip_mean_month", "Tmean8110Ws", "BFIWs", "EVAP_INFL", "lakemorpho_fetch"))

micxlm11 <- run_micxlm(mod_vars = c("NTL", "DOC", "PH", "agr_ws", "precip_mean_month", "Tmean8110Ws", "EVAP_INFL"))

# Best fit model with TN onlu
micxlm12 <- run_micxlm(mod_vars = c("NTL", "DOC", "PH", "TURB", "agr_ws", "precip_mean_month", "Tmean8110Ws", "EVAP_INFL"))

# Other experiments
micxlm13 <- run_micxlm(mod_vars = c("NTL", "DOC", "PH", "TURB", "agr_ws", "precip_mean_month", "Tmean8110Ws", "D_EXCESS"))

# Best fit model with TN + nitrate
micxlm14 <- run_micxlm(mod_vars = c("NTL", "NITRATE_DET", "NITRATE_N", "DOC", "PH", "TURB", "agr_ws", "precip_mean_month", "Tmean8110Ws", "EVAP_INFL"))

micxlm15 <- run_micxlm(mod_vars = c("NTL", "NITRATE_DET", "NITRATE_N", "AMMONIA_N", "DOC", "PH", "TURB", "agr_ws", "precip_mean_month", "Tmean8110Ws", "EVAP_INFL"))

micxlm16 <- run_micxlm(mod_vars = c("NTL", "NITRATE_DET", "NITRATE_N", "PTL", "DOC", "PH", "TURB", "agr_ws", "precip_mean_month", "Tmean8110Ws", "EVAP_INFL"))

micxlm17 <- run_micxlm(mod_vars = c("PTL", "NITRATE_DET", "NITRATE_N", "DOC", "PH", "TURB", "agr_ws", "precip_mean_month", "Tmean8110Ws", "EVAP_INFL"))

micxlm18 <- run_micxlm(mod_vars = c("NTL", "NITRATE_DET", "NITRATE_N", "DOC", "PH", "TURB", "agr_ws", "precip_mean_month", "Tmean8110Ws", "D_EXCESS"))

# Run with local = F
# micxlm_local_f <- run_micxlm(mod_vars = c("NTL", "DOC", "PH", "TURB", "agr_ws", "precip_mean_month", "Tmean8110Ws", "EVAP_INFL"))

summary(micxlm14)
varcomp(micxlm18)

# vis_fit(dep_var, micxlm_local_f, file_name = "Model Fit_Micx_Conc.jpg")

mod_vars = c("NTL", "NITRATE_DET", "NITRATE_N", "DOC", "PH", "TURB", "agr_ws", "precip_mean_month", "Tmean8110Ws", "EVAP_INFL")

micx_pred <- filter(drop_na(habs, all_of(dep_var), all_of(mod_vars)))

micx_loocv <- loocv(micxlm14, cv_predict = TRUE)

micx_pred$preds <- micx_loocv$cv_predict

max_val <- max(log10(micx_pred$MICX +1), micx_pred$preds)
min_val <- min(log10(micx_pred$MICX +1), micx_pred$preds)
name <- "Log10(Microcystin)"

fig <- ggplot(data = micx_pred, aes(x = preds, y = log10(MICX))) +
  geom_point(color = "blue", alpha=0.3) +
  xlim(min_val, max_val) + ylim(min_val, max_val) +
  ylab("Observed") +
  xlab("Fitted") +
  ggtitle(name)
ggsave(paste0("./figures/", "Model Fit_Micx Conc.jpg"), height = 4, width = 5, dpi = 400, units = "in")

```



Random forest experimenting

```{r}
# A good tutorial introducing random forest https://uc-r.github.io/random_forests

# Create a binary for microcystin detections
# habs <- mutate(habs, MICX_DET = factor(ifelse(is.finite(MICX), 1, 0)))

# Dependent variable 
dep_var <- "MICX_DET"

# Which set of independent variables will be considered? All available or only those available across CONUS (removing ancillary NLA water phys/chem data)?
ind_vars <- non_nla_vars

# How much missingness is there in the data?
missing_data <- habs |>
  st_drop_geometry() |>
  summarize_all(~sum(is.na(.))) |>
  pivot_longer(SITE_ID:MICX_DET, names_to = "variable", values_to = "num_missing")

# Examine if the error stabilizes with the number of trees
m1 <- randomForest::randomForest(
  formula = create_formula(dep_var, ind_vars),
  data = drop_na(habs, all_of(dep_var), all_of(ind_vars)),
  ntree = 1000
)
plot(m1)

# Tune the mTry parameter
na_free <- drop_na(habs, all_of(dep_var), all_of(ind_vars))

m2 <- randomForest::tuneRF(
  x          = st_drop_geometry(na_free[ind_vars]),
  y          = na_free$B_G_DENS,
  ntreeTry   = 1000,
  mtryStart  = 2,
  stepFactor = 1.5,
  improve    = 0.01,
  trace      = FALSE      # to not show real-time progress 
)

# hyperparameter grid search
hyper_grid <- expand.grid(
  mtry       = seq(10, 30, by = 2),
  node_size  = seq(5, 50, by = 5),
  sampe_size = c(.55, .632, .70, .80),
  OOB_RMSE   = 0
)

for(i in 1:nrow(hyper_grid)) {
  
  # train model
  model <- ranger::ranger(
    formula         = create_formula(dep_var, ind_vars, log = T, const = 1000),
    data            = st_drop_geometry(drop_na(habs, all_of(dep_var), all_of(ind_vars))), 
    num.trees       = 1000,
    mtry            = hyper_grid$mtry[i],
    min.node.size   = hyper_grid$node_size[i],
    sample.fraction = hyper_grid$sampe_size[i],
    seed            = 123
  )
  
  # add OOB error to grid
  hyper_grid$OOB_RMSE[i] <- sqrt(model$prediction.error)
}

# Which set of parameters yields the lowest OOB RMSE?
hyper_grid %>% 
  dplyr::arrange(OOB_RMSE) %>%
  head(10)

# Check expected error for optimal set of hyperparameters
OOB_RMSE <- vector(mode = "numeric", length = 200)

for(i in seq_along(OOB_RMSE)) {

  optimal_ranger <- ranger::ranger(
    formula         = create_formula(dep_var, ind_vars, log = T, const = 1000),
    data            = st_drop_geometry(drop_na(habs, all_of(dep_var), all_of(ind_vars))), 
    num.trees       = 1000,
    mtry            = 28,
    min.node.size   = 50,
    sample.fraction = .8,
    importance      = 'impurity'
  )
  
  OOB_RMSE[i] <- sqrt(optimal_ranger$prediction.error)
}

hist(OOB_RMSE, breaks = 20)

imp <- tibble(var = names(optimal_ranger$variable.importance), var_imp = optimal_ranger$variable.importance)

imp %>% 
  dplyr::arrange(desc(var_imp)) %>%
  ggplot(aes(x = reorder(var, var_imp), y = var_imp)) +
  geom_col() +
  coord_flip() +
  xlab("Variable") + ylab("Variable Importance") +
  ggtitle("Variables available for CONUS (non-NLA)")

# ggsave("./figures/Variable importance_NLA'07,'12,'17_non-NLA vars.png", dpi = 300, width = 5, height = 5)


# Given the parameter tuning, now pass the data to spmodel
modRF <- splmRF(create_formula(dep_var, ind_vars),
                data = drop_na(habs, all_of(dep_var), all_of(ind_vars)),
                spcov_type = "exponential",
                family = "binomial",
                random = ~ DSGN_CYCLE,
                local = TRUE,
                num.trees       = 1000,
                mtry            = 28,
                min.node.size   = 50,
                sample.fraction = .8,
                importance = "impurity")

modRF.imp <- tibble(var = names(modRF$ranger$variable.importance), var_imp = modRF$ranger$variable.importance)

modRF.imp %>% 
  dplyr::arrange(desc(var_imp)) %>%
  dplyr::top_n(25) %>%
  ggplot(aes(x = reorder(var, var_imp), y = var_imp)) +
  geom_col() +
  coord_flip() +
  xlab("Variable") + ylab("Variable Importance")

# ggsave("./figures/Variable importance_spMod_NLA'07,'12,'17_all.png", dpi = 300, width = 5, height = 5)

obs <- habs |>
  drop_na(all_of(dep_var), all_of(ind_vars)) |>
  st_drop_geometry() |>
  mutate(obs = log10(B_G_DENS + 1000)) |>
  pull(obs)

plot(optimal_ranger$predictions, obs)
cor.test(optimal_ranger$predictions, obs)

mod <- modRF$ranger$predictions

plot(obs, mod, ylim = c(3, max(mod, obs)), xlim = c(3, max(mod, obs)))
cor.test(mod, obs)

  
```

Experiment for the lake random effect

```{r}
# Find 50 random observations to hold out
# Make sure that site that have revisit data isn't included. Want the 50 observations to be unobserved locations in the training set.
# Since there is a lot of missing data, should pre-filter the dataset to observations that will be included for both

# Variables used in the most recent models for cyanos and microcystin detection
vars <- unique(c("BFIWs", "Tmean8110Ws", "Precip8110Ws", "n_farm_inputs", "n_dev_inputs", "p_farm_inputs", "lake_dep", "lakemorpho_fetch", "AG_ECO3", "p_farm_inputs", "N_Surplus", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"))

single_obs <- habs |>
  st_drop_geometry() |>
  drop_na(all_of(c("B_G_DENS", "MICX_DET")), all_of(vars)) |>
  group_by(UNIQUE_ID) |>
  summarise(obs_count = n()) |>
  filter(obs_count == 1) |>
  pull(UNIQUE_ID)

# The above df is organized by UNIQUE ID which is categorized by state. Taking an observation at regular intervals should give good spatial coverage of the US
length(single_obs)/50

hold_out <- sapply(1:50, function(x){single_obs[21*x]})

# Divide data into training and test sets
test  <- filter(habs, UNIQUE_ID %in% hold_out)
train <- filter(habs, !(UNIQUE_ID %in% hold_out))

# Run the models with and without a random effect for lake

# Cyanobacteria
mod_vars <- c("BFIWs", "Tmean8110Ws", "Precip8110Ws", "n_farm_inputs", "n_dev_inputs", "p_farm_inputs", "lake_dep", "lakemorpho_fetch", "AG_ECO3")

cyano_lakere <- splm(create_formula("B_G_DENS", mod_vars, log = T, const = 1000, 
                             interact = "n_farm_inputs * AG_ECO3"),
              data = filter(drop_na(train, all_of("B_G_DENS"), all_of(mod_vars))),
              spcov_type = "exponential",
              random = ~ DSGN_CYCLE + UNIQUE_ID,
              local = T)

cyano_re_nonsp <- splm(create_formula("B_G_DENS", mod_vars, log = T, const = 1000, 
                             interact = "n_farm_inputs * AG_ECO3"),
              data = filter(drop_na(train, all_of("B_G_DENS"), all_of(mod_vars))),
              spcov_type = "none",
              random = ~ DSGN_CYCLE + UNIQUE_ID,
              local = T)

cyano_nolakere <- splm(create_formula("B_G_DENS", mod_vars, log = T, const = 1000, 
                             interact = "n_farm_inputs * AG_ECO3"),
              data = filter(drop_na(train, all_of("B_G_DENS"), all_of(mod_vars))),
              spcov_type = "exponential",
              random = ~ DSGN_CYCLE,
              local = T)

cyano_nore <- splm(create_formula("B_G_DENS", mod_vars, log = T, const = 1000, 
                             interact = "n_farm_inputs * AG_ECO3"),
              data = filter(drop_na(train, all_of("B_G_DENS"), all_of(mod_vars))),
              spcov_type = "exponential",
              # random = ~ DSGN_CYCLE,
              local = T)

cyano_nonsp <- splm(create_formula("B_G_DENS", mod_vars, log = T, const = 1000, 
                             interact = "n_farm_inputs * AG_ECO3"),
              data = filter(drop_na(train, all_of("B_G_DENS"), all_of(mod_vars))),
              spcov_type = "none",
              # random = ~ DSGN_CYCLE,
              local = T)

# Compare model fit
glances(cyano_lakere, cyano_nolakere)
lakere_loocv   <- loocv(cyano_lakere)
nolakere_loocv <- loocv(cyano_nolakere)

# Predict for the training set
test$cyano_relake_preds   <- predict(cyano_lakere, newdata = test)
test$cyano_re_nonsp_preds <- predict(cyano_re_nonsp, newdata = test)
test$cyano_norelake_preds <- predict(cyano_nolakere, newdata = test)
test$cyano_nore_preds     <- predict(cyano_nore, newdata = test)
test$cyano_nonsp_preds    <- predict(cyano_nonsp, newdata = test)

# Correlations
cor(test$cyano_relake_preds, log10(test$B_G_DENS + 1000))
cor(test$cyano_re_nonsp_preds, log10(test$B_G_DENS + 1000))
cor(test$cyano_norelake_preds, log10(test$B_G_DENS + 1000))
cor(test$cyano_nore_preds, log10(test$B_G_DENS + 1000))
cor(test$cyano_nonsp_preds, log10(test$B_G_DENS + 1000))


# Plot it out
ggplot(data = test) +
  geom_point(aes(x = cyano_relake_preds, y = log10(B_G_DENS + 1000)), color = "blue") +
  geom_point(aes(x = cyano_norelake_preds, y = log10(B_G_DENS + 1000)), color = "red")


# Detection of microcystin
mod_vars <- c("p_farm_inputs", "N_Surplus", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3")
int <- "p_farm_inputs * AG_ECO3 + N_Surplus * lake_dep"

micx_lakere <- spglm(create_formula(dep_var = "MICX_DET", ind_vars = mod_vars, interact = int),
                     family = "binomial",
                     data = drop_na(train, all_of(dep_var), all_of(mod_vars)),
                     spcov_type = "exponential",
                     random = ~ DSGN_CYCLE + UNIQUE_ID,
                     local = T)

micx_nonsp <- spglm(create_formula(dep_var = "MICX_DET", ind_vars = mod_vars, interact = int),
                     family = "binomial",
                     data = drop_na(train, all_of(dep_var), all_of(mod_vars)),
                     spcov_type = "none",
                     random = ~ DSGN_CYCLE + UNIQUE_ID,
                     local = T)

micx_nolakere <- spglm(create_formula(dep_var = "MICX_DET", ind_vars = mod_vars, interact = int),
                     family = "binomial",
                     data = drop_na(train, all_of(dep_var), all_of(mod_vars)),
                     spcov_type = "exponential",
                     random = ~ DSGN_CYCLE,
                     local = T)

micx_nore <- spglm(create_formula(dep_var = "MICX_DET", ind_vars = mod_vars, interact = int),
                     family = "binomial",
                     data = drop_na(train, all_of(dep_var), all_of(mod_vars)),
                     spcov_type = "exponential",
                     # random = ~ DSGN_CYCLE,
                     local = T)

micx_nore_nonsp <- spglm(create_formula(dep_var = "MICX_DET", ind_vars = mod_vars, interact = int),
                     family = "binomial",
                     data = drop_na(train, all_of(dep_var), all_of(mod_vars)),
                     spcov_type = "none",
                     # random = ~ DSGN_CYCLE,
                     local = T)

aug_lakere     <- augment(micx_lakere, newdata = test)
aug_nonsp      <- augment(micx_nonsp, newdata = test)
aug_nolakere   <- augment(micx_nolakere, newdata = test)
aug_nore       <- augment(micx_nore, newdata = test)
aug_nore_nonsp <- augment(micx_nore_nonsp, newdata = test)

pROC::auc(aug_lakere$MICX_DET, aug_lakere$.fitted)
pROC::auc(aug_nonsp$MICX_DET, aug_nonsp$.fitted)
pROC::auc(aug_nolakere$MICX_DET, aug_nolakere$.fitted)
pROC::auc(aug_nore$MICX_DET, aug_nore$.fitted)
pROC::auc(aug_nore_nonsp$MICX_DET, aug_nore_nonsp$.fitted)


pROC::auc(with(aug_nonsp, MICX_DET, .fitted))
pROC::auc(with(aug_nolakere, MICX_DET, .fitted))
pROC::auc(with(aug_nore, MICX_DET, .fitted))
pROC::auc(with(aug_nore_nonsp, MICX_DET, .fitted))


test$lakere <- predict(micx_lakere, newdata = test)
test$nonsp <- predict(micx_nonsp, newdata = test)
test$nolakere <- predict(micx_nolakere, newdata = test)
test$nolakere <- predict(micx_nolakere, newdata = test)


```



Try random forest with large collection of data from Robert Sabo


```{r}
# All data from Robert (untransformed)
nni <- readr::read_csv("NLA07-12_NutrientInventory_Data.csv")

# Have to break out the month and day of the compiled HABs data
comp <- habs |>
  mutate(Month = as.numeric(format(as.Date(DATE_COL, format = "%m/%d/%Y"), "%m")),
         Day = as.numeric(format(as.Date(DATE_COL, format = "%m/%d/%Y"), "%d")),
         Year = as.numeric(as.character(DSGN_CYCLE))) |>
  # select(SITE_ID, Year, Month, Day, B_G_DENS, TEMPERATURE, DOC, TURB, PH, EVAP_INFL, lakemorpho_depth, ElevWs, SlopeWs) 
  # Remove redundant variables
  select(-NTL, -PTL, -RunoffWs, -LAT_DD83, -LON_DD83, -DATE_COL, -DSGN_CYCLE, -VISIT_NO, -COMID, -MICX, -CHLA_RESULT, -CYLSPER, -UNIQUE_ID)

# Merge with cyanobacteria counts
comp <- left_join(nni, comp, by = c("SITE_ID", "Year", "Month", "Day"))

# Create a vector of the independent variables
nni_vars <- colnames(comp)[c(9:91,93:(length(colnames(comp))-1))] #

# Examine if the error stabilizes with the number of trees
m1 <- randomForest::randomForest(
  formula = create_formula(dep_var, nni_vars, log = T),
  data = drop_na(comp, all_of(dep_var), all_of(nni_vars))
)
plot(m1)

# Tune the mTry parameter
na_free <- drop_na(comp, all_of(dep_var), all_of(nni_vars))

m2 <- randomForest::tuneRF(
  x          = st_drop_geometry(na_free[nni_vars]),
  y          = log10(na_free$B_G_DENS + 1),
  ntreeTry   = 500,
  mtryStart  = 4,
  stepFactor = 1.5,
  improve    = 0.01,
  trace      = FALSE      # to not show real-time progress 
)

# hyperparameter grid search
hyper_grid <- expand.grid(
  mtry       = seq(25, 35, by = 2),
  node_size  = seq(3, 9, by = 2),
  sampe_size = c(.55, .632, .70, .80),
  OOB_RMSE   = 0
)

for(i in 1:nrow(hyper_grid)) {
  
  # train model
  model <- ranger::ranger(
    formula         = create_formula(dep_var, nni_vars, log = T),
    data            = st_drop_geometry(drop_na(comp, all_of(dep_var), all_of(nni_vars))), 
    num.trees       = 500,
    mtry            = hyper_grid$mtry[i],
    min.node.size   = hyper_grid$node_size[i],
    sample.fraction = hyper_grid$sampe_size[i],
    seed            = 123,
    num.threads     = 8
  )
  
  # add OOB error to grid
  hyper_grid$OOB_RMSE[i] <- sqrt(model$prediction.error)
}

# Which set of parameters yields the lowest OOB RMSE?
hyper_grid %>% 
  dplyr::arrange(OOB_RMSE) %>%
  head(15)

# Check expected error for optimal set of hyperparameters
OOB_RMSE <- vector(mode = "numeric", length = 100)

for(i in seq_along(OOB_RMSE)) {

  optimal_ranger <- ranger::ranger(
    formula         = create_formula(dep_var, nni_vars, log = T),
    data            = st_drop_geometry(drop_na(comp, all_of(dep_var), all_of(nni_vars))), 
    num.trees       = 500,
    mtry            = 29,
    min.node.size   = 3,
    sample.fraction = .8,
    num.threads     = 8, 
    importance      = 'impurity'
  )
  
  OOB_RMSE[i] <- sqrt(optimal_ranger$prediction.error)
}

hist(OOB_RMSE, breaks = 20)

optimal_ranger <- ranger::ranger(
  formula         = create_formula(dep_var, nni_vars, log = T),
  data            = drop_na(comp, all_of(dep_var), all_of(nni_vars)), 
  num.trees       = 500,
  mtry            = 29,
  min.node.size   = 3,
  sample.fraction = .8,
  num.threads     = 8, 
  importance      = 'impurity')

imp <- tibble(var = names(optimal_ranger$variable.importance), var_imp = optimal_ranger$variable.importance)

imp %>% 
  dplyr::arrange(desc(var_imp)) %>%
  dplyr::top_n(25) %>%
  ggplot(aes(x = reorder(var, var_imp), y = var_imp)) +
  geom_col() +
  coord_flip() +
  xlab("Variable") + ylab("Variable Importance") +
  ggtitle("NLA '07,'12_All Variables")

ggsave("./figures/Variable importance_NLA'07,'12_all.png", dpi = 300, width = 5, height = 5)

########################################################

# Have to break out the month and day of the compiled HABs data
comp <- habs |>
  mutate(Month = as.numeric(format(as.Date(DATE_COL, format = "%m/%d/%Y"), "%m")),
         Day = as.numeric(format(as.Date(DATE_COL, format = "%m/%d/%Y"), "%d")),
         Year = as.numeric(as.character(DSGN_CYCLE))) |>
  select(-NTL, -PTL, -RunoffWs) |>
  right_join(nni, by = c("SITE_ID", "Year", "Month", "Day")) # |>
  # filter(!duplicated(UNIQUE_ID)) # If running with unique observations

# Investigate how the year random effect interacts with some data that is specific to the sample year
nni_sub <- c(all_vars, "LSTAnomaly_YrMean", "NPP_YrMean", "Precip_YrMean", "Tmean_YrMean")

nni_no_re_no_sp <- splm(create_formula(dep_var, nni_sub, log = T),
                     data = drop_na(comp, all_of(dep_var), all_of(nni_sub)),
                     spcov_type = "none", 
                     local = TRUE)

nni_no_re <- splm(create_formula(dep_var, nni_sub, log = T),
                     data = drop_na(comp, all_of(dep_var), all_of(nni_sub)),
                     spcov_type = "exponential", 
                     local = TRUE)

nni_re_site <- splm(create_formula(dep_var, nni_sub, log = T),
                         data = drop_na(comp, all_of(dep_var), all_of(nni_sub)),
                         spcov_type = "exponential",
                         random = ~  UNIQUE_ID,
                         local = TRUE)

nni_re_year <- splm(create_formula(dep_var, nni_sub, log = T),
                         data = drop_na(comp, all_of(dep_var), all_of(nni_sub)),
                         spcov_type = "exponential",
                         random = ~  DSGN_CYCLE,
                         local = TRUE)

nni_unnest_re <- splm(create_formula(dep_var, nni_sub, log = T),
                       data = drop_na(comp, all_of(dep_var), all_of(nni_sub)),
                       spcov_type = "exponential",
                       random = ~ DSGN_CYCLE + UNIQUE_ID,
                       local = TRUE)

nni_nest_re <- splm(create_formula(dep_var, nni_sub, log = T),
                       data = drop_na(comp, all_of(dep_var), all_of(nni_sub)),
                       spcov_type = "exponential",
                       random = ~ (DSGN_CYCLE / UNIQUE_ID),
                       local = TRUE)

# Compare model with no spatial component, with spatial component, random effect for site alone, random effect for year along, random effect for site and year unnested, random effect for site nested within year.
# How does the AIC and R2 change with these model configurations
glances(nni_no_re_no_sp,
        nni_no_re,
        nni_re_site,
        nni_re_year,
        nni_unnest_re,
        nni_nest_re)
# Nested random effects had the lowest AIC and R2 followed by unnested random effects
# About the same amount of variation is explained with no random effects

optimal_ranger <- ranger::ranger(
  formula         = create_formula(dep_var, nni_sub, log = T),
  data            = drop_na(comp, all_of(dep_var), all_of(nni_sub)), 
  num.trees       = 500,
  mtry            = 8,
  min.node.size   = 3,
  sample.fraction = .8,
  num.threads     = 8, 
  importance      = 'impurity')

imp <- tibble(var = names(optimal_ranger$variable.importance), var_imp = optimal_ranger$variable.importance)

imp %>% 
  dplyr::arrange(desc(var_imp)) %>%
  dplyr::top_n(25) %>%
  ggplot(aes(x = reorder(var, var_imp), y = var_imp)) +
  geom_col() +
  coord_flip() +
  xlab("Variable") + ylab("Variable Importance") +
  ggtitle("NLA '07,'12_All Variables")

ggsave("./figures/Variable importance_NLA'07,'12_with annual.png", dpi = 300, width = 5, height = 5)


```



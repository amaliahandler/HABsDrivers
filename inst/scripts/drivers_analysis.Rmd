---
title: "Analysis of Cyanobacteria and Microcystin Drivers in Lakes"
author: "Handler"
date: '2022-11-21'
output: html_document
editor_options: 
  chunk_output_type: console
---

Based on data compiled in inst/scripts/drivers_compilation.Rmd

```{r setup, include=FALSE}
library(usethis)
library(devtools)
library(spmodel)
library(sf)
library(mapview)
library(dplyr)
library(tidyr)
library(ggplot2)
library(corrplot)

# Load all data and functions from HABsDrivers package
load_all()

# Detailed guide to spmodel
# https://usepa.github.io/spmodel/articles/guide.html

set.seed(99)
```

### Data Prep

```{r data prep}
# Set the western mountains to the base group
habs <- mutate(habs, AG_ECO3 = factor(AG_ECO3, levels = c("WMTNS", "PLNLOW", "EHIGH")))

# Load CONUS polygon for making maps
conus <- st_transform(AOI::aoi_get(state = "conus"), 5072)
```

### Find Cyanobacteria Constant

Find the constant to add to the cyanobacteria cell count. This variable has very high numbers in addition to real zero values. Determine a constant value that will ensure that zero is "close" to small numbers.

```{r find constant}

# Find a constant to add to the cyano for the log transformation

# function to find c
find_c <- function(par, formula, data) {
  const <- exp(par)
  mf <- model.frame(formula, data)
  data$.y <- log(model.response(mf) + const)
  new_formula <- update(formula, .y ~ .)
  lmod <- lm(new_formula, data)
  resids <- residuals(lmod)
  sigma <- summary(lmod)$sigma
  n <- NROW(data)
  ratio <- resids/sigma
  g1 <- sum(ratio^3) / n
  g2p <- sum(ratio^4) / n - 3
  g2 <- g2p + 6 / (lmod$df.residual + 2)
  g0 <- abs(g1) + abs(g2)
  g0
}

# example data
dat <- data.frame(x = rnorm(10), y = rnorm(10, mean = 10))

# HABs data
dat <- st_drop_geometry(drop_na(select(habs, B_G_DENS, NTL, NITRATE_N, AMMONIA_N, DOC, PH, TURB, Precip8110Ws, Tmean8110Ws, EVAP_INFL, MAXDEPTH, lakemorpho_fetch, AG_ECO3)))

# Finds the c for log(y + c) (note that y should be on the original scale for the purposes of this function. The find_c function take the log of the response variable)
# Note that changing the covariates impacts the constant. By trying different sets and numbers of covariates, the constant bounces around a bit, but is usually in the 100's to the 1000's. 
out <- optim(0, 
             fn = find_c, 
             formula = B_G_DENS ~ NTL + AMMONIA_N + DOC + PH + TURB + Precip8110Ws + Tmean8110Ws + EVAP_INFL + MAXDEPTH + lakemorpho_fetch + AG_ECO3, 
             data = dat, 
             method = "Brent", 
             lower = -10, upper = 10)
c_value <- exp(out$par)
print(c_value)

```

### Cyanobacteria, With In-Lake Conditions

```{r cyano with lake data}

# Construct the model
dep_var  <- "B_G_DENS"
const    <- 1000

# Filter to the same set of observations for model comparison purposes. These are all the variables that will be tested for the model.
habs_mod <- habs |>
  select(B_G_DENS, NTL, PTL, NITRATE_N, AMMONIA_N, DOC, PH, TURB, Precip8110Ws, Tmean8110Ws, precip_mean_month, temp_mean_month, EVAP_INFL, MAXDEPTH, lakemorpho_fetch, AG_ECO3, UNIQUE_ID, DSGN_CYCLE) |>
  drop_na()

# Function to run the cyano models for model comparison.
run_cyano_ml <- function(mod_vars, interact){
  splm(create_formula(dep_var, mod_vars, log = T, const = const, interact),
              data = habs_mod,
              spcov_type = "exponential",
              random = ~ DSGN_CYCLE + UNIQUE_ID,
              estmethod = "ml",
              local = T)
}

# Model comparison

# Does TN or TP fit better?
cy1 <- run_cyano_ml(mod_vars = c("NTL", "NITRATE_N", "AMMONIA_N", "DOC", "PH", "TURB", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch"), interact = NULL)

cy2 <- run_cyano_ml(mod_vars = c("PTL", "NITRATE_N", "AMMONIA_N", "DOC", "PH", "TURB", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch"), interact = NULL)

# Monthly mean temperature and precipitation or climate normals?
cy3 <- run_cyano_ml(mod_vars = c("NTL", "NITRATE_N", "AMMONIA_N", "DOC", "PH", "TURB", "precip_mean_month", "temp_mean_month", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch"), interact = NULL)

# Are there ecoregional differences?
cy4 <- run_cyano_ml(mod_vars = c("NTL", "NITRATE_N", "AMMONIA_N", "DOC", "PH", "TURB", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3"), interact = NULL)

# Do interactions improve the model?
cy5 <- run_cyano_ml(mod_vars = c("NTL", "NITRATE_N", "AMMONIA_N", "DOC", "PH", "TURB", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch"), interact = "MAXDEPTH * NTL")

cy6 <- run_cyano_ml(mod_vars = c("NTL", "NITRATE_N", "AMMONIA_N", "DOC", "PH", "TURB", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3"), interact = "AG_ECO3 * NTL")

# Make a table of the model comparison

# Variables common to all models
com_vars <- c("NITRATE_N", "AMMONIA_N", "DOC", "PH", "TURB", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch")

# Which models are included in the table?
cy_list <- list(cy1, cy2, cy3, cy4, cy5, cy6)

# Get the fixed effects that are different between the models
dif_vars <- sapply(cy_list, function(mod){
  coef_names <- names(mod$coefficients$fixed)
  coef_names <- coef_names[!coef_names %in% c("(Intercept)", com_vars)]
  paste(coef_names, collapse = ", ")
})

# Get the loocv to get the R^2 between observed and fit
cymods_ml_loocv <- do.call(rbind, lapply(cy_list, loocv))

# Put it all together into a table
cy_res_table <- glances(cy1, cy2, cy3, cy4, cy5, cy6) |>
  arrange(model) |>
  select(model, n, p, npar, AIC, AICc, BIC) |>
  cbind(cymods_ml_loocv) |>
  mutate(distinct_vars = dif_vars,
         common_vars = paste(com_vars, collapse = ", ")) |>
  arrange(BIC) |>
  tibble()

# Save the model comparison table for inclusion in supplement
saveRDS(cy_res_table, "./inst/model_objects/cyano_mod_compare_withlakedata.rds")

# Run best fit model (c6) with all available oberservations with local = F
mod_vars <- c("NTL", "NITRATE_N", "AMMONIA_N", "DOC", "PH", "TURB", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3") 
interact <- "AG_ECO3 * NTL"
dat_final <- habs |>
  select(all_of(mod_vars), B_G_DENS, DSGN_CYCLE, UNIQUE_ID) |>
  drop_na()

cyano_withlake_sp <- splm(create_formula(dep_var, mod_vars, log = T, const = const, interact),
                          data = dat_final,
                          spcov_type = "exponential",
                          random = ~ DSGN_CYCLE + UNIQUE_ID,
                          estmethod = "ml",
                          local = F)

# Run the best fit model without spatial correlation for comparison
cmod_final_withlake_nsp <- splm(create_formula(dep_var, mod_vars, log = T, const = const, interact),
                              data = dat_final,
                              spcov_type = "none",
                              local = F)
  
# Evaluate fit of non-spatial model
cyano_withlake_nsp_loocv <- loocv(cmod_final_withlake_nsp)

# Visualize the fit of the final spatial model
cyano_withlake_sp_loocv <- loocv(cyano_withlake_sp, cv_predict = TRUE)
dat_final$preds         <- cyano_withlake_sp_loocv$cv_predict

max_val <- max(log10(dat_final$B_G_DENS + const), dat_final$preds)

fig <- ggplot(data = dat_final, aes(x = preds, y = log10(B_G_DENS + const))) +
  geom_hex(bins = 60) +
  scale_fill_continuous(type = "viridis") +
  xlim(2.8, max_val) + ylim(2.8, max_val) +
  ylab("Observed") +
  xlab("Fitted") +
  ggtitle(paste0("Log10(Cyanobacteria + ", const,")"))
ggsave(paste0("./inst/figures/cyano_withlake_sp_final_fitted_preds.png"), fig, height = 4, width = 5, bg = "transparent", dpi = 400, units = "in")

# Several very high predictions appear to be due to extremely high TN concentrations. These are outliers, but there's no reason to believe the predictor data are problematic.

# Save the model
# saveRDS(cyano_withlake_sp, "./inst/model_objects/model_cyano_withlakedata.rds")

# Map of fitted values
ggplot() + 
  geom_sf(data = conus, fill = "#e2e2e2", color = "white", lwd = 1) +
  geom_sf(data = arrange(habs_mod, preds), 
          aes(fill = preds), pch = 21, size = 2) +
  scale_fill_gradientn(colors = RColorBrewer::brewer.pal(9, 'YlOrRd'),
                       name = "Log10(Cyanobacteria + 1000)") +
  theme_void()
ggsave("./inst/figures/cyano_withlake_sp_final_fitted_preds_map.png", width = 7, height = 3.5, units = "in", dpi = 600)

# Save the model
# saveRDS(cymod_final_withlake, "./inst/model_objects/model_cyano_withlakedata.rds")
```


### Cyanobacteria, Without In-Lake Conditions

```{r cyano without lake data}
# Construct the model
dep_var  <- "B_G_DENS"
const    <- 1000

# Filter to the same set of observations for model comparison
habs_mod <- habs |>
  select(B_G_DENS, Precip8110Ws, Tmean8110Ws, precip_mean_month, temp_mean_month, BFIWs, MAXDEPTH, lakemorpho_fetch, p_dev_inputs, p_farm_inputs, n_farm_inputs, fst_ws, AG_ECO3, UNIQUE_ID, DSGN_CYCLE) |>
  drop_na()

# Function to run the cyano models for model comparison. Figured out that these models should be run with local = F for more stable AIC/BIC comparison. These don't take much longer to run than local = T models.
run_cyano_ml <- function(mod_vars, interact){
  splm(create_formula(dep_var, mod_vars, log = T, const = const, interact),
              data = habs_mod,
              spcov_type = "exponential",
              random = ~ DSGN_CYCLE + UNIQUE_ID,
              estmethod = "ml",
              local = T)
}

# Base model
c1 <- run_cyano_ml(mod_vars = c("n_farm_inputs", "p_dev_inputs", "Precip8110Ws", "Tmean8110Ws", "BFIWs", "MAXDEPTH", "lakemorpho_fetch"), interact = NULL)

# Additional land cover
c2 <- run_cyano_ml(mod_vars = c("n_farm_inputs", "p_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "BFIWs", "MAXDEPTH", "lakemorpho_fetch"), interact = NULL)

# Climate normals versus monthly precip and temp
c3 <- run_cyano_ml(mod_vars = c("n_farm_inputs", "p_dev_inputs", "fst_ws", "precip_mean_month", "temp_mean_month", "BFIWs", "MAXDEPTH", "lakemorpho_fetch"), interact = NULL)

# Ecoregions
c4 <- run_cyano_ml(mod_vars = c("n_farm_inputs", "p_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "BFIWs", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3"), interact = NULL)

# Interactions
c5 <- run_cyano_ml(mod_vars = c("n_farm_inputs", "p_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "BFIWs", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3"), interact = "MAXDEPTH * n_farm_inputs")

c6 <- run_cyano_ml(mod_vars = c("n_farm_inputs", "p_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "BFIWs", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3"), interact = "AG_ECO3 * n_farm_inputs")

# Variables common to all models
com_vars <- c("n_farm_inputs", "p_dev_inputs", "BFIWs", "MAXDEPTH", "lakemorpho_fetch")

# Which models are included in the table?
cy_list <- list(c1, c2, c3, c4, c5, c6)

# Get the fixed effects that are different between the models
dif_vars <- sapply(cy_list, function(mod){
  coef_names <- names(mod$coefficients$fixed)
  coef_names <- coef_names[!coef_names %in% c("(Intercept)", com_vars)]
  paste(coef_names, collapse = ", ")
})

# Get the loocv to get the R^2 between observed and fit
cmods_ml_loocv <- do.call(rbind, lapply(cy_list, loocv))

# Put it all together into a table
cmods_ml_nolake <- glances(c1, c2, c3, c4, c5, c6) |>
  arrange(model) |>
  select(model, n, p, npar, AIC, AICc, BIC) |>
  cbind(cmods_ml_loocv) |>
  mutate(distinct_vars = dif_vars,
         common_vars = paste(com_vars, collapse = ", ")) |>
  arrange(BIC) |>
  tibble()

# Save the model comparison table for inclusion in supplement
saveRDS(cmods_ml_nolake, "./inst/model_objects/cyano_mod_compare_nolakedata.rds")

# Run best fit model (c1) with all available observations with local = F
mod_vars <- c("n_farm_inputs", "p_dev_inputs", "Precip8110Ws", "Tmean8110Ws", "BFIWs", "MAXDEPTH", "lakemorpho_fetch") 
interact <- NULL
dat_final <- habs |>
  select(all_of(mod_vars), B_G_DENS, DSGN_CYCLE, UNIQUE_ID) |>
  drop_na()

cyano_nolake_sp <- splm(create_formula(dep_var, mod_vars, log = T, const = const, interact),
                          data = dat_final,
                          spcov_type = "exponential",
                          random = ~ DSGN_CYCLE + UNIQUE_ID,
                          estmethod = "ml",
                          local = F)

# Save the model
saveRDS(cyano_nolake_sp, "./inst/model_objects/model_cyano_nolakedata.rds")
  
# Run the best fit model, c1, without spatial correlation for comparison
cmod_final_nolake_nsp <- splm(create_formula(dep_var, mod_vars, log = T, const = const, interact),
                              data = dat_final,
                              spcov_type = "none",
                              local = F)
  
# Evaluate fit of non-spatial model
cyano_nolake_nsp_loocv <- loocv(cmod_final_nolake_nsp)

# Visual the fit of the final spatial model
cyano_nolake_sp_loocv <- loocv(cyano_nolake_sp, cv_predict = TRUE)
dat_final$preds        <- cyano_nolake_sp_loocv$cv_predict

max_val <- max(log10(dat_final$B_G_DENS + const), dat_final$preds)
min_val <- min(log10(dat_final$B_G_DENS + const), dat_final$preds)

fig <- ggplot(data = dat_final, aes(x = preds, y = log10(B_G_DENS + const))) +
  geom_hex(bins = 60) +
  scale_fill_continuous(type = "viridis") +
  xlim(min_val, max_val) + ylim(min_val, max_val) +
  ylab("Observed") +
  xlab("Fitted") +
  ggtitle(paste0("Log10(Cyanobacteria + ", const,")"))
ggsave(paste0("./inst/figures/cyano_sp_final_fitted_preds.png"), fig, height = 4, width = 5, bg = "transparent", dpi = 400, units = "in")

# Map of fitted values
conus <- st_transform(AOI::aoi_get(state = "conus"), 5072)
ggplot() + 
  geom_sf(data = conus, fill = "#e2e2e2", color = "white", lwd = 1) +
  geom_sf(data = arrange(habs_mod, preds), 
          aes(fill = preds), pch = 21, size = 2) +
  scale_fill_gradientn(colors = RColorBrewer::brewer.pal(9, 'YlOrRd'),
                       name = "Log10(Cyanobacteria + 1000)") +
  theme_void()
ggsave("./inst/figures/cyano_sp_final_fitted_preds_map.png", width = 7, height = 3.5, units = "in", dpi = 600)

# Map of standardized residuals
cyano_aug <- augment(c4)
breaks <- c(-2, 0, 2, 3, 4)
cols <- rev(RColorBrewer::brewer.pal(6, "Spectral"))
ggplot() + 
  geom_sf(data = conus, fill = "#e2e2e2", color = "white", lwd = 1) +
  geom_sf(data = arrange(cyano_aug, .std.resid), 
          aes(fill = .std.resid), pch = 21, size = 1.5) +
  scale_fill_stepsn(colors = cols,
                    breaks = breaks,
                    name = "Standardized \nResiduals") +
  theme_void()
ggsave("./inst/figures/cyano_nolake_stdresiduals_map.png", width = 7, height = 3.5, units = "in", dpi = 600)

# Biplot of fitted versus observed data colored by the standardized residuals 
cyano_aug$preds <- cyano_nolake_sp_loocv$cv_predict
ggplot(data = cyano_aug, aes(x = preds, y = `log10(B_G_DENS + 1000)`, fill = .std.resid)) +
  geom_point(pch = 21) +
  # scale_fill_continuous(type = "viridis",
  #                       name = "Standardized \nResidual") +
  scale_fill_stepsn(colors = cols,
                    breaks = breaks,
                    name = "Standardized \nResiduals") +
  xlim(min_val, max_val) + ylim(min_val, max_val) +
  ylab("Observed") +
  xlab("Fitted") +
  ggtitle(paste0("Log10(Cyanobacteria + ", const,")"))
ggsave(paste0("./inst/figures/cyano_nolake_stdresiduals_biplot.png"), height = 4, width = 5, bg = "transparent", dpi = 400, units = "in")

# The spatial covariance contribution to fitted values, mapped
cyano_aug <- augment(cyano_nolake_sp)
cyano_aug$.spde <- fitted(cyano_nolake_sp, type = "spcov")$de

ggplot() + 
  geom_sf(data = conus, fill = "#e2e2e2", color = "white", lwd = 1) +
  geom_sf(data = arrange(cyano_aug, .spde), 
          aes(fill = .spde), pch = 21, size = 3) +
  colorspace::scale_fill_continuous_divergingx(palette = 'RdBu', mid = 0, rev = TRUE) +
  theme_void()
ggsave("./inst/figures/cyano_nolake_spde_map.png", width = 7, height = 3.5, units = "in", dpi = 600)


```

### Cyanobacteria model comparison

Comparison of spatial and non-spatial models for cyanobacteria, with and without lake data

```{r cyano spatial and independent error model comparison}

# With lake data
cyano_withlake_sp_loocv$stats
cyano_withlake_nsp_loocv

# No lake data
cyano_nolake_sp_loocv$stats
cyano_nolake_nsp_loocv

# Comparison table
cyano_spatial_comp <-
  rbind(cyano_withlake_sp_loocv$stats,
        cyano_withlake_nsp_loocv,
        cyano_nolake_sp_loocv$stats,
        cyano_nolake_nsp_loocv) |>
  mutate(resp_var = "cyano",
         lake_data = c(rep("present", 2), rep("absent", 2)),
         spatial_mod = c(rep(c("spatial", "non-spatial"), 2)), .before = bias)

# Save the table
saveRDS(cyano_spatial_comp, "./inst/model_objects/spatial_compare_cyano.rds")

```


## Microcystin Detection Models

### Microcystin, With In-Lake Conditions

```{r micx with lake data}

# Set the dependent variable
dep <- "MICX_DET"

# First conduct model comparison with independent error models. We do this because fitting spatial models is computationally expensive to do so in a way that models can be compared.

# Comparing AIC/BIC between models requires the same set of observations be used for all models. Trim the dataset to include just the variables that will be investigated as potential fixed effects in the model.
dat_micx_lake <- habs |>
  select(# Dependent variable and random effects
         MICX_DET, UNIQUE_ID, DSGN_CYCLE, 
         # Climate fixed effects
         Precip8110Ws, Tmean8110Ws, precip_mean_month, 
         # Setting fixed effects
         AG_ECO3, 
         # Lake morphology fixed effects
         MAXDEPTH, lakemorpho_fetch, 
         # Nutrient input fixed effects
         p_farm_inputs, 
         # Lake water fixed effects
         NTL, NITRATE_N, DOC, TEMPERATURE, EVAP_INFL) |>
  drop_na()

# Function to run independent error models with maximum likelihood 
run_micx_ie <- function(mod_vars, int = NULL){
  spglm(create_formula(dep_var = dep, ind_vars = mod_vars, interact = int),
        family = "binomial",
        data = dat_micx_lake,
        estmethod = "ml",
        spcov_type = "none",
        # random = ~ DSGN_CYCLE + UNIQUE_ID,
        local = T)
}

# Run a few candidate models. Tried to choose a few combinations of fixed effects from the four categories: Nutrient inputs, climate, setting, and lake morphology

# An initial model
mx1 <-run_micx_ie(mod_vars = c("NTL", "DOC", "precip_mean_month", "TEMPERATURE", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch"))

# Do the 30 year climate normal for precipitation fit better?
mx2 <-run_micx_ie(mod_vars = c("NTL", "DOC", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch"))

# Do dissolved N species improve model fit?
mx3 <-run_micx_ie(mod_vars = c("NTL", "NITRATE_N", "DOC", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch"))

# What about additional watershed metrics?
mx4 <-run_micx_ie(mod_vars = c("NTL", "NITRATE_N", "DOC", "p_farm_inputs", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch"))

# What about ecoregion?
mx5 <-run_micx_ie(mod_vars = c("NTL", "NITRATE_N", "DOC", "p_farm_inputs", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3"))

# What is there an interaction?
mx6 <-run_micx_ie(mod_vars = c("NTL", "NITRATE_N", "DOC", "p_farm_inputs", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3", int = "NTL * MAXDEPTH"))

# Review model AIC/BIC
glances(mx1, mx2, mx3, mx4, mx5, mx6)

# Make a list of the independent error models to compare
mx_ie_mods <- list(mx1, mx2, mx3, mx4, mx5, mx6)

# Run leave one out cross validation
mx_ie_loovc <- lapply(mx_ie_mods, loocv, cv_predict = TRUE)

# AUC based on loocv
mx_ie_auc_loocv <- sapply(1:length(mx_ie_loovc), function(i){
  preds <- mx_ie_loovc[[i]]$cv_predict
  calc <- pROC::roc(mx_ie_mods[[i]]$obdata$MICX_DET, preds)
  return(as.numeric(calc$auc))
})

mx_withlake_ie_fit <- do.call(rbind, lapply(mx_ie_loovc, function(list.obj){list.obj$stats}))

# Variables common to all models
com_vars <- c("NTL", "DOC", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch")

# Get the fixed effects that are different between the models
dif_vars <- sapply(mx_ie_mods, function(mod){
  coef_names <- names(mod$coefficients$fixed)
  coef_names <- coef_names[!coef_names %in% c("(Intercept)", com_vars)]
  paste(coef_names, collapse = ", ")
})

# Get any interaction terms

# Put it all together into a table, note that the table is organized by BIC
mx_ie_modcomp <- glances(mx1, mx2, mx3, mx4, mx5, mx6) |>
  arrange(model) |>
  cbind(mx_withlake_ie_fit) |>
  select(-npar, -value, -AICc, -logLik, -pseudo.r.squared) |> 
  mutate(AUC = mx_ie_auc_loocv,
         distinct_vars = dif_vars,
         common_vars = paste(com_vars, collapse = ", ")) |>
  arrange(BIC)

# Save the model comparison table
saveRDS(mx_ie_modcomp, "./inst/model_objects/micx_iemod_compare_withlakedata.rds")

# Based on the above analysis, models m4, m5, and m6 have the lower AIC/BIC and will be run with spatial covariance for final model selection

# Function to run spatial models
run_micx_sp <- function(mod_vars, int = NULL){
  spglm(create_formula(dep_var = dep, ind_vars = mod_vars, interact = int),
        family = "binomial",
        data = dat_micx_lake,
        spcov_type = "exponential",
        estmethod = "reml",
        random = ~ DSGN_CYCLE + UNIQUE_ID,
        local = T)
}

# Running with spatial covariance
mx4_sp <-run_micx_sp(mod_vars = c("NTL", "NITRATE_N", "DOC", "p_farm_inputs", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch"))

mx5_sp <-run_micx_sp(mod_vars = c("NTL", "NITRATE_N", "DOC", "p_farm_inputs", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3"))

mx6_sp <-run_micx_sp(mod_vars = c("NTL", "NITRATE_N", "DOC", "p_farm_inputs", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3", int = "NTL * MAXDEPTH"))

# Make a list of the models to compare
mx_lake_sp_mods <- list(mx4_sp, mx5_sp, mx6_sp)

# Run leave one out cross validation
mx_lake_sp_loocv <- lapply(mx_lake_sp_mods, loocv, cv_predict = TRUE)

mx_lake_sp_fit <- do.call(rbind, lapply(mx_lake_sp_loocv, function(list.obj){list.obj$stats}))

# AUC based on loocv
mx_lake_sp_auc <- sapply(1:length(mx_lake_sp_loocv), function(i){
  preds <- mx_lake_sp_loocv[[i]]$cv_predict
  calc <- pROC::roc(mx_lake_sp_mods[[i]]$obdata$MICX_DET, preds)
  return(as.numeric(calc$auc))
})

# Variables common to all models
com_vars <- c("NTL", "NITRATE_N", "DOC", "p_farm_inputs", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch")

# Get the fixed effects that are different between the models
dif_vars <- sapply(mx_lake_sp_mods, function(mod){
  coef_names <- names(mod$coefficients$fixed)
  coef_names <- coef_names[!coef_names %in% c("(Intercept)", com_vars)]
  paste(coef_names, collapse = ", ")
})

# Put it all together into a table
mx_lake_sp_modcomp <- mx_lake_sp_fit |>
  mutate(model = c("mx4_sp", "mx5_sp", "mx6_sp"),
         AUC = mx_lake_sp_auc,
         distinct_vars = dif_vars,
         common_vars = paste(com_vars, collapse = ", ")) |>
  arrange(desc(AUC))

# Save the model comparison table
saveRDS(mx_lake_sp_modcomp, "./inst/model_objects/mixc_spmod_compare_withlakedata.rds")

# The final model is model mx5_sp due to the highest AUC and lowest MSPE, though mx4_sp performs virtually identically
# The final model should be run using all available observations and with local = F
mod_vars <- c("NTL", "NITRATE_N", "DOC", "p_farm_inputs", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3")
int <- NULL
dat_final <- habs |>
  select(all_of(mod_vars), MICX_DET, DSGN_CYCLE, UNIQUE_ID) |>
  drop_na()

Sys.time()
micx_sp_withlake <- spglm(create_formula(dep_var = dep, ind_vars = mod_vars, interact = int),
                          family = "binomial",
                          data = dat_final,
                          spcov_type = "exponential",
                          estmethod = "reml",
                          random = ~ DSGN_CYCLE + UNIQUE_ID,
                          local = F)
Sys.time()


# Get bias, MSPE, and predictions for AUC
micx_sp_withlake_loocv <- loocv(micx_sp_withlake, cv_predict = TRUE)

# Get AUC from leave one out predictions
auc <- pROC::roc(micx_sp_withlake$obdata$MICX_DET, micx_sp_withlake_loocv$cv_predict)

micx_sp_withlake_auc <- as.numeric(auc$auc)

Sys.time()

# Save the best performing micx model so far
saveRDS(micx_sp_withlake, "./inst/model_objects/model_micx_withlakedata.rds")

# Run non-spatial model for comparison to final model
micx_nsp_withlake <- spglm(create_formula(dep_var = dep, ind_vars = mod_vars, interact = int),
                           family = "binomial",
                           data = dat_final,
                           estmethod = "reml",
                           spcov_type = "none",
                           local = F)

# Get bias, MSPE of non-spatial model
micx_nsp_withlake_loocv <- loocv(micx_nsp_withlake, cv_predict = TRUE)

# Get AUC from leave one out predictions
auc <- pROC::roc(micx_nsp_withlake$obdata$MICX_DET, micx_nsp_withlake_loocv$cv_predict)

micx_nsp_withlake_auc <- as.numeric(auc$auc)

# Visualize the results
# Boxplot of probabilities
micx_sp_withlake_aug <- augment(micx_sp_final_withlake, type.predict = "response")
levels(micx_sp_withlake_aug$MICX_DET) <- c("Below Detection", "Above Detection")

ggplot(data = micx_sp_withlake_aug, aes(x = MICX_DET, y = .fitted)) + 
      geom_boxplot(color = "#2A6BA6", alpha=0.3) + 
      xlab("Observed") +
      ylab("Fitted Probability") 
ggsave("./inst/figures/micx_sp_final_withlake_fitted_probs.png", height = 3, width = 3)

# Map of fitted probabilities

conus <- st_transform(AOI::aoi_get(state = "conus"), 5072)
ggplot() + 
  geom_sf(data = conus, fill = "#e2e2e2", color = "white", lwd = 1) +
  geom_sf(data = arrange(micx_sp_withlake_aug, .fitted), aes(fill = .fitted), pch = 21, size = 2) +
  scale_fill_gradientn(colors = RColorBrewer::brewer.pal(9, 'YlOrRd'),
                       name = "Fitted \nProbability") +
  theme_void()
ggsave("./inst/figures/micx_sp_final_withlake_fitted_probs_map.png", width = 5, height = 3.5, units = "in", dpi = 600)

```


### Microcystin, No In-Lake Conditions

```{r micx no lake data}
# Set the dependent variable
dep <- "MICX_DET"

# First conduct model comparison with independent error models. We do this because fitting spatial models is computationally expensive to do so in a way that models can be compared.

# Comparing AIC/BIC between models requires the same set of observations be used for all models. Trim the dataset to include just the variables that will be investigated as potential fixed effects in the model.
dat_micx <- habs |>
  select(# Dependent variable and random effects
         MICX_DET, UNIQUE_ID, DSGN_CYCLE, 
         # Climate fixed effects
         Precip8110Ws, Tmean8110Ws, precip_mean_month, temp_mean_month, 
         # Setting fixed effects
         BFIWs, RunoffWs, AG_ECO3, 
         # Lake morphology fixed effects
         MAXDEPTH, lakemorpho_fetch, 
         # Nutrient input fixed effects
         p_dev_inputs, n_dev_inputs, N_Total_Deposition, N_Surplus, p_farm_inputs, n_farm_inputs, fst_ws, wet_ws, KffactWs) |> 
  mutate(AG_ECO3 = factor(AG_ECO3, levels = c("WMTNS", "PLNLOW", "EHIGH"))) |>
  drop_na()

# Function to run independent error models

# Set the initial covariance to be small. This produces results identifcal to glm()
run_micx_ie <- function(mod_vars, int = NULL){
  spglm(create_formula(dep_var = dep, ind_vars = mod_vars, interact = int),
        family = "binomial",
        data = dat_micx,
        estmethod = "ml",
        spcov_type = "none",
        local = T)
}

# Run a few candidate models. Tried to choose a few combinations of fixed effects from the four categories: Nutrient inputs, climate, setting, and lake morphology

# Initial model
m1 <- run_micx_ie(mod_vars = c("n_farm_inputs", "p_dev_inputs", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs"), int = NULL)

m2 <- run_micx_ie(mod_vars = c("p_farm_inputs", "n_dev_inputs", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs"), int = NULL)

# Does the inclusion of ecoregion improve the model?
m3 <- run_micx_ie(mod_vars = c("p_farm_inputs", "n_dev_inputs", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = NULL)

# Does monthly climate data rather than annual MAT/MAP (m1) improve the model?
m4 <- run_micx_ie(mod_vars = c("p_farm_inputs", "n_dev_inputs", "precip_mean_month", "temp_mean_month", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = NULL)

# Would the addition of another variable describing nutrient inputs improve the model?
m5 <- run_micx_ie(mod_vars = c("p_farm_inputs", "n_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = NULL)

# Would interactions improve the model?
m6 <- run_micx_ie(mod_vars = c("p_farm_inputs", "n_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")

# Review model AIC/BIC
glances(m1, m2, m3, m4, m5, m6)

# Make a list of the independent error models to compare
micx_ie_mods <- list(m1, m2, m3, m4, m5, m6)

# Run leave one out cross validation
micx_ie_loocv <- lapply(micx_ie_mods, loocv, cv_predict = TRUE)

micx_nolake_ie_fit <- do.call(rbind, lapply(micx_ie_loocv, function(list.obj){list.obj$stats}))

# AUC based on loocv
micx_nolake_ie_auc <- sapply(1:length(micx_ie_loocv), function(i){
  preds <- micx_ie_loocv[[i]]$cv_predict
  calc <- pROC::roc(micx_ie_mods[[i]]$obdata$MICX_DET, preds)
  return(as.numeric(calc$auc))
})

# Variables common to all models
com_vars <- c("BFIWs", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3PLNLOW", "AG_ECO3EHIGH")

# Get the fixed effects that are different between the models
dif_vars <- sapply(micx_ie_mods, function(mod){
  coef_names <- names(mod$coefficients$fixed)
  coef_names <- coef_names[!coef_names %in% c("(Intercept)", com_vars)]
  paste(coef_names, collapse = ", ")
})

# Get any interaction terms

# Put it all together into a table, note that the table is organized by BIC
micx_ie_modcomp <- glances(m1, m2, m3, m4, m5, m6) |>
  arrange(model) |>
  cbind(micx_nolake_ie_fit) |>
  select(-npar, -value, -AICc, -logLik, -pseudo.r.squared) |> 
  mutate(AUC = micx_nolake_ie_auc,
         distinct_vars = dif_vars,
         common_vars = paste(com_vars, collapse = ", ")) |>
  arrange(BIC) |>
  tibble()

# Save the model comparison table
saveRDS(micx_ie_modcomp, "./inst/model_objects/micx_iemod_compare_nolakedata.rds")

# Based on the above analysis, models m3, m4, and m5 have the lower AIC/BIC and will be run with spatial covariance for final model selection

# Function to run spatial models
run_micx_sp <- function(mod_vars, int = NULL){
  spglm(create_formula(dep_var = dep, ind_vars = mod_vars, interact = int),
        family = "binomial",
        data = dat_micx,
        spcov_type = "exponential",
        estmethod = "reml",
        random = ~ DSGN_CYCLE + UNIQUE_ID,
        local = T)
}

# Run the models with spatial covariance
m3_sp <- run_micx_sp(mod_vars = c("p_farm_inputs", "n_dev_inputs", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = NULL)

m5_sp <- run_micx_sp(mod_vars = c("p_farm_inputs", "n_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = NULL)

m6_sp <- run_micx_sp(mod_vars = c("p_farm_inputs", "n_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")

# Make a list of the models to compare
micx_sp_mods <- list(m3_sp, m5_sp, m6_sp)

# Run leave one out cross validation
micx_sp_loocv <- lapply(micx_sp_mods, loocv, cv_predict = TRUE)

# AUC based on loocv
micx_sp_auc_loocv <- sapply(1:length(micx_sp_loocv), function(i){
  preds <- micx_sp_loocv[[i]]$cv_predict
  calc <- pROC::roc(micx_sp_mods[[i]]$obdata$MICX_DET, preds)
  return(as.numeric(calc$auc))
})

# Variables common to all models
com_vars <- c("p_farm_inputs", "n_dev_inputs", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3")

# Get the fixed effects that are different between the models
dif_vars <- sapply(micx_sp_mods, function(mod){
  coef_names <- names(mod$coefficients$fixed)
  coef_names <- coef_names[!coef_names %in% c("(Intercept)", com_vars)]
  paste(coef_names, collapse = ", ")
})

# Put it all together into a table
micx_sp_modcomp <- rbind(micx_sp_loocv[[1]]$stats, micx_sp_loocv[[2]]$stats, micx_sp_loocv[[3]]$stats) |>
  mutate(model = c("m3_sp", "m5_sp", "m6_sp"),
         AUC = micx_sp_auc_loocv,
         distinct_vars = dif_vars,
         common_vars = paste(com_vars, collapse = ", ")) |>
  arrange(desc(AUC)) |>
  tibble()

# Save the model comparison table
saveRDS(micx_sp_modcomp, "./inst/model_objects/micx_spmod_compare_nolakedata.rds")

# Two models, m6_sp and m5_sp, had the highest AUC values. Chose to go with m5_sp because if it's slightly simpler forumulation and interpretation (no interactions)
# The final model should be run using all available observations and with local = F
mod_vars <- c("p_farm_inputs", "n_dev_inputs", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3")
int <- NULL
dat_final <- habs |>
  select(all_of(mod_vars), MICX_DET, DSGN_CYCLE, UNIQUE_ID) |>
  drop_na()

Sys.time()
micx_sp_nolake <- spglm(create_formula(dep_var = dep, ind_vars = mod_vars, interact = int),
                        family = "binomial",
                        data = dat_final,
                        spcov_type = "exponential",
                        estmethod = "reml",
                        random = ~ DSGN_CYCLE + UNIQUE_ID,
                        local = F)
Sys.time()

# Get AUC of final model
# micx_sp_nolake_auc <- AUROC(micx_sp_nolake)

# Get bias, MSPE
micx_sp_nolake_loocv <- loocv(micx_sp_nolake, cv_predict = TRUE)

# Get AUC from leave one out predictions
auc <- pROC::roc(micx_sp_nolake$obdata$MICX_DET, micx_sp_nolake_loocv$cv_predict)

micx_sp_nolake_auc <- as.numeric(auc$auc)

Sys.time()

# Save the best performing micx model so far
saveRDS(micx_sp_nolake, "./inst/model_objects/model_micx_nolakedata.rds")

# Run non-spatial model for comparison to final model
micx_nsp_nolake <- spglm(create_formula(dep_var = dep, ind_vars = mod_vars, interact = int),
                           family = "binomial",
                           data = dat_final,
                           estmethod = "reml",
                           spcov_type = "none",
                           local = F)

# Get bias, MSPE of non-spatial model
micx_nsp_nolake_loocv <- loocv(micx_nsp_nolake, cv_predict = TRUE)

# Check AUC for loovc
auc <- pROC::roc(micx_nsp_nolake$obdata$MICX_DET, micx_nsp_nolake_loocv$cv_predict)

micx_nsp_nolake_auc <- as.numeric(auc$auc)

# Visualize the results
# Boxplot of probabilities
micx_sp_nolake_aug <- augment(micx_sp_final_nolake, type.predict = "response")
levels(micx_sp_nolake_aug$MICX_DET) <- c("Below Detection", "Above Detection")

ggplot(data = micx_sp_nolake_aug, aes(x = MICX_DET, y = .fitted)) + 
      geom_boxplot(color = "#2A6BA6", alpha=0.3) + 
      xlab("Observed") +
      ylab("Fitted Probability") 
ggsave("./inst/figures/micx_sp_final_fitted_probs.png", height = 3, width = 3)

# Map of fitted probabilities
conus <- st_transform(AOI::aoi_get(state = "conus"), 5072)
ggplot() + 
  geom_sf(data = conus, fill = "#e2e2e2", color = "white", lwd = 1) +
  geom_sf(data = micx_sp_nolake_aug, aes(fill = .fitted), pch = 21, size = 2) +
  scale_fill_gradientn(colors = RColorBrewer::brewer.pal(9, 'YlOrRd'),
                       name = "Fitted \nProbability") +
  theme_void()
ggsave("./inst/figures/micx_sp_final_fitted_probs_map.png", width = 5, height = 3.5, units = "in", dpi = 600)

# Map of standardized residuals
# Organize the data so that most extreme values are plotted on top
micx_sp_nolake_aug <- micx_sp_nolake_aug|>
  mutate(plot_order = factor(case_when(.std.resid < -2 ~ "L2",
                                  .std.resid > 2 ~ "L1",
                                  .std.resid < -1 & .std.resid >= -2 ~ "L3",
                                  TRUE ~ "L4"),
                        levels = c("L1", "L2", "L3", "L4"))) |>
  arrange(desc(plot_order))

breaks <- c(-2, -1, 0, 1, 2)
cols <- rev(RColorBrewer::brewer.pal(length(breaks) + 1, "Spectral"))

ggplot() + 
  geom_sf(data = conus, fill = "#e2e2e2", color = "white", lwd = 1) +
  geom_sf(data = micx_sp_nolake_aug, 
          aes(fill = .std.resid), pch = 21, size = 1.5) +
  scale_fill_stepsn(colors = cols,
                    breaks = breaks,
                    name = "Standardized \nResiduals") +
  theme_void()
ggsave("./inst/figures/micx_nolake_stdresiduals_map_NoEcoregion.png", width = 7, height = 3.5, units = "in", dpi = 600)

# The spatial covariance contribution to fitted values, mapped
micx_aug <- model_micx_nolakedata |>
  augment() |>
  mutate(.spde = fitted(model_micx_nolakedata, type = "spcov")$de, .after = .std.resid)

ggplot() + 
  geom_sf(data = conus, fill = "#e2e2e2", color = "white", lwd = 1) +
  geom_sf(data = arrange(micx_aug, .spde), 
          aes(fill = .spde), pch = 21, size = 1) +
  colorspace::scale_fill_continuous_divergingx(palette = 'RdBu', mid = 0, rev = TRUE) +
  theme_void()
ggsave("./inst/figures/micx_nolake_spde_map.png", width = 7, height = 3.5, units = "in", dpi = 600)

```

### Microcystin model comparison

Compare models with and without lake data and spatial and independent error models

```{r micx spatial and independent error model comparison}

# With lake data
micx_sp_withlake_auc
micx_sp_withlake_loocv$stats

micx_nsp_withlake_auc
micx_nsp_withlake_loocv$stats

# No lake data
micx_sp_nolake_auc
micx_sp_nolake_loocv$stats

micx_nsp_nolake_auc
micx_nsp_nolake_loocv$stats

# Comparison table
micx_spatial_comp <-
  rbind(micx_sp_withlake_loocv$stats,
        micx_nsp_withlake_loocv$stats,
        micx_sp_nolake_loocv$stats,
        micx_nsp_nolake_loocv$stats) |>
  mutate(resp_var = "micx",
         lake_data = c(rep("present", 2), 
                       rep("absent", 2)),
         spatial_mod = c(rep(c("spatial", "non-spatial"), 2)), .before = bias,
         auc = c(micx_sp_withlake_auc, 
                 micx_nsp_withlake_auc, 
                 micx_sp_nolake_auc, 
                 micx_nsp_nolake_auc))

# Save the table
saveRDS(micx_spatial_comp, "./inst/model_objects/spatial_compare_micx.rds")

```


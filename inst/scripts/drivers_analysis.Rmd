---
title: "drivers_analysis"
author: "Handler"
date: '2022-11-21'
output: html_document
editor_options: 
  chunk_output_type: console
---

Based on data compiled in drivers_compilation.Rmd

```{r setup, include=FALSE}
library(usethis)
library(devtools)
library(spmodel)
library(sf)
library(mapview)
library(dplyr)
library(tidyr)
library(ggplot2)
library(corrplot)

# Load all data and functions from HABsDrivers package
load_all()

# Detailed guide to spmodel
# https://usepa.github.io/spmodel/articles/guide.html
```


Some additional variables:

```{r}
# Calculate the chlorophyll a associated with cyanobacteria
habs <- mutate(habs, CHLA_CYANO = CHLA_RESULT * BG_BIOVOL/PHYT_BIOVOL, .after = CHLA_RESULT)

# Add a binary 1/0 variable for detect/non-detect of nitrate
habs <- mutate(habs, NITRATE_DET = ifelse(is.na(NITRATE_N), 0, 1), .after = NITRATE_N)

# Replace non-detect values for nitrate with 0
habs <- mutate(habs, NITRATE_N = ifelse(is.na(NITRATE_N), 0, NITRATE_N))

habs <- habs |>
  # Robert suggested using agricultural inputs rather than land cover
  mutate(n_farm_inputs = N_Fert_Farm + N_CBNF + N_livestock_Waste,
         n_dev_inputs = N_Human_Waste + N_Fert_Urban,
         p_farm_inputs = P_f_fertilizer + P_livestock_Waste,
         p_dev_inputs = P_human_waste_kg + P_nf_fertilizer) |> # ,
         # nfarm_inputs_pres = ifelse(n_farm_inputs == 0, 0, 1),
  # Creating a categorical variable for lake depth
  mutate(lake_dep = ifelse(MAXDEPTH <= 10, "shallow", "deep"))

# Create a categorical variable for microcystin detection
habs <- mutate(habs, MICX_DET = factor(ifelse(is.finite(MICX), 1, 0)))

# There is a MAXDEPTH measurement that is close to 1000 m and three lakemorpho observations > 500 m. Need to remove these.
# There are also some extreme values for the nutrient inputs. Could this be an issue with the watershed area?
habs <- habs|>
  mutate(MAXDEPTH = ifelse(MAXDEPTH > 200, NA, MAXDEPTH),
         lakemorpho_depth = ifelse(lakemorpho_depth > 500, NA, lakemorpho_depth),
         n_farm_inputs = ifelse(n_farm_inputs > 600, NA, n_farm_inputs),
         p_farm_inputs = ifelse(p_farm_inputs > 100, NA, p_farm_inputs),
         n_dev_inputs = ifelse(n_dev_inputs > 100, NA, n_dev_inputs),
         p_dev_inputs = ifelse(p_dev_inputs > 100, NA, p_dev_inputs),
         N_Surplus = ifelse(N_Surplus > 3000, NA, N_Surplus))
```


Examine the predictor data for colinear variables
- TN and DOC
- Precip8110Ws and Precip_Minus_EVTWs and RunoffWs
- nondev_ws and agr_ws
- SlopeWs and ElevWs
- N_Total_Inputs, N_Surplus, P_Surplus (r > 0.90)


```{r}
cormat_pred <- cor(st_drop_geometry(select(habs, TEMPERATURE:P_Surplus)), use = "pairwise.complete.obs")

# Trim to just the variables explored in the models
cor_dat <- habs |>
  st_drop_geometry() |>
  select(TEMPERATURE, MAXDEPTH, AMMONIA_N, DOC:NITRATE_N, PH, D_EXCESS, fst_ws, wet_ws, lakemorpho_fetch, BFIWs, KffactWs:Precip_Minus_EVTWs, Precip8110Ws, Tmean8110Ws, N_Total_Deposition, n_farm_inputs:p_dev_inputs) |>
  relocate(NTL, PTL, NITRATE_N, AMMONIA_N, DOC, PH, TEMPERATURE, TURB, D_EXCESS, fst_ws, wet_ws, KffactWs, n_farm_inputs, p_farm_inputs, n_dev_inputs, p_dev_inputs, N_Total_Deposition, Precip_Minus_EVTWs, Precip8110Ws, Tmean8110Ws, RunoffWs, BFIWs, MAXDEPTH, lakemorpho_fetch)

var_names <- c("Total N", 
               "Total P",   
               "Nitrate", 
               "Ammonia", 
               "DOC", 
               "pH", 
               "Water Temp",
               "Turbidity",
               "Evaporation", 
               "Forest Cover", 
               "Wetland Cover",
               "Soil Erodability",
               "Farm N",
               "Farm P",
               "Developed N", 
               "Developed P",
               "Deposition N", 
               "Precip-ET", 
               "Precip", 
               "Air Temp",
               "Runoff", 
               "Baseflow Index",
               "Lake Depth",
               "Lake Fetch")

cormat_pred <- cor(cor_dat, use = "pairwise.complete.obs", method = "spearman")

colnames(cormat_pred) <- var_names
rownames(cormat_pred) <- var_names

# Square plot
corrplot.mixed(cormat_pred, upper = "ellipse", diag = "n", tl.pos = "lt", tl.col = "black", tl.srt = 45)

# Lower triangle plot
cor_drivers <- corrplot(cormat_pred, method = "ellipse", type = "lower", tl.col = "black", tl.srt = 45)

# Save the plot
png(filename = "./figures/Correlation Matrix of Major Drivers.png", height = 6, width = 6, units = "in", bg = "transparent", res = 600)
corrplot(cormat_pred, method = "ellipse", type = "lower", tl.col = "black", tl.srt = 45)
dev.off()

```


How much of the variation in the response variables is potentially explainable based on the spatial versus temporal variation?


```{r}
# Assess spatial (signal) to temporal (noise) in response variables
do.call(rbind, lapply(c("MICX", "B_G_DENS", "CHLA_RESULT", "CHLA_CYANO"), function(x){
  form <- as.formula(paste(x, " ~ 1 + (1|SITE_ID)"))
  df   <- habs
  
  if(x == "MICX"){
    df <- drop_na(df, MICX)
  }
  
  if(x == "B_G_DENS" | x == "MICX"){
    form <- as.formula(paste("log10(", x, "+ 1) ~ 1 + (1|SITE_ID)"))
  }
  
  if(x == "CHLA_RESULT"){
    form <- as.formula(paste("log10(", x, ") ~ 1 + (1|SITE_ID)"))
  }
  
  if(x == "CHLA_CYANO"){
    form <- as.formula(paste("log10(", x, ") ~ 1 + (1|SITE_ID)"))
  }
  
  mod         <- lme4::lmer(form, data = df, REML = T, verbose = F)
  site.var    <- as.numeric(lme4::VarCorr(mod)) 
  visit.var   <- attr(lme4::VarCorr(mod), "sc")^2
  sn          <- site.var / visit.var
  maxR2       <- sn/(sn + 1)
  return(data.frame(variable = x, maxR2))
}))

```

Model setup

```{r model setup}
# Create variable groups
all_vars     <- colnames(habs)[match("TEMPERATURE", colnames(habs)):match("P_nf_fertilizer", colnames(habs))]
# Add in ecoregion
all_vars     <- c(all_vars, "AG_ECO3", "AG_ECO9_NM")
dep_vars     <- c("B_G_DENS", "MICX", "CYLSPER", "CHLA_RESULT", "CHLA_CYANO", "BG_BIOVOL", "PHYT_BIOVOL")
all_ind_vars <- all_vars[!all_vars %in% dep_vars]

# Dropping non-developed area of the watershed due to issues of colinearity with developed area. Also dropping nitrate data since it is missing for a large number of observations.
# all_ind_vars <- all_ind_vars[!all_ind_vars %in% c("nondev_ws", "NITRATE_N")]
# Dropping non-developed area of the watershed due to issues of colinearity with developed area.
all_ind_vars <- all_ind_vars[!all_ind_vars == "nondev_ws"]

# NLA water variables
nla_ind_vars <- c("TEMPERATURE", "MAXDEPTH", "STRATIFIED", "AMMONIA_N", "DO_SURF", "DOC", "NTL", "PTL", "TURB", "NITRATE_N", "NITRATE_DET", "PH", "EVAP_INFL", "D_EXCESS")
  
# All non-NLA variables
non_nla_vars <- all_ind_vars[!all_ind_vars %in% nla_ind_vars]

# All nutrient inventory variables
nni_vars <- colnames(habs)[match("N_CBNF", colnames(habs)):match("P_nf_fertilizer", colnames(habs))]

```

Helper to visualize fitted versus observed values from the model results

```{r}
vis_fit <- function(dep_var, splm_obj, file_name = NULL, width = 5, height = 4, dpi = 400){
  
  # Augment the splm object with the .fitted data
  aug <- augment(splm_obj) |>
    rename(obs = 1)
  
  # Title the figure according to response variable modeled
  name <- "Log10(Cyanobacteria + 1)"
  
  if(dep_var == "MICX_DET"){name = "Probability Microcystin Presence/Absence"}
  if(dep_var == "MICX"){name = "Log10(Microcystin Concentration)"}
  
  fig <- NULL
  
  # Construct the figure, continuous case
  if(dep_var == "MICX" | dep_var == "B_G_DENS"){
    
    # Max values for the axes
    max_val <- max(pull(aug, obs), pull(aug, .fitted))
    
    fig <- ggplot(data = aug, aes(x = obs, y = .fitted)) + 
      geom_point(color = "blue", alpha=0.3) + 
      xlim(0, max_val) + ylim(0, max_val) +
      xlab("Observed") +
      ylab("Fitted") +
      ggtitle(name)
  }
  
  # Binary case
  if(dep_var == "MICX_DET"){
    levels(aug$obs) <- c("Absent", "Present")
    
    fig <- ggplot(data = aug, aes(x = obs, y = .fitted)) + 
      geom_boxplot(color = "#2A6BA6", alpha=0.3) + 
      xlab("Observed") +
      ylab("Fitted") +
      ggtitle(name)
  }
  
  # Save the figure
  if(is.null(file_name) == FALSE){ggsave(paste0("./figures/", file_name), height = height, width = width, dpi = dpi, units = "in")}
  
  # Print a correlation test
  fit_test <- NULL
  if(dep_var == "MICX_DET"){fit_test = pROC::auc(aug$obs, aug$.fitted)}
  if((dep_var == "MICX" | dep_var == "B_G_DENS")){fit_test = cor.test(pull(aug, obs), pull(aug, .fitted))}
  
  print(fit_test)
  
  return(fig)
}

```


Experiment with some spatial models


```{r cyano models}

# Find a constant to add to the cyano for the log transformation

# function to find c
find_c <- function(par, formula, data) {
  const <- exp(par)
  mf <- model.frame(formula, data)
  data$.y <- log(model.response(mf) + const)
  new_formula <- update(formula, .y ~ .)
  lmod <- lm(new_formula, data)
  resids <- residuals(lmod)
  sigma <- summary(lmod)$sigma
  n <- NROW(data)
  ratio <- resids/sigma
  g1 <- sum(ratio^3) / n
  g2p <- sum(ratio^4) / n - 3
  g2 <- g2p + 6 / (lmod$df.residual + 2)
  g0 <- abs(g1) + abs(g2)
  g0
}

set.seed(1)

# example data
dat <- data.frame(x = rnorm(10), y = rnorm(10, mean = 10))

# HABs data
dat <- st_drop_geometry(drop_na(select(habs, B_G_DENS, NTL, NITRATE_N, NITRATE_DET, AMMONIA_N, DOC, Precip8110Ws, Tmean8110Ws, D_EXCESS, MAXDEPTH, agr_ws, AG_ECO3)))

# finds the c for log(y + c) (note that y should be on the original scale for
# the purposes of this function, as I take the log inside)
out <- optim(0, fn = find_c, formula = B_G_DENS ~ NTL + NITRATE_N + NITRATE_DET + AMMONIA_N + DOC + Precip8110Ws + Tmean8110Ws + D_EXCESS + MAXDEPTH + agr_ws + AG_ECO3 + AG_ECO3 * NTL, data = dat, method = "Brent", lower = -10, upper = 10)
c_value <- exp(out$par)
print(c_value)

# 2024-01-24 Models on cyanobacteria cell counts using all available explanatory variables

# Lessons learned: 

# There is a lot of missing biovolume data. Enough that I switched back to cyano count data. Will need to check with Karen about why so much data is missing for this parameter.

# TP isn't important unless TN is removed from the model. These two variables are likely highly colinear. Both TN and TP come out as important in the model if one of them has an interaction with three aggregated ecoregions. With TN*AG_ECO3, both the plains and western mountains come out as important plus the interaction between the plains and TN. With TP*AG_ECO3, the plains are important alone and there is an interaction between the plains and the western mountains and TP. When the interaction term is present between TN and the ecoregions, the effect of precipitation 30 yr normals and EVAP/INFL is lessened. However, the model with the lowest AIC lacks the interaction term. 

# Watershed mean slope and elevation were coming out as highly related to cyanos, but the effect diminished with the addition of the ecoregional data as a categorical variable. It's likely that slope and elevation were acting as proxies for the western mountain and xeric ecoregions that have much lower cyanos compared to other regions. Therefore, decided to include just the three aggregated ecoregions. 

# Also, the ecoregions are included as a fixed rather than a random effect now since the effect seems to be important and not an artifact of the NLA design. 

# Might consider playing around with having an ecoregional interaction term with some of the variables. This seemed promising when there was an interaction between ecoregion and TN, but not with any other variables (tried temp and agriculture). 

# The 30-year climate normals for temp and precip always outperformed the monthly means in which the sample was collected and the water temperature at the time of sampling. This is likely at least in part to the inclusion of a survey year random effect, but when survey year is removed and monthly means included, the model performs substantially worse.

# Note that in some preliminary tests the spatial regression models are explianing ~40-55% of the variation cyano count data while the random forest model explains ~28%.

# Experimenting with including nitrate in the models. Nitrate detection and concentration are negatively associated with cyanobacteria. TN, nitrate detected, and nitrate concentration can all be included in the same model. These three variables can also be included with TP and it comes out as important, though negatively correlated with cyanos which is confusing. Note that the addition of nitrate and ammonium variables increases the AIC relative to a model that only includes TN.

# Switched out E/I for d-excess following a conversation with Renee Brooks. D-excess is a measure of how much how evaporated the water is. When water is still, there is a higher evaporation rate. So d-excess can be thought of as a proxy for how long water has been sitting around evaporating. When d-excess is low, the water is more evaporated. It seems to have a stronger relationship with cyanos.

# Tried running the model as both Poisson and negative bionomial. Fits did not meaningfully change and interpretation is much more challenging. Decided to stick with a linear model for the time-being.

# Ran the code from Mike to identify an appropriate value of a constant to add to the cyano data in order to log transform. The constan

# Now that I am adding an optimized constant (1000) to the model, the effect of the ecoregion has disappeared. Now, when both TN and TP are in the model, they can both be important; although TP is less important than TN.

# Playing around with interactions between the ecoregions and TN, TP, and DOC and finding that generally the interaction has a negative coefficient value. I think that means that within a given ecoregion, increases in TN or TP or DOC are associated with a decrease in cyanos. Not sure how to square that with the overall positive realtionship with TN and TP. When there's an interaction between DOC and ecoregion, the direction of the overall relationship switches from negative to positive and then the interaction coefficients are negative.

# When total agricultural N inputs or excess agricultural N inputs are substituted in instead of agricultural cover, there variable is not significantly related and was negatively related to cyanos, which doesn't make sense. 

# Try an interactions between shallow and deep lakes per Jim Carleton's suggestion. Finding that both MAXDEPTH and depth as a categorical variable is important.

# Construct the model
dep_var  <- "B_G_DENS"
const <- 1000

# Function to run the cyano models by only supplying the model vars and the interaction term
run_cyano <- function(mod_vars, interact){
  splm(create_formula(dep_var, mod_vars, log = T, const = const, interact),
              data = filter(drop_na(habs, all_of(dep_var), all_of(mod_vars))),
              spcov_type = "exponential",
              random = ~ DSGN_CYCLE + UNIQUE_ID,
              local = T)
}

# Original full model
c1 <- run_cyano(mod_vars = c("NTL", "PTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "Precip8110Ws", "Tmean8110Ws", "D_EXCESS", "MAXDEPTH","p_farm_inputs", "AG_ECO3"), interact = "PTL * AG_ECO3")

# No interaction 
c2 <- run_cyano(mod_vars = c("NTL", "PTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "Precip8110Ws", "Tmean8110Ws", "D_EXCESS", "MAXDEPTH","p_farm_inputs", "AG_ECO3"), interact = NULL)

# Remove ecoregions
c3 <- run_cyano(mod_vars = c("NTL", "PTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "Precip8110Ws", "Tmean8110Ws", "D_EXCESS", "MAXDEPTH","p_farm_inputs"), interact = NULL)

# Try different nutrient inputs associated with agriculture (p farm inputs seem to fit best)
c4 <- run_cyano(mod_vars = c("NTL", "PTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "Precip8110Ws", "Tmean8110Ws", "D_EXCESS", "MAXDEPTH","n_farm_inputs"), interact = NULL)
c5 <- run_cyano(mod_vars = c("NTL", "PTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "Precip8110Ws", "Tmean8110Ws", "D_EXCESS", "MAXDEPTH","n_farm_inputs", "p_farm_inputs"), interact = NULL)
c6 <- run_cyano(mod_vars = c("NTL", "PTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "Precip8110Ws", "Tmean8110Ws", "D_EXCESS", "MAXDEPTH","agr_ws"), interact = NULL)
c7 <- run_cyano(mod_vars = c("NTL", "PTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "Precip8110Ws", "Tmean8110Ws", "D_EXCESS", "MAXDEPTH","P_Accumulated_ag_inputs"), interact = NULL)

# Does TP or TN perform better? TN performs better
c8 <- run_cyano(mod_vars = c("NTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "Precip8110Ws", "Tmean8110Ws", "D_EXCESS", "MAXDEPTH","p_farm_inputs"), interact = NULL)
c10 <- run_cyano(mod_vars = c("PTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "Precip8110Ws", "Tmean8110Ws", "D_EXCESS", "MAXDEPTH","p_farm_inputs"), interact = NULL)

# Remove dissolved N species. Clearly performs worse
c9 <- run_cyano(mod_vars = c("NTL", "DOC", "PH", "Precip8110Ws", "Tmean8110Ws", "D_EXCESS", "MAXDEPTH","p_farm_inputs"), interact = NULL)

# Do the annual or monthly climate means perform better? Yes for AIC, but no for pseudo R2, performs the same for R2 though
c11 <- run_cyano(mod_vars = c("NTL", "PTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "precip_mean_month", "temp_mean_month", "D_EXCESS", "MAXDEPTH","p_farm_inputs"), interact = NULL)

# What about some other water variables
c12 <- run_cyano(mod_vars = c("NTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "TURB", "Precip8110Ws", "Tmean8110Ws", "D_EXCESS", "MAXDEPTH","p_farm_inputs"), interact = NULL)
c13 <- run_cyano(mod_vars = c("NTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "TURB", "TEMPERATURE", "Precip8110Ws", "Tmean8110Ws", "D_EXCESS", "MAXDEPTH","p_farm_inputs"), interact = NULL)

# D_excess versus evap/inflow
c14 <- run_cyano(mod_vars = c("NTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "TURB", "TEMPERATURE", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH","p_farm_inputs"), interact = NULL)

# Other nutrient input variables. Perhaps consider including wetland area.
c15 <- run_cyano(mod_vars = c("NTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "TURB", "TEMPERATURE", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH","p_farm_inputs", "wet_ws"), interact = NULL)
c16 <- run_cyano(mod_vars = c("NTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "TURB", "TEMPERATURE", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH","p_farm_inputs", "fst_ws"), interact = NULL)
c17 <- run_cyano(mod_vars = c("NTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "TURB", "TEMPERATURE", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH","p_farm_inputs", "N_Total_Deposition"), interact = NULL)
c18 <- run_cyano(mod_vars = c("NTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "TURB", "TEMPERATURE", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH","p_farm_inputs", "KffactWs"), interact = NULL)

# What about other lake or setting information? Lake fetch and baseflow index may be important
c19 <- run_cyano(mod_vars = c("NTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "TURB", "TEMPERATURE", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH","wet_ws", "p_farm_inputs", "lakemorpho_fetch"), interact = NULL)
c20 <- run_cyano(mod_vars = c("NTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "TURB", "TEMPERATURE", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "wet_ws", "p_farm_inputs", "BFIWs"), interact = NULL)
c22 <- run_cyano(mod_vars = c("NTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "TURB", "TEMPERATURE", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "wet_ws", "p_farm_inputs", "lakemorpho_fetch", "BFIWs"), interact = NULL)
c21 <- run_cyano(mod_vars = c("NTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "TURB", "TEMPERATURE", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH","wet_ws","p_farm_inputs", "RunoffWs"), interact = NULL)
c23 <- run_cyano(mod_vars = c("NTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "TURB", "TEMPERATURE", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "wet_ws", "p_farm_inputs", "BFIWs", "AG_ECO3"), interact = NULL)

# Best fit so far?
c20 <- run_cyano(mod_vars = c("NTL", "NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "TURB", "TEMPERATURE", "Precip8110Ws", "Tmean8110Ws", "EVAP_INFL", "MAXDEPTH", "wet_ws", "p_farm_inputs", "BFIWs"), interact = NULL)

cyano <- splm(create_formula(dep_var, mod_vars, log = T, const = const, interact = NULL),
              data = filter(drop_na(habs, all_of(dep_var), all_of(mod_vars))),
              spcov_type = "exponential",
              random = ~ DSGN_CYCLE + UNIQUE_ID,
              local = T)

# Look at model details
summary(c20)
varcomp(cyano)

# Model comparison

# Evaluate fit
cyano_pred       <- filter(drop_na(habs, all_of(dep_var), all_of(mod_vars)))
cyano_loocv      <- loocv(cyano, cv_predict = TRUE)
cyano_pred$preds <- cyano_loocv$cv_predict

max_val <- max(log10(cyano_pred$B_G_DENS + const), cyano_pred$preds)
name    <- paste0("Log10(Cyanobacteria + ", const,")")

fig <- ggplot(data = cyano_pred, aes(x = preds, y = log10(B_G_DENS + const))) +
  geom_point(color = "#2A6BA6", alpha=0.3, size = 2) +
  xlim(2.8, 7) + ylim(2.8, 7) +
  ylab("Observed") +
  xlab("Fitted") +
  ggtitle(name)
ggsave(paste0("./figures/", "Model Fit_Cyano.jpg"), fig, height = 4, width = 5, bg = "transparent", dpi = 400, units = "in")

# Best model so far (?)
dep_var  <- "B_G_DENS"
mod_vars <- c("NTL","NITRATE_N", "NITRATE_DET", "AMMONIA_N", "DOC", "PH", "Precip8110Ws", "Tmean8110Ws", "D_EXCESS", "MAXDEPTH", "n_farm_inputs")
cyano <- splm(create_formula(dep_var, mod_vars, log = T, const, interact = NULL),
                 data = drop_na(habs, all_of(dep_var), all_of(mod_vars)),
                 spcov_type = "exponential",
                 random = ~ DSGN_CYCLE + UNIQUE_ID,
                 local = T)

summary(cyano)
varcomp(cyano)

# Evaluate fit
cyano_pred       <- filter(drop_na(habs, all_of(dep_var), all_of(mod_vars)))
cyano_loocv      <- loocv(cyano, cv_predict = TRUE)
cyano_loocv$stats

# Save the model
# saveRDS(cyano, "./inst/model_objects/model_cyano_withlakedata.rds")

# Cyanobacteria models without NLA covariates

# *** Turns out I was using mass of N and P inputs rather than area-normalized inputs. This has been updated in the input data. Now N and P inputs are on a per hectare basis and the numbers are more reasonable and not in the billions/millions. ***

# Individual N and P inputs were not really related to cyanos. Only N_CBNF was significantly related to cyanos, but the relationship was negative. Sometimes P_livestock_waste was related and was positive. Total_N_Inputs was negatively related to cyanos. 

# Summarizing N and P inputs into farm and development categories did not result in any of the variables being significantly related to the cyanobacteria counts.

# Piling in non-inventory watershed variables improves the amount of variation explained, but not by much. Agriculture and developed land cover in the watershed is more associated with cyanobacteria that any of the nutrient inventory variables. 

# There are a few extremely high observations of N farm inputs. Perhaps try log-transforming this covariate? Then there are >800 observations with no N farm inputs. So created a variable for the presence/absence of farm inputs. Even still, these variables almost never come out as important.

# On recommendation from Ryan, I tried removing the random effect for the lake ID. It appears that the variation assigned to the lake ID gets reallocated to the spatially dependent error term. 

# There are still a bunch of extreme values for the N and P inputs. Even when these extreme values are removed, it doesn't result in covariates having stronger relationships with the response.

# Baseflow index is more strongly related than runoff.

# Adding N_Rock and N_Total_Dep were related when included together, but N_Rock was negatively related. N_Total_Dep was positively related. 

# Construct the model
dep_var  <- "B_G_DENS"
const    <- 1000
mod_vars <- c("N_Fert_Farm", "N_CBNF", "N_Livestock_N_Content", "N_Human_Waste", "N_Fert_Urban", "P_Surplus", "P_f_fertilizer", "P_livestock_Waste", "P_human_waste_kg", "P_nf_fertilizer")

mod_vars <- c("N_Total_Inputs", "P_Surplus", "AG_ECO3")

mod_vars <- c("n_farm_inputs", "n_dev_inputs", "p_farm_inputs", "p_dev_inputs")

mod_vars <- c("agr_ws", "dev_ws", "fst_ws", "dev_ws", "wet_ws", "Precip_Minus_EVTWs", "BFIWs", "precip_mean_month", "temp_mean_month", "RunoffWs", "lakemorpho_depth", "lakemorpho_fetch", "AgKffactWs", "n_farm_inputs", "p_farm_inputs", "p_dev_inputs", "AG_ECO3")

mod_vars <- c("agr_ws", "dev_ws", "wet_ws", "fst_ws", "BFIWs", "RunoffWs", "Tmean8110Ws", "Precip8110Ws", "N_Fert_Farm", "N_Total_Deposition", "N_CBNF", "N_Fert_Urban","N_livestock_Waste", "P_f_fertilizer", "P_nf_fertilizer", "P_livestock_Waste", "lakemorpho_depth", "KffactWs", "AG_ECO3")

mod_vars <- c("agr_ws", "dev_ws", "wet_ws", "fst_ws", "BFIWs", "RunoffWs", "Tmean8110Ws", "Precip8110Ws", "N_Total_Deposition", "n_farm_inputs", "n_dev_inputs", "p_farm_inputs", "p_dev_inputs", "lakemorpho_depth", "KffactWs", "AG_ECO3")

mod_vars <- c("wet_ws", "fst_ws", "BFIWs", "RunoffWs", "Tmean8110Ws", "Precip8110Ws", "N_Total_Deposition", "n_farm_inputs", "n_dev_inputs", "p_farm_inputs", "p_dev_inputs", "lakemorpho_depth", "KffactWs", "AG_ECO3")

mod_vars <- c("fst_ws", "BFIWs", "Tmean8110Ws", "Precip8110Ws", "N_Total_Deposition", "n_farm_inputs", "n_dev_inputs", "p_farm_inputs", "p_dev_inputs", "lake_dep", "AG_ECO3")

mod_vars <- c("BFIWs", "Tmean8110Ws", "Precip8110Ws", "N_Total_Deposition", "n_farm_inputs", "p_dev_inputs", "lake_dep", "AG_ECO9_NM")

mod_vars <- c("BFIWs", "Tmean8110Ws", "Precip8110Ws", "N_Total_Deposition", "n_farm_inputs", "p_farm_inputs", "p_dev_inputs", "lake_dep", "AG_ECO3")

# Seems like a reasonable mix of variables so far
mod_vars <- c("BFIWs", "Tmean8110Ws", "Precip8110Ws", "n_farm_inputs", "n_dev_inputs", "p_farm_inputs", "lake_dep", "AG_ECO3")

# Trying the same variables with interactions by ecoregion and lake depth. No interaction between N farm inputs and lake depth, but there was an interaction with ecoregion. P farm inputs are related to cyanos and interact with ecoregion. Not enough power to include interactions for nutrients and ecoregion for both N and P farm inputs.

# Lake depth as a categorical variable always fits better than the continuous variable. The 30 yr climate normals always fit better than the month means.

# Having trouble with P_accumulated_ag_inputs and P farm inputs. Since they are highly correlated with each other and other input variables. Accumulated P inputs are important only when P farm inputs are also included, but the variable seems to sop up variation from the P farm inputs so it's no longer significant. When accumulated inputs are included alone, it's not important. Concluding to leave it out for now.

# Rock N has a negative relationship. Not sure what the mechanism is here. It tends to mop up variation from other variables when present. Total N Deposition doesn't appear to have a relationship.
mod_vars <- c("BFIWs", "Tmean8110Ws", "Precip8110Ws", "n_farm_inputs", "n_dev_inputs", "p_farm_inputs", "lake_dep", "lakemorpho_fetch", "AG_ECO3")

# There is *maybe* an additional interaction between n_farm_inputs and lake depth (categorical: deep/shallow). A comparison of AIC and variation captured by covariates is slightly improved with the interaction. In all these cases, the relationship between N farm inputs and cyanos is slightly negative for the western mountains/xeric ecoregion, although not highly important. 

# Switching the order of the categorical variables
habs <- mutate(habs, AG_ECO3 = factor(AG_ECO3, levels = c("WMTNS", "PLNLOW", "EHIGH")))
habs <- mutate(habs, lake_dep = factor(lake_dep, levels = c("shallow", "deep")))

# Best fit so far? 
mod_vars <- c("BFIWs", "Tmean8110Ws", "Precip8110Ws", "n_farm_inputs", "n_dev_inputs", "p_farm_inputs", "lake_dep", "lakemorpho_fetch")

cyano <- splm(create_formula(dep_var, mod_vars, log = T, const = const, 
                             interact = NULL),
              data = filter(drop_na(habs, all_of(dep_var), all_of(mod_vars))),
              spcov_type = "exponential",
              random = ~ DSGN_CYCLE + UNIQUE_ID,
              local = T)

# Look at model details
summary(cyano)
varcomp(cyano)

# Evaluate fit
cyano_pred       <- filter(drop_na(habs, all_of(dep_var), all_of(mod_vars)))
cyano_loocv      <- loocv(cyano, cv_predict = TRUE)
cyano_pred$preds <- cyano_loocv$cv_predict

# Save the model object
# saveRDS(cyano, "./inst/model_objects/model_cyano_nolakedata.rds")

max_val <- max(log10(cyano_pred$B_G_DENS + const), cyano_pred$preds)
name    <- paste0("Log10(Cyanobacteria + ", const,")")

fig <- ggplot(data = cyano_pred, aes(x = preds, y = log10(B_G_DENS + const))) +
  geom_point(color = "#2A6BA6", alpha=0.3, size = 2) +
  xlim(2.8, 7) + ylim(2.8, 7) +
  ylab("Observed") +
  xlab("Fitted") +
  geom_abline(intercept = 0, slope = 1)
  # ggtitle(name)
ggsave(paste0("./figures/", "Model Fit_Cyano_No NLA Vars.jpg"), fig, height = 4, width = 4, bg = "transparent", dpi = 400, units = "in")

# Hex observation density plot
fig <- ggplot(data = cyano_pred, aes(x = preds, y = log10(B_G_DENS + const))) +
  geom_hex(bins = 60) +
  scale_fill_continuous(type = "viridis") +
  xlim(2.8, 7) + ylim(2.8, 7) +
  ylab("Observed") +
  xlab("Fitted") +
  theme_bw()
ggsave(paste0("./figures/", "Model Fit_Cyano_No NLA Vars.jpg"), fig, height = 4, width = 5, bg = "transparent", dpi = 600, units = "in")

# Static map
conus <- st_transform(AOI::aoi_get(state = "conus"), 5070)
aug_bins <- cyano9 |>
  augment() |>
  mutate(bin = case_when(.std.resid < -2 ~ "c1",
                         .std.resid > -2 & .std.resid <= -1 ~ "c2",
                         .std.resid > -1 & .std.resid <= 0 ~ "c3",
                         .std.resid > 0 & .std.resid <= 1 ~ "c4",
                         .std.resid > 1 & .std.resid <= 2 ~ "c5",
                         .std.resid > 2 & .std.resid <= 3 ~ "c6",
                         .std.resid > 3 ~ "c7")) |>
  arrange(abs(.std.resid))
  
ggplot() + 
  geom_sf(data = conus, fill = "#e2e2e2", color = "white", size = 0.5) +
  geom_sf(data = aug_bins, aes(fill = bin), pch = 21) +
  scale_fill_manual(values = c('#7f3b08','#e08214','#fee0b6','#d8daeb','#b2abd2','#8073ac','#2d004b'),
                    name = " ", 
                    breaks = c(paste0("c", 1:7)),
                    labels = (c("< -2", "-2 - -1","-1 - 0","0 - 1","1 - 2","2 - 3", "> 3"))) +
  theme_void() +
  ggtitle("Cyanobacteria: Standardized Residuals") +
  theme(plot.title = element_text(hjust = 0.5, vjust = 1, size = 12))
ggsave("./figures/Cyano_StdResidMap.png", width = 6, height = 3.5, units = "in", dpi = 600)

# Map of fitted probability
# Side-by-side of observed and fitted values
mapper <- aug_bins |>
  rename(Observed = `log10(B_G_DENS + 1000)`,
         Estimated = .fitted) |>
  pivot_longer(cols = c(Observed, Estimated), names_to = "type", values_to = "value")

ggplot() + 
  geom_sf(data = conus, fill = "#e2e2e2", color = "white", size = 0.5) +
  geom_sf(data = arrange(mapper, value), aes(fill = value), pch = 21) +
  facet_wrap(~type) +
  scale_fill_gradientn(colors = RColorBrewer::brewer.pal(9, 'YlOrRd'),
                       name = "Cyanobacteria \n (cells/mL)", 
                       breaks = c(log10(0+1000),log10(10000+1000),log10(10^5+1000), log10(10^6+1000), log10(10^7+1000)),
                       labels = c("0", "10,000", "100,000", "1,000,000", "10,000,000")) +
  theme_void() +
  ggtitle("Cyanobacteria Abundance")+
  theme(plot.title = element_text(hjust = 0.5, vjust = 1, size = 12))
ggsave("./figures/Map_Cyano_EstimatedObserved.png", width = 8, height = 4, units = "in", dpi = 600)

# Map of observed cyanobacteria
ggplot() + 
  geom_sf(data = conus, fill = "#e2e2e2", color = "white", size = 0.5) +
  geom_sf(data = arrange(aug_bins, `log10(B_G_DENS + 1000)`), aes(fill = `log10(B_G_DENS + 1000)`), pch = 21) +
  scale_fill_gradientn(colors = RColorBrewer::brewer.pal(9, 'YlOrRd'),
                       name = "Cyanobacteria \n (cells/mL)", 
                       breaks = c(log10(0+1000),log10(10000+1000),log10(10^5+1000), log10(10^6+1000), log10(10^7+1000)),
                       labels = c("0", "10,000", "100,000", "1,000,000", "10,000,000")) +
  theme_void() +
  ggtitle("Observed Cyanobacteria Abundance")+
  theme(plot.title = element_text(hjust = 0.5, vjust = 1, size = 12))
ggsave("./figures/ObservedMap_Cyano.png", width = 6, height = 3.5, units = "in", dpi = 600)

# NLA lake locations for ASLO presentation
ggplot() + 
  geom_sf(data = conus, fill = "#e2e2e2", color = "white", size = 0.5) +
  geom_sf(data = habs, aes(shape = DSGN_CYCLE), color = "blue", bg = "black", alpha = 0.5) +
  scale_shape(name = "Survey Year") +
  theme_void() 
ggsave("./figures/NLA071217Lakes.png", width = 6, height = 3.5, units = "in", dpi = 600)

# Make a function to examine bi-plots of variables
biplot <- function(data = habs, xvar, log = F){
  x <- pull(data[,match(xvar, colnames(data))], 1)
  p <- ggplot(data) +
    geom_point(aes(y = log10(B_G_DENS + 1000), x = x), color = "blue", alpha = 0.3) +
    xlab(xvar)
  if(log == T){
    p <- p + scale_x_log10() + xlab(paste0("log10(", xvar, ")"))
  }
  return(p)
}

biplot(xvar = "n_farm_inputs", log = F)
biplot(xvar = "n_farm_inputs", log = T)
biplot(xvar = "p_farm_inputs", log = F)
biplot(xvar = "p_farm_inputs", log = T)
biplot(xvar = "n_dev_inputs", log = F)
biplot(xvar = "n_dev_inputs", log = T)
biplot(xvar = "p_dev_inputs", log = F)
biplot(xvar = "p_dev_inputs", log = T)
biplot(xvar = "N_Surplus", log = T)
ggsave(paste0("./figures/Biplot_Cyano vs farm P inputs.jpg"), biplot(xvar = "p_farm_inputs", log = F),height = 3, width = 3, bg = "transparent", dpi = 400, units = "in")

# No ecoregion or interaction terms, lake depth is categorical
cyano1 <- run_cyano(mod_vars = c("BFIWs", "Tmean8110Ws", "Precip8110Ws", "n_farm_inputs", "n_dev_inputs", "p_farm_inputs", "lake_dep", "lakemorpho_fetch"), interact = NULL)

# No ecoregion or interaction terms, lake depth is continuous. Continuous lake depth is better fit.
cyano9 <- run_cyano(mod_vars = c("BFIWs", "Tmean8110Ws", "Precip8110Ws", "n_farm_inputs", "n_dev_inputs", "p_farm_inputs", "MAXDEPTH", "lakemorpho_fetch"), interact = NULL)

# No ecoregion or interaction terms, lake depth is continuous, climate is monthly
cyano10 <- run_cyano(mod_vars = c("BFIWs", "temp_mean_month", "precip_mean_month", "n_farm_inputs", "n_dev_inputs", "p_farm_inputs", "MAXDEPTH", "lakemorpho_fetch"), interact = NULL)

# Add ecoregion, but still no interaction
cyano2 <- run_cyano(mod_vars = c("BFIWs", "Tmean8110Ws", "Precip8110Ws", "n_farm_inputs", "n_dev_inputs", "p_farm_inputs", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3"), interact = NULL)

# Add ecoregion interactions with the nutrient inputs
cyano3 <- run_cyano(mod_vars = c("BFIWs", "Tmean8110Ws", "Precip8110Ws", "n_farm_inputs", "n_dev_inputs", "p_farm_inputs", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3"), interact = "n_farm_inputs * AG_ECO3")

cyano4 <- run_cyano(mod_vars = c("BFIWs", "Tmean8110Ws", "Precip8110Ws", "n_farm_inputs", "n_dev_inputs", "p_farm_inputs", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3"), interact = "p_farm_inputs * AG_ECO3")

cyano5 <- run_cyano(mod_vars = c("BFIWs", "Tmean8110Ws", "Precip8110Ws", "n_farm_inputs", "n_dev_inputs", "p_farm_inputs", "MAXDEPTH", "lakemorpho_fetch", "AG_ECO3"), interact = "n_dev_inputs * AG_ECO3")

# Interact with lake depth instead of ecoregion
cyano6 <- run_cyano(mod_vars = c("BFIWs", "Tmean8110Ws", "Precip8110Ws", "n_farm_inputs", "n_dev_inputs", "p_farm_inputs", "MAXDEPTH", "lakemorpho_fetch"), interact = "n_farm_inputs * MAXDEPTH")

cyano7 <- run_cyano(mod_vars = c("BFIWs", "Tmean8110Ws", "Precip8110Ws", "n_farm_inputs", "n_dev_inputs", "p_farm_inputs", "MAXDEPTH", "lakemorpho_fetch"), interact = "p_farm_inputs * MAXDEPTH")

cyano8 <- run_cyano(mod_vars = c("BFIWs", "Tmean8110Ws", "Precip8110Ws", "n_farm_inputs", "n_dev_inputs", "p_farm_inputs", "MAXDEPTH", "lakemorpho_fetch"), interact = "n_dev_inputs * MAXDEPTH")

glances(cyano1, cyano2, cyano3, cyano4, cyano5, cyano6, cyano7, cyano8)

```


Models for microcystin detection (presence/absence)


```{r}
# Use binary microcystin variable
dep_var  <- "MICX_DET"

run_micx <- function(mod_vars, int = NULL){
  spglm(create_formula(dep_var = "MICX_DET", ind_vars = mod_vars, interact = int),
                family = "binomial",
                data = drop_na(habs, all_of(dep_var), all_of(mod_vars)),
                spcov_type = "none",
                random = ~ DSGN_CYCLE + UNIQUE_ID,
                local = T)
}

# Lessons learned
# These models take substantially longer to run than the linear models and the estimated covariates are most unstable when run using approximation methods (local = T).

# The temperature and precip data never seem to be important to this model.

# Soil erodibility (Kf) is inversely associated with microcystin detection?

# These were all run with local = T
micx1 <- run_micx(mod_vars = c("NTL","PTL", "DOC", "PH", "dev_ws", "agr_ws", "KffactWs", "precip_mean_month", "TEMPERATURE", "BFIWs", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch", "AG_ECO3"))

micx2 <- run_micx(mod_vars = c("NTL","PTL", "DOC", "PH", "dev_ws", "agr_ws", "wet_ws", "KffactWs", "precip_mean_month", "temp_mean_month", "BFIWs", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch", "AG_ECO3"), int = "PTL*AG_ECO3")

micx3 <- run_micx(mod_vars = c("NTL","PTL", "DOC", "PH", "dev_ws", "agr_ws", "KffactWs", "precip_mean_month", "temp_mean_month", "BFIWs", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch", "AG_ECO3"), int = "NTL*AG_ECO3")

micx4 <- run_micx(mod_vars = c("NTL", "DOC", "PH", "dev_ws", "agr_ws", "KffactWs", "precip_mean_month", "temp_mean_month", "BFIWs", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch", "AG_ECO3"))

micx5 <- run_micx(mod_vars = c("NTL", "PH", "dev_ws", "agr_ws", "KffactWs", "temp_mean_month", "BFIWs", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch", "AG_ECO3"))

# Set local = F here since it seems like the estimates are changing quite a bit between estimated runs
micx6 <- run_micx(mod_vars = c("NTL", "PH", "dev_ws", "agr_ws", "KffactWs", "temp_mean_month", "BFIWs", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch", "AG_ECO3"))

# Back to local = T
micx7 <- run_micx(mod_vars = c("NTL", "PH", "dev_ws", "agr_ws", "KffactWs", "temp_mean_month", "BFIWs", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch", "RunoffWs", "AG_ECO3"))

# Best fit so far? Hard to know when running models using approximation methods.
micx8 <- run_micx(mod_vars = c("NTL", "PH", "dev_ws", "agr_ws", "KffactWs", "temp_mean_month", "BFIWs", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch", "AG_ECO3"))

# Try with dissolved N species
micx9 <- run_micx(mod_vars = c("NTL","NITRATE_DET","NITRATE_N", "AMMONIA_N", "PH", "dev_ws", "agr_ws", "KffactWs", "temp_mean_month", "BFIWs", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch", "AG_ECO3"))

# Try with no spatial covariation
micx10 <- run_micx(mod_vars = c("NTL","NITRATE_DET","NITRATE_N", "PH", "dev_ws", "agr_ws", "KffactWs", "temp_mean_month", "BFIWs", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch", "AG_ECO3"))

# Take out developed area and monthly temperature 
micx11 <- run_micx(mod_vars = c("NTL", "PH", "agr_ws", "dev_ws", "KffactWs", "BFIWs", "temp_mean_month", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch", "AG_ECO3"))

# What happens when we replace ag cover with ag N inputs of excess ag inputs?
micx12 <- run_micx(mod_vars = c("NTL", "PH", "p_dev_inputs", "KffactWs", "BFIWs", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch", "AG_ECO3"))

# Best fit model so far with NLA water data
micx11 <- run_micx(mod_vars = c("NTL", "PH", "agr_ws", "dev_ws", "KffactWs", "BFIWs", "temp_mean_month", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch", "AG_ECO3"))

# Save this model
# saveRDS(micx11, "./inst/model_objects/model_micx_withlakedata.rds")

### Running Models with nutrient inventory instead of land cover

# The models do run when replace with the log-transformed N inputs. Guessing that the extreme values make the model difficult to fit.

# Turns out I was working with nutrient inventory numbers that weren't normalized to the watershed area. As a result, there were some extremely high numbers in the data.

# What happens when we replace ag cover with ag N inputs of excess ag inputs?
micx13 <- run_micx(mod_vars = c("NTL", "PH", "n_farm_inputs", "n_dev_inputs", "BFIWs", "MAXDEPTH", "EVAP_INFL", "lakemorpho_fetch", "AG_ECO3"))

# Just run with the nutrient inventory inputs. Only P farm inputs important. N farm inputs and P developed inputs may be important. When both N and P farm inputs are included, P is more important than N. 
# Adding an interaction between N farm inputs and ecoregion revealed a potential effect of N in the eastern highlands, but nowhere else.
# Adding an interaction between P farm inputs and ecoregion suggests that P farm inputs is only related to MICX detection in the eastern highlands ecoregion.
# Adding two interaction terms helped nothing
# Lake depth does interact with P farm inputs
micx20 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "n_dev_inputs", "p_dev_inputs"))
micx20 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs"))
micx20 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "AG_ECO3"), int = "n_farm_inputs * AG_ECO3")
micx20 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")
micx20 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3 + n_farm_inputs * AG_ECO3")
micx20 <- run_micx(mod_vars = c("p_farm_inputs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")
micx20 <- run_micx(mod_vars = c("p_farm_inputs", "AG_ECO3", "lake_dep"), int = "p_farm_inputs * lake_dep")

# Switching the order of the categorical variables
habs <- mutate(habs, AG_ECO3 = factor(AG_ECO3, levels = c("WMTNS", "PLNLOW", "EHIGH")))
habs <- mutate(habs, lake_dep = factor(lake_dep, levels = c("shallow", "deep")))

# Switched the ordering of the lake depths. Indicated that shallow lakes have a positive relationship with N inputs. Deep lakes may also have a positive relationship, but not substantially different from shallow lakes.
micx21 <- run_micx(mod_vars = c("p_farm_inputs", "AG_ECO3", "lake_dep"), int = "p_farm_inputs * lake_dep")
micx21 <- run_micx(mod_vars = c("p_farm_inputs", "AG_ECO3", "MAXDEPTH"), int = "p_farm_inputs * MAXDEPTH")

# What about other inventory variables? N surplus is positively related. N total inputs was not related. P accumulated agricultural inputs does not fit better/with P farm inputs
# P farm inputs and ecoregion interact in the presence of N surplus
micx22 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus"))
micx22 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus", "P_Accumulated_ag_inputs"))
micx22 <- run_micx(mod_vars = c("N_Surplus", "P_Accumulated_ag_inputs"))
micx22 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus"), int = "p_farm_inputs * AG_ECO3")
micx22 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus"), int = "N_Surplus * AG_ECO3")

# Adding climate info, the monthly means. Temperature important, but not precip
micx21 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "precip_mean_month", "temp_mean_month", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")

# Trying the climate normals. Both temp and precip important
micx22 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "Precip8110Ws", "Tmean8110Ws", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")
micx22 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "Precip8110Ws", "Tmean8110Ws", "AG_ECO3"))

# Add the lake depth. Is the continuous or categorical lake depth a better predictor? Both very important.
micx23 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "Precip8110Ws", "Tmean8110Ws", "AG_ECO3", "MAXDEPTH"), int = "p_farm_inputs * AG_ECO3")

micx24 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "Precip8110Ws", "Tmean8110Ws", "AG_ECO3", "lake_dep"), int = "p_farm_inputs * AG_ECO3")

# Add other variables
# Baseflow index is related
micx25 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "Precip8110Ws", "Tmean8110Ws", "AG_ECO3", "lake_dep", "BFIWs"), int = "p_farm_inputs * AG_ECO3")

# Lake fetch is related
micx26 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "Precip8110Ws", "Tmean8110Ws", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")

# Soil erosion not important. Total or agricultural specific.
micx27 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "Precip8110Ws", "Tmean8110Ws", "lake_dep", "lakemorpho_fetch", "BFIWs", "AgKffactWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")

# Try other land cover types. Developed area important, forested area probably important, but not significantly so.
micx28 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "dev_ws", "fst_ws", "Precip8110Ws", "Tmean8110Ws", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")

# N developed inputs are related. P developed input also may be important. Likely variables are highly collinear.
micx29 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "n_dev_inputs", "Precip8110Ws", "Tmean8110Ws", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")
micx30 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "n_dev_inputs", "p_dev_inputs", "Precip8110Ws", "Tmean8110Ws", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")
micx31 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "p_dev_inputs", "Precip8110Ws", "Tmean8110Ws", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")

# Add in forested land cover. Removed temperature. Added precip minus ET (integrated measure of both precipitation and temperature) which seems to be more related.
micx32 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "n_dev_inputs", "fst_ws", "Precip8110Ws", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")
micx33 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "n_dev_inputs", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")
micx34 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "n_dev_inputs", "fst_ws", "Precip_Minus_EVTWs", "RunoffWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")

# Remove N farm inputs
micx34 <- run_micx(mod_vars = c("p_farm_inputs", "n_dev_inputs", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")

micx35 <- run_micx(mod_vars = c("p_farm_inputs", "n_dev_inputs", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * lake_dep + n_dev_inputs * AG_ECO3")

micx35 <- run_micx(mod_vars = c("p_farm_inputs", "n_dev_inputs", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * lake_dep + n_dev_inputs * AG_ECO3")

# Getting close, but need to play around with the final set of interactions
micx36 <- run_micx(mod_vars = c("p_farm_inputs", "n_farm_inputs", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")

micx37 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")

# N surplus is related
micx37 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")

# Does N surplus interact? Interaction between N_surplus and lake depth has a negative relationship with shallow lakes and a positive relationship with deep lakes. Does that make sense? This model has slightly lower AIC than a model that does not have an interaction between N_suplus and lake depth.
micx38 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3 + N_Surplus * lake_dep")

# Running with random effect of lake unique ID
micx40 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3 + N_Surplus * lake_dep")

# The interaction exists for the categorical lake depth, but not the continuous variable
micx39 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus", "fst_ws", "Precip_Minus_EVTWs", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3 + N_Surplus * MAXDEPTH")

# Best fit so far?
micx38 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3 + N_Surplus * lake_dep")

# Remove an interaction
micx39 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")
micx40 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "N_Surplus * lake_dep")

# Remove all interactions
micx41 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = NULL)

# Remove the ecoregions
micx42 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs"), int = NULL)

# Try continuous depth, this fits better
micx43 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus", "fst_ws", "Precip_Minus_EVTWs", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = NULL)

# Try climate normals for temp and precip rather than precip-EVT
micx44 <- run_micx(mod_vars = c("p_farm_inputs", "N_Surplus", "fst_ws", "Tmean8110Ws", "Precip8110Ws", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = NULL)

# What about other N input types?
micx45 <- run_micx(mod_vars = c("p_farm_inputs", "n_dev_inputs", "fst_ws", "Precip_Minus_EVTWs", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = NULL)
micx46 <- run_micx(mod_vars = c("p_farm_inputs", "N_Total_Deposition", "fst_ws", "Precip_Minus_EVTWs", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = NULL)
micx47 <- run_micx(mod_vars = c("p_farm_inputs", "fst_ws", "Precip_Minus_EVTWs", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = NULL)
micx48 <- run_micx(mod_vars = c("p_farm_inputs", "p_dev_inputs", "fst_ws", "Precip_Minus_EVTWs", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = NULL)

# Add an interaction back in
micx49 <- run_micx(mod_vars = c("p_farm_inputs", "fst_ws", "Precip_Minus_EVTWs", "MAXDEPTH", "lakemorpho_fetch", "BFIWs", "AG_ECO3"), int = "p_farm_inputs * AG_ECO3")

glances(micx38, micx39, micx40, micx41, micx42)

# mixc47 maybe most reasonable fit
summary(micx47)
beepr::beep()

aug_micx <- augment(micx47)
pROC::auc(aug_micx$MICX_DET, aug_micx$.fitted)

micx_loocv <- loocv(micx11, cv_predict = T)

# Save the best performing micx model so far
# saveRDS(micx47, "./inst/model_objects/model_micx_nolakedata.rds")

# Boxplot of estimated probability
vis_fit(dep_var, micx47, file_name = "Model Fit_Micx_Det.jpg")

# Maps for ASLO presentation
ggplot() + 
  geom_sf(data = conus, fill = "#e2e2e2", color = "white", size = 0.5) +
  geom_sf(data = aug_micx, aes(fill = .fitted), pch = 21) +
  scale_fill_gradientn(colors = RColorBrewer::brewer.pal(9, 'YlOrRd'),
                       name = "Estimated \nProbability", 
                       breaks = c(0.25,0.5,0.75,1)) +
  theme_void() +
  ggtitle("Fitted Probability of Microcystin Detection")+
  theme(plot.title = element_text(hjust = 0.5, vjust = 1, size = 12))
ggsave("./figures/FittedProbMap_Micx.png", width = 6, height = 3.5, units = "in", dpi = 600)

ggplot() + 
  geom_sf(data = conus, fill = "#e2e2e2", color = "white", size = 0.5) +
  geom_sf(data = arrange(aug_micx, MICX_DET), aes(fill = MICX_DET), pch = 21) +
  scale_fill_manual(values = c('#ffeda0','#bd0026'), #'#fee0b6','#d8daeb','#b2abd2','#8073ac'
                       name = "Microcystin \nDetected", 
                       breaks = levels(aug_micx$MICX_DET),
                    labels = c("Below Detection", "Detected")) +
  theme_void() +
  ggtitle("Observed Microcystin Detection")+
  theme(plot.title = element_text(hjust = 0.5, vjust = 1, size = 12))
ggsave("./figures/ObservedMap_Micx.png", width = 6, height = 3.5, units = "in", dpi = 600)

```


Models for microcystin concentration, when present


```{r}
dep_var  <- "MICX"

run_micxlm <- function(mod_vars, int = NULL){
  splm(create_formula(dep_var, mod_vars, log = T, interact = int),
                data = drop_na(habs, all_of(dep_var), all_of(mod_vars)),
                spcov_type = "exponential",
                random = ~ DSGN_CYCLE + UNIQUE_ID,
                local = F)
}

# Lessons learned
# Similarly to cyanobacteria cell counts, TP only becomes important when TN is removed as a covariate, signaling that these are colinear. But interesting that turbidity is important with this model in addition to TN. Would have expected these variables to be colinear so as not to overlay with each other.

# E/I has a better relationship to microcystin than d-excess.

# The addition of detected and concentration of nitrate improves the model pseudo R2, but only concentration appears to be important. Also the AIC is lower with inclusion of these variables. The addition of ammonia doesn't improve the model. Similar result with TP. TP was also negatively, which is counterintuitive. When nitrate isn't in the model and TP replaces TN, TP has a positive relationship. 

micxlm1 <- run_micxlm(mod_vars = c("NTL","PTL", "DOC", "PH", "wet_ws", "agr_ws", "precip_mean_month", "TEMPERATURE", "BFIWs", "RunoffWs", "EVAP_INFL", "MAXDEPTH", "lakemorpho_shoreline.length", "AG_ECO3"))

micxlm2 <- run_micxlm(mod_vars = c("NTL","PTL", "DOC", "PH", "wet_ws", "agr_ws", "precip_mean_month", "TEMPERATURE", "BFIWs", "RunoffWs", "EVAP_INFL", "MAXDEPTH", "lakemorpho_shoreline.length", "AG_ECO3"), int = "NTL*AG_ECO3")

micxlm3 <- run_micxlm(mod_vars = c("NTL","PTL", "DOC", "PH", "wet_ws", "agr_ws", "precip_mean_month", "TEMPERATURE", "BFIWs", "RunoffWs", "EVAP_INFL", "MAXDEPTH", "lakemorpho_shoreline.length", "AG_ECO3"), int = "PTL*AG_ECO3")

micxlm4 <- run_micxlm(mod_vars = c("NTL", "DOC", "PH", "wet_ws", "agr_ws", "precip_mean_month", "TEMPERATURE", "BFIWs", "RunoffWs", "EVAP_INFL", "MAXDEPTH", "lakemorpho_shoreline.length", "AG_ECO3"))

micxlm5 <- run_micxlm(mod_vars = c("PTL", "DOC", "PH", "wet_ws", "agr_ws", "precip_mean_month", "TEMPERATURE", "BFIWs", "RunoffWs", "EVAP_INFL", "MAXDEPTH", "lakemorpho_shoreline.length", "AG_ECO3"))

micxlm6 <- run_micxlm(mod_vars = c("NTL", "DOC", "PH", "agr_ws", "precip_mean_month", "TEMPERATURE", "BFIWs", "RunoffWs", "EVAP_INFL", "MAXDEPTH", "lakemorpho_shoreline.length", "AG_ECO3"))

micxlm7 <- run_micxlm(mod_vars = c("NTL", "DOC", "PH", "agr_ws", "precip_mean_month", "TEMPERATURE", "BFIWs", "EVAP_INFL", "MAXDEPTH", "lakemorpho_shoreline.length"))

micxlm8 <- run_micxlm(mod_vars = c("NTL", "DOC", "PH", "agr_ws", "precip_mean_month", "TEMPERATURE", "BFIWs", "EVAP_INFL", "MAXDEPTH"))

micxlm9 <- run_micxlm(mod_vars = c("NTL", "DOC", "PH", "agr_ws", "precip_mean_month", "Tmean8110Ws", "BFIWs", "EVAP_INFL", "MAXDEPTH"))

micxlm10 <- run_micxlm(mod_vars = c("NTL", "DOC", "PH", "agr_ws", "precip_mean_month", "Tmean8110Ws", "BFIWs", "EVAP_INFL", "lakemorpho_fetch"))

micxlm11 <- run_micxlm(mod_vars = c("NTL", "DOC", "PH", "agr_ws", "precip_mean_month", "Tmean8110Ws", "EVAP_INFL"))

# Best fit model with TN onlu
micxlm12 <- run_micxlm(mod_vars = c("NTL", "DOC", "PH", "TURB", "agr_ws", "precip_mean_month", "Tmean8110Ws", "EVAP_INFL"))

# Other experiments
micxlm13 <- run_micxlm(mod_vars = c("NTL", "DOC", "PH", "TURB", "agr_ws", "precip_mean_month", "Tmean8110Ws", "D_EXCESS"))

# Best fit model with TN + nitrate
micxlm14 <- run_micxlm(mod_vars = c("NTL", "NITRATE_DET", "NITRATE_N", "DOC", "PH", "TURB", "agr_ws", "precip_mean_month", "Tmean8110Ws", "EVAP_INFL"))

micxlm15 <- run_micxlm(mod_vars = c("NTL", "NITRATE_DET", "NITRATE_N", "AMMONIA_N", "DOC", "PH", "TURB", "agr_ws", "precip_mean_month", "Tmean8110Ws", "EVAP_INFL"))

micxlm16 <- run_micxlm(mod_vars = c("NTL", "NITRATE_DET", "NITRATE_N", "PTL", "DOC", "PH", "TURB", "agr_ws", "precip_mean_month", "Tmean8110Ws", "EVAP_INFL"))

micxlm17 <- run_micxlm(mod_vars = c("PTL", "NITRATE_DET", "NITRATE_N", "DOC", "PH", "TURB", "agr_ws", "precip_mean_month", "Tmean8110Ws", "EVAP_INFL"))

micxlm18 <- run_micxlm(mod_vars = c("NTL", "NITRATE_DET", "NITRATE_N", "DOC", "PH", "TURB", "agr_ws", "precip_mean_month", "Tmean8110Ws", "D_EXCESS"))

# Run with local = F
# micxlm_local_f <- run_micxlm(mod_vars = c("NTL", "DOC", "PH", "TURB", "agr_ws", "precip_mean_month", "Tmean8110Ws", "EVAP_INFL"))

summary(micxlm14)
varcomp(micxlm18)

# vis_fit(dep_var, micxlm_local_f, file_name = "Model Fit_Micx_Conc.jpg")

mod_vars = c("NTL", "NITRATE_DET", "NITRATE_N", "DOC", "PH", "TURB", "agr_ws", "precip_mean_month", "Tmean8110Ws", "EVAP_INFL")

micx_pred <- filter(drop_na(habs, all_of(dep_var), all_of(mod_vars)))

micx_loocv <- loocv(micxlm14, cv_predict = TRUE)

micx_pred$preds <- micx_loocv$cv_predict

max_val <- max(log10(micx_pred$MICX +1), micx_pred$preds)
min_val <- min(log10(micx_pred$MICX +1), micx_pred$preds)
name <- "Log10(Microcystin)"

fig <- ggplot(data = micx_pred, aes(x = preds, y = log10(MICX))) +
  geom_point(color = "blue", alpha=0.3) +
  xlim(min_val, max_val) + ylim(min_val, max_val) +
  ylab("Observed") +
  xlab("Fitted") +
  ggtitle(name)
ggsave(paste0("./figures/", "Model Fit_Micx Conc.jpg"), height = 4, width = 5, dpi = 400, units = "in")

```



Random forest experimenting

```{r}
# A good tutorial introducing random forest https://uc-r.github.io/random_forests

# Create a binary for microcystin detections
# habs <- mutate(habs, MICX_DET = factor(ifelse(is.finite(MICX), 1, 0)))

# Dependent variable 
dep_var <- "MICX_DET"

# Which set of independent variables will be considered? All available or only those available across CONUS (removing ancillary NLA water phys/chem data)?
ind_vars <- non_nla_vars

# How much missingness is there in the data?
missing_data <- habs |>
  st_drop_geometry() |>
  summarize_all(~sum(is.na(.))) |>
  pivot_longer(SITE_ID:MICX_DET, names_to = "variable", values_to = "num_missing")

# Examine if the error stabilizes with the number of trees
m1 <- randomForest::randomForest(
  formula = create_formula(dep_var, ind_vars),
  data = drop_na(habs, all_of(dep_var), all_of(ind_vars)),
  ntree = 1000
)
plot(m1)

# Tune the mTry parameter
na_free <- drop_na(habs, all_of(dep_var), all_of(ind_vars))

m2 <- randomForest::tuneRF(
  x          = st_drop_geometry(na_free[ind_vars]),
  y          = na_free$B_G_DENS,
  ntreeTry   = 1000,
  mtryStart  = 2,
  stepFactor = 1.5,
  improve    = 0.01,
  trace      = FALSE      # to not show real-time progress 
)

# hyperparameter grid search
hyper_grid <- expand.grid(
  mtry       = seq(10, 30, by = 2),
  node_size  = seq(5, 50, by = 5),
  sampe_size = c(.55, .632, .70, .80),
  OOB_RMSE   = 0
)

for(i in 1:nrow(hyper_grid)) {
  
  # train model
  model <- ranger::ranger(
    formula         = create_formula(dep_var, ind_vars, log = T, const = 1000),
    data            = st_drop_geometry(drop_na(habs, all_of(dep_var), all_of(ind_vars))), 
    num.trees       = 1000,
    mtry            = hyper_grid$mtry[i],
    min.node.size   = hyper_grid$node_size[i],
    sample.fraction = hyper_grid$sampe_size[i],
    seed            = 123
  )
  
  # add OOB error to grid
  hyper_grid$OOB_RMSE[i] <- sqrt(model$prediction.error)
}

# Which set of parameters yields the lowest OOB RMSE?
hyper_grid %>% 
  dplyr::arrange(OOB_RMSE) %>%
  head(10)

# Check expected error for optimal set of hyperparameters
OOB_RMSE <- vector(mode = "numeric", length = 200)

for(i in seq_along(OOB_RMSE)) {

  optimal_ranger <- ranger::ranger(
    formula         = create_formula(dep_var, ind_vars, log = T, const = 1000),
    data            = st_drop_geometry(drop_na(habs, all_of(dep_var), all_of(ind_vars))), 
    num.trees       = 1000,
    mtry            = 28,
    min.node.size   = 50,
    sample.fraction = .8,
    importance      = 'impurity'
  )
  
  OOB_RMSE[i] <- sqrt(optimal_ranger$prediction.error)
}

hist(OOB_RMSE, breaks = 20)

imp <- tibble(var = names(optimal_ranger$variable.importance), var_imp = optimal_ranger$variable.importance)

imp %>% 
  dplyr::arrange(desc(var_imp)) %>%
  ggplot(aes(x = reorder(var, var_imp), y = var_imp)) +
  geom_col() +
  coord_flip() +
  xlab("Variable") + ylab("Variable Importance") +
  ggtitle("Variables available for CONUS (non-NLA)")

# ggsave("./figures/Variable importance_NLA'07,'12,'17_non-NLA vars.png", dpi = 300, width = 5, height = 5)


# Given the parameter tuning, now pass the data to spmodel
modRF <- splmRF(create_formula(dep_var, ind_vars),
                data = drop_na(habs, all_of(dep_var), all_of(ind_vars)),
                spcov_type = "exponential",
                family = "binomial",
                random = ~ DSGN_CYCLE,
                local = TRUE,
                num.trees       = 1000,
                mtry            = 28,
                min.node.size   = 50,
                sample.fraction = .8,
                importance = "impurity")

modRF.imp <- tibble(var = names(modRF$ranger$variable.importance), var_imp = modRF$ranger$variable.importance)

modRF.imp %>% 
  dplyr::arrange(desc(var_imp)) %>%
  dplyr::top_n(25) %>%
  ggplot(aes(x = reorder(var, var_imp), y = var_imp)) +
  geom_col() +
  coord_flip() +
  xlab("Variable") + ylab("Variable Importance")

# ggsave("./figures/Variable importance_spMod_NLA'07,'12,'17_all.png", dpi = 300, width = 5, height = 5)

obs <- habs |>
  drop_na(all_of(dep_var), all_of(ind_vars)) |>
  st_drop_geometry() |>
  mutate(obs = log10(B_G_DENS + 1000)) |>
  pull(obs)

plot(optimal_ranger$predictions, obs)
cor.test(optimal_ranger$predictions, obs)

mod <- modRF$ranger$predictions

plot(obs, mod, ylim = c(3, max(mod, obs)), xlim = c(3, max(mod, obs)))
cor.test(mod, obs)

  
```

Experiment for the lake random effect

```{r}
# Find 50 random observations to hold out
# Make sure that site that have revisit data isn't included. Want the 50 observations to be unobserved locations in the training set.
# Since there is a lot of missing data, should pre-filter the dataset to observations that will be included for both

# Variables used in the most recent models for cyanos and microcystin detection
vars <- unique(c("BFIWs", "Tmean8110Ws", "Precip8110Ws", "n_farm_inputs", "n_dev_inputs", "p_farm_inputs", "lake_dep", "lakemorpho_fetch", "AG_ECO3", "p_farm_inputs", "N_Surplus", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3"))

single_obs <- habs |>
  st_drop_geometry() |>
  drop_na(all_of(c("B_G_DENS", "MICX_DET")), all_of(vars)) |>
  group_by(UNIQUE_ID) |>
  summarise(obs_count = n()) |>
  filter(obs_count == 1) |>
  pull(UNIQUE_ID)

# The above df is organized by UNIQUE ID which is categorized by state. Taking an observation at regular intervals should give good spatial coverage of the US
length(single_obs)/50

hold_out <- sapply(1:50, function(x){single_obs[21*x]})

# Divide data into training and test sets
test  <- filter(habs, UNIQUE_ID %in% hold_out)
train <- filter(habs, !(UNIQUE_ID %in% hold_out))

# Run the models with and without a random effect for lake

# Cyanobacteria
mod_vars <- c("BFIWs", "Tmean8110Ws", "Precip8110Ws", "n_farm_inputs", "n_dev_inputs", "p_farm_inputs", "lake_dep", "lakemorpho_fetch", "AG_ECO3")

cyano_lakere <- splm(create_formula("B_G_DENS", mod_vars, log = T, const = 1000, 
                             interact = "n_farm_inputs * AG_ECO3"),
              data = filter(drop_na(train, all_of("B_G_DENS"), all_of(mod_vars))),
              spcov_type = "exponential",
              random = ~ DSGN_CYCLE + UNIQUE_ID,
              local = T)

cyano_re_nonsp <- splm(create_formula("B_G_DENS", mod_vars, log = T, const = 1000, 
                             interact = "n_farm_inputs * AG_ECO3"),
              data = filter(drop_na(train, all_of("B_G_DENS"), all_of(mod_vars))),
              spcov_type = "none",
              random = ~ DSGN_CYCLE + UNIQUE_ID,
              local = T)

cyano_nolakere <- splm(create_formula("B_G_DENS", mod_vars, log = T, const = 1000, 
                             interact = "n_farm_inputs * AG_ECO3"),
              data = filter(drop_na(train, all_of("B_G_DENS"), all_of(mod_vars))),
              spcov_type = "exponential",
              random = ~ DSGN_CYCLE,
              local = T)

cyano_nore <- splm(create_formula("B_G_DENS", mod_vars, log = T, const = 1000, 
                             interact = "n_farm_inputs * AG_ECO3"),
              data = filter(drop_na(train, all_of("B_G_DENS"), all_of(mod_vars))),
              spcov_type = "exponential",
              # random = ~ DSGN_CYCLE,
              local = T)

cyano_nonsp <- splm(create_formula("B_G_DENS", mod_vars, log = T, const = 1000, 
                             interact = "n_farm_inputs * AG_ECO3"),
              data = filter(drop_na(train, all_of("B_G_DENS"), all_of(mod_vars))),
              spcov_type = "none",
              # random = ~ DSGN_CYCLE,
              local = T)

# Compare model fit
glances(cyano_lakere, cyano_nolakere)
lakere_loocv   <- loocv(cyano_lakere)
nolakere_loocv <- loocv(cyano_nolakere)

# Predict for the training set
test$cyano_relake_preds   <- predict(cyano_lakere, newdata = test)
test$cyano_re_nonsp_preds <- predict(cyano_re_nonsp, newdata = test)
test$cyano_norelake_preds <- predict(cyano_nolakere, newdata = test)
test$cyano_nore_preds     <- predict(cyano_nore, newdata = test)
test$cyano_nonsp_preds    <- predict(cyano_nonsp, newdata = test)

# Correlations
cor(test$cyano_relake_preds, log10(test$B_G_DENS + 1000))
cor(test$cyano_re_nonsp_preds, log10(test$B_G_DENS + 1000))
cor(test$cyano_norelake_preds, log10(test$B_G_DENS + 1000))
cor(test$cyano_nore_preds, log10(test$B_G_DENS + 1000))
cor(test$cyano_nonsp_preds, log10(test$B_G_DENS + 1000))


# Plot it out
ggplot(data = test) +
  geom_point(aes(x = cyano_relake_preds, y = log10(B_G_DENS + 1000)), color = "blue") +
  geom_point(aes(x = cyano_norelake_preds, y = log10(B_G_DENS + 1000)), color = "red")


# Detection of microcystin
mod_vars <- c("p_farm_inputs", "N_Surplus", "fst_ws", "Precip_Minus_EVTWs", "lake_dep", "lakemorpho_fetch", "BFIWs", "AG_ECO3")
int <- "p_farm_inputs * AG_ECO3 + N_Surplus * lake_dep"

micx_lakere <- spglm(create_formula(dep_var = "MICX_DET", ind_vars = mod_vars, interact = int),
                     family = "binomial",
                     data = drop_na(train, all_of(dep_var), all_of(mod_vars)),
                     spcov_type = "exponential",
                     random = ~ DSGN_CYCLE + UNIQUE_ID,
                     local = T)

micx_nonsp <- spglm(create_formula(dep_var = "MICX_DET", ind_vars = mod_vars, interact = int),
                     family = "binomial",
                     data = drop_na(train, all_of(dep_var), all_of(mod_vars)),
                     spcov_type = "none",
                     random = ~ DSGN_CYCLE + UNIQUE_ID,
                     local = T)

micx_nolakere <- spglm(create_formula(dep_var = "MICX_DET", ind_vars = mod_vars, interact = int),
                     family = "binomial",
                     data = drop_na(train, all_of(dep_var), all_of(mod_vars)),
                     spcov_type = "exponential",
                     random = ~ DSGN_CYCLE,
                     local = T)

micx_nore <- spglm(create_formula(dep_var = "MICX_DET", ind_vars = mod_vars, interact = int),
                     family = "binomial",
                     data = drop_na(train, all_of(dep_var), all_of(mod_vars)),
                     spcov_type = "exponential",
                     # random = ~ DSGN_CYCLE,
                     local = T)

micx_nore_nonsp <- spglm(create_formula(dep_var = "MICX_DET", ind_vars = mod_vars, interact = int),
                     family = "binomial",
                     data = drop_na(train, all_of(dep_var), all_of(mod_vars)),
                     spcov_type = "none",
                     # random = ~ DSGN_CYCLE,
                     local = T)

aug_lakere     <- augment(micx_lakere, newdata = test)
aug_nonsp      <- augment(micx_nonsp, newdata = test)
aug_nolakere   <- augment(micx_nolakere, newdata = test)
aug_nore       <- augment(micx_nore, newdata = test)
aug_nore_nonsp <- augment(micx_nore_nonsp, newdata = test)

pROC::auc(aug_lakere$MICX_DET, aug_lakere$.fitted)
pROC::auc(aug_nonsp$MICX_DET, aug_nonsp$.fitted)
pROC::auc(aug_nolakere$MICX_DET, aug_nolakere$.fitted)
pROC::auc(aug_nore$MICX_DET, aug_nore$.fitted)
pROC::auc(aug_nore_nonsp$MICX_DET, aug_nore_nonsp$.fitted)


pROC::auc(with(aug_nonsp, MICX_DET, .fitted))
pROC::auc(with(aug_nolakere, MICX_DET, .fitted))
pROC::auc(with(aug_nore, MICX_DET, .fitted))
pROC::auc(with(aug_nore_nonsp, MICX_DET, .fitted))


test$lakere <- predict(micx_lakere, newdata = test)
test$nonsp <- predict(micx_nonsp, newdata = test)
test$nolakere <- predict(micx_nolakere, newdata = test)
test$nolakere <- predict(micx_nolakere, newdata = test)


```



Try random forest with large collection of data from Robert Sabo


```{r}
# All data from Robert (untransformed)
nni <- readr::read_csv("NLA07-12_NutrientInventory_Data.csv")

# Have to break out the month and day of the compiled HABs data
comp <- habs |>
  mutate(Month = as.numeric(format(as.Date(DATE_COL, format = "%m/%d/%Y"), "%m")),
         Day = as.numeric(format(as.Date(DATE_COL, format = "%m/%d/%Y"), "%d")),
         Year = as.numeric(as.character(DSGN_CYCLE))) |>
  # select(SITE_ID, Year, Month, Day, B_G_DENS, TEMPERATURE, DOC, TURB, PH, EVAP_INFL, lakemorpho_depth, ElevWs, SlopeWs) 
  # Remove redundant variables
  select(-NTL, -PTL, -RunoffWs, -LAT_DD83, -LON_DD83, -DATE_COL, -DSGN_CYCLE, -VISIT_NO, -COMID, -MICX, -CHLA_RESULT, -CYLSPER, -UNIQUE_ID)

# Merge with cyanobacteria counts
comp <- left_join(nni, comp, by = c("SITE_ID", "Year", "Month", "Day"))

# Create a vector of the independent variables
nni_vars <- colnames(comp)[c(9:91,93:(length(colnames(comp))-1))] #

# Examine if the error stabilizes with the number of trees
m1 <- randomForest::randomForest(
  formula = create_formula(dep_var, nni_vars, log = T),
  data = drop_na(comp, all_of(dep_var), all_of(nni_vars))
)
plot(m1)

# Tune the mTry parameter
na_free <- drop_na(comp, all_of(dep_var), all_of(nni_vars))

m2 <- randomForest::tuneRF(
  x          = st_drop_geometry(na_free[nni_vars]),
  y          = log10(na_free$B_G_DENS + 1),
  ntreeTry   = 500,
  mtryStart  = 4,
  stepFactor = 1.5,
  improve    = 0.01,
  trace      = FALSE      # to not show real-time progress 
)

# hyperparameter grid search
hyper_grid <- expand.grid(
  mtry       = seq(25, 35, by = 2),
  node_size  = seq(3, 9, by = 2),
  sampe_size = c(.55, .632, .70, .80),
  OOB_RMSE   = 0
)

for(i in 1:nrow(hyper_grid)) {
  
  # train model
  model <- ranger::ranger(
    formula         = create_formula(dep_var, nni_vars, log = T),
    data            = st_drop_geometry(drop_na(comp, all_of(dep_var), all_of(nni_vars))), 
    num.trees       = 500,
    mtry            = hyper_grid$mtry[i],
    min.node.size   = hyper_grid$node_size[i],
    sample.fraction = hyper_grid$sampe_size[i],
    seed            = 123,
    num.threads     = 8
  )
  
  # add OOB error to grid
  hyper_grid$OOB_RMSE[i] <- sqrt(model$prediction.error)
}

# Which set of parameters yields the lowest OOB RMSE?
hyper_grid %>% 
  dplyr::arrange(OOB_RMSE) %>%
  head(15)

# Check expected error for optimal set of hyperparameters
OOB_RMSE <- vector(mode = "numeric", length = 100)

for(i in seq_along(OOB_RMSE)) {

  optimal_ranger <- ranger::ranger(
    formula         = create_formula(dep_var, nni_vars, log = T),
    data            = st_drop_geometry(drop_na(comp, all_of(dep_var), all_of(nni_vars))), 
    num.trees       = 500,
    mtry            = 29,
    min.node.size   = 3,
    sample.fraction = .8,
    num.threads     = 8, 
    importance      = 'impurity'
  )
  
  OOB_RMSE[i] <- sqrt(optimal_ranger$prediction.error)
}

hist(OOB_RMSE, breaks = 20)

optimal_ranger <- ranger::ranger(
  formula         = create_formula(dep_var, nni_vars, log = T),
  data            = drop_na(comp, all_of(dep_var), all_of(nni_vars)), 
  num.trees       = 500,
  mtry            = 29,
  min.node.size   = 3,
  sample.fraction = .8,
  num.threads     = 8, 
  importance      = 'impurity')

imp <- tibble(var = names(optimal_ranger$variable.importance), var_imp = optimal_ranger$variable.importance)

imp %>% 
  dplyr::arrange(desc(var_imp)) %>%
  dplyr::top_n(25) %>%
  ggplot(aes(x = reorder(var, var_imp), y = var_imp)) +
  geom_col() +
  coord_flip() +
  xlab("Variable") + ylab("Variable Importance") +
  ggtitle("NLA '07,'12_All Variables")

ggsave("./figures/Variable importance_NLA'07,'12_all.png", dpi = 300, width = 5, height = 5)

########################################################

# Have to break out the month and day of the compiled HABs data
comp <- habs |>
  mutate(Month = as.numeric(format(as.Date(DATE_COL, format = "%m/%d/%Y"), "%m")),
         Day = as.numeric(format(as.Date(DATE_COL, format = "%m/%d/%Y"), "%d")),
         Year = as.numeric(as.character(DSGN_CYCLE))) |>
  select(-NTL, -PTL, -RunoffWs) |>
  right_join(nni, by = c("SITE_ID", "Year", "Month", "Day")) # |>
  # filter(!duplicated(UNIQUE_ID)) # If running with unique observations

# Investigate how the year random effect interacts with some data that is specific to the sample year
nni_sub <- c(all_vars, "LSTAnomaly_YrMean", "NPP_YrMean", "Precip_YrMean", "Tmean_YrMean")

nni_no_re_no_sp <- splm(create_formula(dep_var, nni_sub, log = T),
                     data = drop_na(comp, all_of(dep_var), all_of(nni_sub)),
                     spcov_type = "none", 
                     local = TRUE)

nni_no_re <- splm(create_formula(dep_var, nni_sub, log = T),
                     data = drop_na(comp, all_of(dep_var), all_of(nni_sub)),
                     spcov_type = "exponential", 
                     local = TRUE)

nni_re_site <- splm(create_formula(dep_var, nni_sub, log = T),
                         data = drop_na(comp, all_of(dep_var), all_of(nni_sub)),
                         spcov_type = "exponential",
                         random = ~  UNIQUE_ID,
                         local = TRUE)

nni_re_year <- splm(create_formula(dep_var, nni_sub, log = T),
                         data = drop_na(comp, all_of(dep_var), all_of(nni_sub)),
                         spcov_type = "exponential",
                         random = ~  DSGN_CYCLE,
                         local = TRUE)

nni_unnest_re <- splm(create_formula(dep_var, nni_sub, log = T),
                       data = drop_na(comp, all_of(dep_var), all_of(nni_sub)),
                       spcov_type = "exponential",
                       random = ~ DSGN_CYCLE + UNIQUE_ID,
                       local = TRUE)

nni_nest_re <- splm(create_formula(dep_var, nni_sub, log = T),
                       data = drop_na(comp, all_of(dep_var), all_of(nni_sub)),
                       spcov_type = "exponential",
                       random = ~ (DSGN_CYCLE / UNIQUE_ID),
                       local = TRUE)

# Compare model with no spatial component, with spatial component, random effect for site alone, random effect for year along, random effect for site and year unnested, random effect for site nested within year.
# How does the AIC and R2 change with these model configurations
glances(nni_no_re_no_sp,
        nni_no_re,
        nni_re_site,
        nni_re_year,
        nni_unnest_re,
        nni_nest_re)
# Nested random effects had the lowest AIC and R2 followed by unnested random effects
# About the same amount of variation is explained with no random effects

optimal_ranger <- ranger::ranger(
  formula         = create_formula(dep_var, nni_sub, log = T),
  data            = drop_na(comp, all_of(dep_var), all_of(nni_sub)), 
  num.trees       = 500,
  mtry            = 8,
  min.node.size   = 3,
  sample.fraction = .8,
  num.threads     = 8, 
  importance      = 'impurity')

imp <- tibble(var = names(optimal_ranger$variable.importance), var_imp = optimal_ranger$variable.importance)

imp %>% 
  dplyr::arrange(desc(var_imp)) %>%
  dplyr::top_n(25) %>%
  ggplot(aes(x = reorder(var, var_imp), y = var_imp)) +
  geom_col() +
  coord_flip() +
  xlab("Variable") + ylab("Variable Importance") +
  ggtitle("NLA '07,'12_All Variables")

ggsave("./figures/Variable importance_NLA'07,'12_with annual.png", dpi = 300, width = 5, height = 5)


```



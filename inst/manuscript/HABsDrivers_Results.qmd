---
title: "CyanoHABs National Drivers and Predictions"
format: docx
authors: Amalia Handler, Michael Dumelle, and Melanie Reynolds
editor: visual
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
# Load model development data
devtools::load_all()

# Load packages
library(here)
library(spmodel)
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggpubr)
library(sf)
library(tigris)
library(knitr)
library(here)
library(corrplot)
library(flextable)
library(officer)
library(officedown)
library(stringr)
library(ggbeeswarm)

# Do not include code chunks in document
knitr::opts_chunk$set(echo = FALSE, message = FALSE)

# Load model objects
cyano_lake <- readRDS(paste0(here(), "/inst/model_objects/model_cyano_withlakedata.rds"))
micx_lake  <- readRDS(paste0(here(), "/inst/model_objects/model_micx_withlakedata.rds"))

cyano_nolake <- readRDS(paste0(here(), "/inst/model_objects/model_cyano_nolakedata.rds"))
micx_nolake  <- readRDS(paste0(here(), "/inst/model_objects/model_micx_nolakedata.rds"))

# p-value results for models with lake conditions
pval <- function(x){ifelse(x < 0.001, "p<0.001", paste0("p=",round(x, 3)))}

doc_cyano <- pval(summary(cyano_lake)$coefficients$fixed$p[5])
doc_micx  <- pval(summary(micx_lake)$coefficients$fixed$p[4])
int_cyano_plnlow <- pval(summary(cyano_lake)$coefficients$fixed$p[15])


```


```{r nla map compilation, message = FALSE}
# CONUS with state outlines
conus <- tigris::states(cb = TRUE, progress_bar = FALSE) |>
  filter(!STUSPS %in% c('HI', 'PR', 'AK', 'MP', 'GU', 'AS', 'VI')) |>
  st_transform(crs = 5072)

# Note that the 3 aggregated ecoregions shapefile has been simplified to a reduced number of vertices and is only intended for data visualization purposes at the national scale.
nla_map <- ggplot() + 
  geom_sf(data = conus, fill = "white", color = "black", size = 0.5) + # grey fill #e2e2e2
  geom_sf(data = eco_ag3_simpl, aes(fill = WSA_3_NM), color = "black", alpha = 0.25, size = 0.5) +
  scale_fill_discrete(name = "Aggregated Ecoregion") +
  geom_sf(data = habs, shape = 24, fill = "grey39", size = 1, stroke = .2) +
  theme_void()

```

```{r nla map}
#| label: nla-map
#| fig-width: 7
#| fig-height: 3.5
#| fig-cap: "Lakes sampled in the 2007, 2012, and 2017 National Lakes Assessment."
nla_map

```

## Results

```{r setup correlation plot}
#| label: cor-plot
#| fig-width: 6
#| fig-height: 6
#| fig-cap: "Pairwise spearman's rank correlation matrix of all covariates considered for the models. Blue represent positive correlations and red represent negative correlations. Darker colors and tighter ellipses represent larger correlation coefficients and stronger relationships."

# Trim to just the variables explored in the models
cor_dat <- habs |>
  st_drop_geometry() |>
  select(B_G_DENS, MICX, TEMPERATURE, MAXDEPTH, AMMONIA_N, DOC:NITRATE_N, PH, D_EXCESS, EVAP_INFL, fst_ws, wet_ws, precip_mean_month, temp_mean_month, lakemorpho_fetch, BFIWs, KffactWs:Precip_Minus_EVTWs, Precip8110Ws, Tmean8110Ws, N_Total_Deposition, P_Deposition, n_farm_inputs:p_dev_inputs, P_Accumulated_ag_inputs, P_Legacy_P) |>
  relocate(B_G_DENS, MICX, NTL, PTL, NITRATE_N, AMMONIA_N, DOC, PH, TEMPERATURE, TURB, D_EXCESS, EVAP_INFL, fst_ws, wet_ws, KffactWs, n_farm_inputs, p_farm_inputs, P_Accumulated_ag_inputs, P_Legacy_P, n_dev_inputs, p_dev_inputs, N_Total_Deposition, P_Deposition, precip_mean_month, temp_mean_month, Precip8110Ws, Tmean8110Ws, Precip_Minus_EVTWs, RunoffWs, BFIWs, MAXDEPTH, lakemorpho_fetch)

var_names <- c("Cyanobacteria", 
               "Microcystin", 
               "Total N", 
               "Total P",   
               "Nitrate", 
               "Ammonia", 
               "DOC", 
               "pH", 
               "Water Temp",
               "Turbidity",
               "Evaporation",
               "Evaporation/Inflow",
               "Forest Cover", 
               "Wetland Cover",
               "Soil Erodability",
               "Farm N Inputs",
               "Farm P Inputs",
               "Developed N Inputs", 
               "Developed P Inputs",
               "Accumulated P Inputs",
               "Legacy P Inputs",
               "Deposition N",
               "Deposition P",
               "Monthly Precip",
               "Monthly Air Temp",
               "Annual Precip", 
               "Annual Air Temp",
               "Annual Precip-ET",
               "Runoff", 
               "Baseflow Index",
               "Lake Depth",
               "Lake Fetch")

cormat_pred <- cor(cor_dat, use = "pairwise.complete.obs", method = "spearman")

colnames(cormat_pred) <- var_names
rownames(cormat_pred) <- var_names

# Lower triangle plot
corrplot(cormat_pred, method = "ellipse", type = "lower", tl.col = "black", tl.srt = 45, tl.cex = 0.75)

# How many pairwise comparisons are strongly correlated?
rhos <- as.vector(cormat_pred)

pos_str_rhos <- length(unique(rhos[rhos > 0.5 & rhos < 1]))
neg_str_rhos <- length(unique(rhos[rhos < -0.5 & rhos > -1]))

```

### Drivers of CyanoHABs

Both the cyanobacteria and microcystin models were driven by a similar set of covariates with some differences in the relative importance of individual covariates within each model. Note that many of the potential covariates tested for the models were highly colinear (@cor-plot). There were `r pos_str_rhos` positive pairwise comparisons that had rho \> 0.5 and `r neg_str_rhos` negative pairwise comparisons that had rho \< -0.5.

#### Model Fixed Effects

Nutrient conditions were included in both models with and without in-lake conditions (@tbl-fixed_effects). In the case of models that included in-lake conditions, total N was positively related to cyanobacteria abundance and probability of microcystin detection. The microcystin model with in-lake conditions also included watershed farm P input. Dissolved nutrients including nitrate and and DOC were negatively associated with cyanobacteria and microcystin and ammonium was also negatively associated with cyanobacteria but not included in the final microcystin model. For the models that excluded in-lake conditions, the watershed nutrient inputs became more important with both farm and developed land cover N and P inputs having a positive relationship with cyanobacteria abundance and probability of microcystin detection. Only the microcystin model without in-lake conditions had a negative association with forested land cover.

Regardless of the presence of in-lake conditions, across models shallower lakes and lakes with longer fetch were associated with higher cyanobacteria abundance and probability of microcystin detection. Similarly, watersheds with lower mean annual precipitation and higher mean annual temperature were associated with higher cyanobacteria abundance and probability of microcystin detection.

The models with in-lake conditions present had a positive relationship with the evaporation to inflow ratio. In other words, lakes with higher evaporation rates relative to inflowing water were higher in cyanobacteria abundance and probability of microcystin detection. The baseflow index was not included in the models with in-lake conditions, but higher baseflow influence was associated with lower cyanobacteria and microcystin in the models without in-lake conditions.

In most models, the amount of cyanobacteria and probability of microcystin detection was higher in the central plains and coastal lowlands as well as the upper midwest and eastern highlands compared to the western mountains and xeric ecoregion. In addition, the cyanobacteria model with in-lake conditions had an interaction term between lake total N concentration and the ecoregion. In this instance, higher total N concentration in the EHIGH ecoregion is correlated with significantly higher cyanobacteria abundance relative to the WMTNS. There was also a small negative interaction between the total N concentration and the EHIGH, but not significant (`r int_cyano_plnlow`).

#### Spatial Influence and Model Fit

Standardized residuals were randomly distributed across the country for both models that included and excluded in-lake conditions (@std-resid-maps). For the models of cyanobacteria abundance, spatial models outperformed independent error models with lower bias, lower RMSPE, and higher predicted R^2^ regardless of the presence of in-lake conditions (@tbl-mod-fit). For the probability of microcystin detection, model performance was similar for spatial and independent error models with respect to bias and AUC. Bias was slightly lower for the spatial compared to the independent error models for microcystin when in-lake conditions were present or absent.

The was influence of spatial autocorrelation in both the cyanobacteria and microcystin models without in-lake conditions (@spcov-maps). In the cyanobacteria model, the spatial autocorrelation was positive and high in the portions of the northern central plains, Midwestern states, and mid-Atlantic regions of the country. In contrast, spatial autocorrelation was strongly negative in the Northeastern part of the country. For reference on the influence of this term on model fitted values, as an example, a positive spatially dependent error term of 0.8 for a lake can increase a fitted cyanobacteria abundance of \~10,000 mL based on fixed effects alone to \~100,000 cells/mL with the spatial error term. In contrast, a negative spatially dependent error term of -0.4 can result in a fitted cyanobacteria abundance of \~10,000 cells/mL based on fixed effects alone to \~100 cells/mL with the spatial error term. Similar to the cyanobacteria model, the microcystin had high positive spatial autocorrelation in the Midwestern and central northern plains regions with pockets in Utah, Arizona, Texas, and Florida. For example, a positive spatially dependent error term of 2 can increase the fitted probability of microcystin detection of 30-50% based on fixed effects alone to 80-90%. In contrast, spatial autocorrelation was high and negative in the Northeastern part of the country. As an example, a negative spatially dependent error term of -1.5 can decrease the fitted probability of microcystin detection from 15-30% based on fixed effects alone to 1-10%.

```{r extract model fixed effects}
# Function to extract the fixed effects from each model
fixed_effect_retriever <- function(model_obj, resp_var, lake_data){
  summary(model_obj)$coefficients$fixed |>
    mutate(fixed_effect = rownames(summary(model_obj)$coefficients$fixed)) |>
    mutate(response_var = resp_var,
           lake_data = lake_data) |>
    tibble() |>
    rename(estimate = estimates) |>
    relocate(response_var, lake_data, fixed_effect, .before = estimate)
}

# Extract the effects
fixed_df <- rbind(
  fixed_effect_retriever(micx_lake, resp_var = "micx", lake_data = "present"),
  fixed_effect_retriever(micx_nolake, resp_var = "micx", lake_data = "absent"),
  fixed_effect_retriever(cyano_lake, resp_var = "cyano", lake_data = "present"),
  fixed_effect_retriever(cyano_nolake, resp_var = "cyano", lake_data = "absent")
)

# Table that includes both response variables and models with and without lake data. Covariates are converted to positive or negative signs with asterisks denoting the associated p-values.
pal <- c("#eb6a7a", "#f08f9b", "#f5b4bc", "#fadade", "#F7F7F7", "#dceaf8", "#b8d5f1", "#95c0eb", "#72abe4")

est_and_sign <- fixed_df |>
  filter(!fixed_effect == "(Intercept)") |>
  mutate(est_sign = ifelse(estimate > 0, "+", "−"),
         sig = case_when(p >= 0.05 ~ "ns",
                         p < 0.05 & p >= 0.01 ~ "*",
                         p < 0.01 & p >= 0.001 ~ "**",
                         p < 0.001 ~ "***"),
         est_sig = paste0(est_sign, " (", sig, ")"),
         fixed_effect = factor(fixed_effect, 
                               levels = c("NTL",
                                          "NITRATE_N",
                                          "AMMONIA_N",
                                          "DOC",
                                          "TURB",
                                          "PH",
                                          "EVAP_INFL",
                                          "n_farm_inputs",
                                          "p_farm_inputs",
                                          "n_dev_inputs",
                                          "p_dev_inputs",
                                          "fst_ws",
                                          "MAXDEPTH",
                                          "lakemorpho_fetch",
                                          "BFIWs",
                                          "Precip8110Ws",
                                          "Tmean8110Ws",
                                          "AG_ECO3PLNLOW",
                                          "AG_ECO3EHIGH",
                                          "NTL:AG_ECO3PLNLOW",
                                          "NTL:AG_ECO3EHIGH"))
         ) |>
  select(response_var:fixed_effect, est_sig) |>
  pivot_wider(names_from = response_var:lake_data,
              values_from = est_sig,
              values_fill = "") |>
  arrange(fixed_effect) |>
  relocate(fixed_effect, cyano_present, micx_present, cyano_absent, micx_absent) |>
  mutate(fixed_effect = c("Total N",
                       "Nitrate",
                       "Ammonium",
                       "DOC",
                       "Turbidity",
                       "pH",
                       "Evaporation/Inflow",
                       "Farm N Inputs",
                       "Farm P Inputs",
                       "Developed N Inputs",
                       "Developed P Inputs",
                       "Forest Cover",
                       "Lake Depth",
                       "Lake Fetch",
                       "Baseflow Index",
                       "Annual Precip",
                       "Annual Air Temp",
                       "Ecoregion PLNLOW",
                       "Ecoregion EHIGH",
                       "Total N * PLNLOW",
                       "Total N * EHIGH"),
         Type = c(rep("In-Lake Conditions", 7),
                  rep("Nutrient Inputs", 5),
                  rep("Lake Geometry", 2),
                  rep("Geographic Setting", 5),
                  rep("Interactions", 2)), .before = fixed_effect
            ) |>
  rename(Covariates = fixed_effect)

colorer <- function(i){
  hex <- case_when(i == "+ (***)" ~ pal[1],
                   i == "+ (**)" ~  pal[2],
                   i == "+ (*)" ~   pal[3],
                   i == "+ (ns)" ~  pal[4],
                   i == "" ~        pal[5],
                   i == "− (ns)" ~  pal[6],
                   i == "− (*)" ~   pal[7],
                   i == "− (**)" ~  pal[8],
                   i == "− (***)" ~ pal[9])
}

est_header <- data.frame(
  col_keys = colnames(est_and_sign),
  line2 = c(rep("Model", 2), rep("In-Lake Conditions", 4)),
  line3 = c(rep("Model", 2), c(rep("Present", 2), rep("Absent", 2))),
  line4 = c("Type", "Covariates", rep(c("Cyano", "Micx"), 2))
)

covar_tbl <- est_and_sign |>
  flextable() |>
  set_header_df(mapping = est_header, key = "col_keys" ) |>
  merge_v(part = "header", j = c(1:2)) |> 
  merge_v(part = "body", j = 1) |> 
  merge_h(part = "header", i = c(1:2)) |> 
  theme_booktabs(bold_header = TRUE) |>
  bg(bg = colorer,
     j = 3:6, # All columns in the body except for the first one
     part = "body") |>
  bg(j = c(5:6), i = c(1:7), bg = "#606060") |> # Covariates that weren't available to the models
  theme_box() |>
  align(align = "center", part = "header") |>
  fontsize(size = 10, part = "body") |>
  fontsize(size = 10, part = "header")

```

Table 1. Model fixed effect coefficient sign (negative or positive) and p-value (ns \>0.05, \* \<0.05, \*\* \<0.01, \*\*\*\* \< 0.001) for cyanobacteria (Cyano) and microcystin (Micx) models both where in-lake data was present or absent. Grey cells are covariates that were excluded from model development. Empty cells covariates that were not included in the model. Brighter colors denote a lower p-value for either positive (pink) or negative (blue) relationships.
```{r covariate table}
#| label: tbl-fixed_effects
covar_tbl
```

### Influence of In-Lake Conditions

The presence of in-lake conditions in the cyanobacteria abundance model provides a substantial increase in the predictive R^2^ of the model overall fit (@tbl-mod-fit); however, the bias and RMSPE were similar regardless of the presence of in-lake conditions. The performance of the probability of microcystin detection models were similar with respect to bias, RMSPE, and AUC regardless of the presence of in-lake conditions.

Table 2. Comparison of model fit where in-lake conditions are present or absent and the error structure (spatial or independent).
```{r model fit comparison}
#| label: tbl-mod-fit

comp_cyan <- readRDS(paste0(here(), "/inst/model_objects/spatial_compare_cyano.rds")) |>
  rename(fit = cor2)

comp_micx <- readRDS(paste0(here(), "/inst/model_objects/spatial_compare_micx.rds")) |>
  rename(fit = auc)

options(digits = 2)
rbind(comp_cyan, comp_micx) |>
  select(-MSPE) |>
  mutate(resp_var = case_when(resp_var == "cyano" ~ "Cyanobacteria",
                              resp_var == "micx" ~ "Microcystin"),
         lake_data = case_when(lake_data == "present" ~ "Present",
                               lake_data == "absent" ~ "Absent"),
         spatial_mod = case_when(spatial_mod == "spatial" ~ "Spatial",
                                 spatial_mod == "non-spatial" ~ "Independent")) |>
  flextable() |>
  set_header_labels(values = list(
    resp_var = "Response Variable",
    lake_data = "In-Lake Conditions",
    spatial_mod = "Error Structure",
    bias = "Bias",
    RMSPE = "RMSPE",
    fit = "Fit")) |>
  merge_v(part = "body", j = c(1:2)) |> 
  footnote(i = 1, j = 6,
           value = as_paragraph("Fit is R^2 for cyanobacteria models and AUC for microcystin models."), ref_symbols = "a", part = "header") |>
  theme_booktabs(bold_header = TRUE) |>
  fontsize(size = 10, part = "body") |>
  fontsize(size = 10, part = "header") |>
  fontsize(size = 9, part = "footer") |>
  theme_box() |>
  align(align = "center", part = "header")

```

```{r spatial covariance maps for no-lake models}
#| label: spcov-maps
#| fig-width: 6
#| fig-height: 7
#| fig-cap: "Spatial residuals for the cyanobacteria abundance (a) and probability of microcystin detection (b) models with in-lake conditions absent."

cyano_aug <- augment(cyano_nolake) |>
  mutate(spde = fitted(cyano_nolake, type = "spcov")$de,
         resp = "Cyanobacteria") |>
  select(resp, spde)

micx_aug <- augment(micx_nolake) |>
  mutate(spde = fitted(micx_nolake, type = "spcov")$de,
         resp = "Microcystin") |>
  select(resp, spde) |>
  st_transform(st_crs(cyano_aug))
  
spde <- rbind(cyano_aug, micx_aug)

cyan_spde_map <- ggplot() + 
  geom_sf(data = conus, fill = "#e2e2e2", color = "white", lwd = 1) +
  geom_sf(data = cyano_aug, 
          aes(fill = spde), pch = 21, size = 1.5) +
  colorspace::scale_fill_continuous_divergingx(palette = "BrBG", 
                                               mid = 0, 
                                               name = "Spatial\nResiduals") +
    theme_void()

micx_spde_map <- ggplot() + 
  geom_sf(data = conus, fill = "#e2e2e2", color = "white", lwd = 1) +
  geom_sf(data = micx_aug, 
          aes(fill = spde), pch = 21, size = 1.5) +
  colorspace::scale_fill_continuous_divergingx(palette = "BrBG", 
                                               mid = 0, 
                                               name = "Spatial\nResiduals") +
    theme_void()

ggarrange(plotlist = list(cyan_spde_map, micx_spde_map), ncol = 1, nrow = 2, labels = "auto")

```

### Predicted CyanoHABs Risk

#### Geographic Patterns

```{r micx predictions}
#| label: micx-map
#| fig-width: 6
#| fig-height: 8
#| fig-cap: "Predicted cyanobacteria abundance (a) and probabilty of microcystin detection at or above 0.1 ug/L (b) in 124,529 on-network lakes."

states <- states(cb = TRUE, progress_bar = FALSE)  %>%
  filter(!STUSPS %in% c('HI', 'PR', 'AK', 'MP', 'GU', 'AS', 'VI'))  %>%
  st_transform(crs = 5072)

# Cyano Predictions Map

PredData <- PredData %>%
  mutate(disc_cyano = factor(case_when(pred_cyano_fit < 4.41497 ~ 'B1', # under 25k
                                       pred_cyano_fit >= 4.41497 & pred_cyano_fit < 4.70757 ~ 'B2', # 25k - 50k
                                       pred_cyano_fit >= 4.70757 & pred_cyano_fit < 5.00432 ~ 'B3', # 50k - 100k
                                       pred_cyano_fit >= 5.00432 & pred_cyano_fit < 5.39967 ~ 'B4', # 100k - 250k
                                       pred_cyano_fit >= 5.39967 & pred_cyano_fit < 5.69984 ~ 'B5', # 250k-500k
                                       pred_cyano_fit > 5.69984 ~ 'B6', # 500k
                                       TRUE ~ NA),
                             levels = c('B1', 'B2', 'B3', 'B4', 'B5', 'B6'))) %>%
  arrange(disc_cyano)

sub_25 <- PredData %>%
  filter(disc_cyano == 'B1')

cyano_labels <- c('< 25', '25 - 50', '50 - 100', '100 - 250', '250 - 500', ' > 500')
cyano_colors <- c("#21618C","#5499C7","#A9CCE3","#EDBB99","#DC7633","#A04000")

cyano_pred_map <- ggplot() +
  geom_sf(data = PredData,
          aes(color = disc_cyano),
          size = 0.3,
          alpha = 0.8) +
  scale_color_manual(values = cyano_colors,
                     labels = cyano_labels,
                     name = "Abundance \n(1000 cells/mL)") +
  geom_sf(data = sub_25,
          aes(color = disc_cyano),
          size = 0.3,
          alpha = 0.8)  +
  geom_sf(data = states, fill = NA, color = "black", lwd = 0.1) +
  guides(color = guide_legend(override.aes = list(size = 2))) +
  theme_void()

# Micx Prediction Map

PredData <- PredData |>
  arrange(pred_micx_fit) |>
  mutate(disc_micx = case_when(pred_micx_fit < 0.25 ~ "M1",
                               pred_micx_fit >= 0.25 & pred_micx_fit < 0.50 ~ "M2",
                               pred_micx_fit >= 0.50 & pred_micx_fit < 0.75 ~ "M3",
                               pred_micx_fit >= 0.75 ~ "M4"),
         disc_micx = factor(disc_micx, levels = c("M1", "M2", "M3", "M4")))

labels = c("0-25", "25-50", "50-75", "75-100")
breaks <- c(0.25,0.50,0.75,1.0)
micx_colors <- c("#2980b9","#aed6f1","#f0b27a","#d35405")

micx_pred_map <- ggplot(PredData, aes(color = disc_micx)) +
  geom_sf(size = 0.3) +
  scale_color_manual(values = micx_colors,
                     labels = labels,
                     name = "Probability of \nDetection (%)") +
  geom_sf(data = states, fill = NA, color = "black", lwd = 0.1) +
  guides(color = guide_legend(override.aes = list(size = 2))) +
  theme_void()

ggarrange(plotlist = list(cyano_pred_map, micx_pred_map), ncol = 1, nrow = 2, labels = "auto", align = "h")

```

```{r prepare data - micx}

comp_micx <- PredData |>
  dplyr::select(-starts_with("pred_cyano"),
                -starts_with("cyano_transform")) |>
  drop_na(pred_micx_fit) |>
  mutate(
    ws_nut_inputs = ifelse((n_farm_inputs + n_dev_inputs) >= 10 | (p_farm_inputs + p_dev_inputs) >= 4, "HIGH", "LOW"),
    all_pred = factor(case_when(
      ws_nut_inputs == "HIGH" & pred_micx_fit >= 0.50 ~ 'HNHC',
      ws_nut_inputs == "LOW" & pred_micx_fit >= 0.50 ~ 'LNHC',
      ws_nut_inputs == "HIGH" & pred_micx_fit < 0.50 ~ 'HNLC',
      ws_nut_inputs == "LOW" & pred_micx_fit < 0.50 ~ 'LNLC',
      TRUE ~ 'OTHER'),
      levels = c('HNHC','HNLC','LNHC','LNLC'))
    ) |>
    arrange(all_pred)

```

```{r prepare data - cyano}

comp_cyano <- PredData |>
  dplyr::select(-starts_with("pred_micx"),
                -starts_with("micx_transform")) |>
  drop_na(cyano_transform_fit) |>
  mutate(
    ws_nut_inputs = ifelse((n_farm_inputs + n_dev_inputs) >= 10 | (p_farm_inputs + p_dev_inputs) >= 4, "HIGH", "LOW"),
    all_pred = factor(case_when(
      ws_nut_inputs == "HIGH" & pred_cyano_fit >= 5 ~ 'HNHC',
      ws_nut_inputs == "LOW" & pred_cyano_fit >= 5 ~ 'LNHC',
      ws_nut_inputs == "HIGH" & pred_cyano_fit < 5 ~ 'HNLC',
      ws_nut_inputs == "LOW" & pred_cyano_fit < 5 ~ 'LNLC',
      TRUE ~ 'OTHER'),
      levels = c('HNHC','HNLC','LNHC','LNLC'))
    ) |>
    arrange(all_pred)

```

#### Nutrient and Non-Nutrient Drivers

```{r nutrient input comparisons, include = FALSE}

# Tables comparing the different types of nutrient inputs and whether that changes the "high" versus "low" nutrient input designations

th_n <- 10
th_p <- 4

# The current analysis relies on just the nutrient inputs that are included in the respective models. How do the numbers change when all nutrient inputs included in the model are used to determine high/low nutrient inputs? What about when deposition is included as well?
habs |>
  st_drop_geometry() |>
  distinct(UNIQUE_ID, .keep_all = TRUE) |>
  mutate(th_n_farm = ifelse(n_farm_inputs >= th_n, "HIGH", "LOW"),
         th_p_farm = ifelse(p_farm_inputs >= th_p, "HIGH", "LOW"),
         th_n_dev = ifelse(n_dev_inputs >= th_n, "HIGH", "LOW"),
         th_p_dev = ifelse(p_dev_inputs >= th_p, "HIGH", "LOW"),
         ) |>
  mutate(cyano_model_inputs = ifelse(th_n_farm == "HIGH" | th_p_dev == "HIGH", "HIGH", "LOW"),
         micx_model_inputs = ifelse(th_n_dev == "HIGH" | th_p_farm == "HIGH", "HIGH", "LOW"),
         all_model_inputs = ifelse((n_farm_inputs + n_dev_inputs) >= th_n | 
                                   (p_farm_inputs + p_dev_inputs) >= th_p, "HIGH", "LOW")
         ) |>
  mutate(tot_n_inputs = N_Fert_Farm + N_livestock_Waste + N_Total_Deposition + N_Fert_Urban + N_Human_Waste + N_CBNF,
         tot_p_inputs = P_f_fertilizer + P_livestock_Waste + P_Deposition + P_nf_fertilizer + P_human_waste_kg,
         all_nni_inputs = ifelse(tot_n_inputs >= th_n | tot_p_inputs >= th_p, "HIGH", "LOW")
         ) |>
  pivot_longer(cols = c(cyano_model_inputs:all_model_inputs, all_nni_inputs), 
               values_to = "inputs", names_to = "input_scope") |>
  group_by(input_scope, inputs) |>
  summarize(count = n(), .groups = "drop") |>
  drop_na() |>
  mutate(includes = c(rep("N/P Farm Fert, N/P Manure, N/P Human Waste, N/P Dev Fert, N CBNF, NO DEPOSITION", 2),
                   rep("N/P Farm Fert, N/P Manure, N/P Human Waste, N/P Dev Fert, N/P Dep, N CBNF, INCLUDES DEPOSITION", 2),
                   rep("N Farm Fert, N Manure, N CBNF, P Dev Fert, P Human Waste", 2),
                   rep("P Farm Fert, P Manure, N Human Waste, N Dev Fert", 2))) |>
  mutate(input_scope = factor(input_scope, levels = c("cyano_model_inputs",
                                                      "micx_model_inputs",
                                                      "all_model_inputs",
                                                      "all_nni_inputs"))) |>
  arrange(input_scope) |>
  flextable() |>
  merge_v(part = "body", j = c(1, 4)) |>
  theme_box() |>
  width(j = 4, width = 3)
  

```


```{r density plots - precip, message = FALSE}
#| label: density-precip
#| fig-width: 5
#| fig-height: 9
#| fig-cap: "Density distributions of mean annual precipitation (a), baseflow index (b), and lake area:depth ratio (c) for the four nutrient input and cyanoHAB risk categories for the predictions from the cyanobacteria abundance (first column) and probability of microcystin detection (second column). Vertical bars in distributions represent the median. Precipitation and the area:depth ratio distributions are truncated to better show majority of data density and differences in medians."

den_df <- comp_cyano |>
  st_drop_geometry() |>
  select(BFIWs, ad_ratio, Precip8110Ws, all_pred) |>
  mutate(resp = "Cyanobacteria") |>
  rbind(mutate(select(st_drop_geometry(comp_micx),
                      BFIWs, ad_ratio, Precip8110Ws, all_pred),
               resp = "Microcystin")) |>
  # Removing infinite values (when depth = 0)
  mutate(ad_ratio = ifelse(is.infinite(ad_ratio), NA, ad_ratio)) |> 
  tibble()

cat_labels <- c('High Nutrient, High CyanoHABs',
                'High Nutrient, Low CyanoHABs',
                'Low Nutrient, High CyanoHABs',
                'Low Nutrient, Low CyanoHABs')

precip_den <- ggplot(den_df) +
  ggridges::geom_density_ridges(aes(x = Precip8110Ws, y = all_pred, fill = all_pred),
                                na.rm = TRUE,
                                scale = 2,
                                alpha = 0.85,
                                quantile_lines = TRUE, quantiles = 2) +
  facet_wrap(~ resp) +
  scale_fill_manual(values = c("#9c0082","#cc6de4","#4e8562", "#8bd1a5"),
                    labels = cat_labels) +
  xlim(0, 2000) +
  labs(x = "Precipitation (mm)") +
  theme(axis.title.y = element_blank(),
        legend.title = element_blank()) 

bfi_den <- ggplot(den_df) +
  ggridges::geom_density_ridges(aes(x = BFIWs, y = all_pred, fill = all_pred),
                                na.rm = TRUE,
                                scale = 2,
                                alpha = 0.85,
                                quantile_lines = TRUE, quantiles = 2) +
  facet_wrap(~ resp) +
  scale_fill_manual(values = c("#9c0082","#cc6de4","#4e8562", "#8bd1a5"),
                    labels = cat_labels) +
  xlim(0, 100) +
  labs(x = "Baseflow Index (%)") +
  theme(axis.title.y = element_blank(),
        legend.title = element_blank()) 

ad_den <- ggplot(den_df) +
  ggridges::geom_density_ridges(aes(x = ad_ratio, y = all_pred, fill = all_pred),
                                na.rm = TRUE,
                                scale = 2,
                                alpha = 0.85,
                                quantile_lines = TRUE, quantiles = 2) +
  facet_wrap(~ resp) +
  scale_fill_manual(values = c("#9c0082","#cc6de4","#4e8562", "#8bd1a5"),
                    labels = cat_labels) +
  xlim(0, 0.5) +
  labs(x = "Area:Depth Ratio") +
  theme(axis.title.y = element_blank(),
        legend.title = element_blank(),
        legend.position = "bottom") +
  guides(fill = guide_legend(nrow = 2, byrow = TRUE))


ggpubr::ggarrange(precip_den, bfi_den, ad_den,
                  ncol = 1, nrow = 3,
                  common.legend = TRUE, 
                  legend.grob = get_legend(ad_den),
                  legend = "bottom",
                  labels = "auto")
```

## Supplemental Material

```{r construct variable summary table}
# Each variable that was considered in the modeling process
# Note that some of these values were excluded from the model development process because of suspected unreasonable outliers. Will need to update this once I determine where in the pipeline to trim these data.

summerizer <- function(var){
  colnum <- match(var[1], colnames(habs))
  dat    <- pull(habs, colnum)
  tibble(Variable = var[2],
         Units = var[3],
         Min = min(dat, na.rm = TRUE),
         Med = median(dat, na.rm = TRUE),
         Mean = mean(dat, na.rm = TRUE),
         Max = max(dat, na.rm = TRUE),
         Scale = var[4],
         Source = var[5]
         )
}

vec_list <- list(
  c("B_G_DENS", "Cyanobacteria", "cells/mL", "Lake", "NLA"),
  c("MICX", "Microcystin", "ug/L", "Lake", "NLA"),
  c("PTL", "Total Phosphorus", "ug/L", "Lake", "NLA"),
  c("NTL", "Total Nitrogen", "mg N/L", "Lake", "NLA"),
  c("NITRATE_N", "Nitrate", "mg N/L", "Lake", "NLA"),
  c("AMMONIA_N", "Ammonium", "mg N/L", "Lake", "NLA"),
  c("DOC", "Dissolved Organic Carbon", "mg/L", "Lake", "NLA"),
  c("PH", "pH", "Std. Units", "Lake", "NLA"),
  c("TURB", "Tubidty", "NTU", "Lake", "NLA"),
  c("EVAP_INFL", "Evaporation:Inflow", "unitless", "Lake", "NLA"),
  c("MAXDEPTH", "Maximum Lake Depth", "meters", "Lake", "NLA"),
  c("lakemorpho_fetch", "Lake Fetch", "meters", "Lake", "Lakemorpho"),
  c("N_Fert_Farm", "Farm Fertilizer N", "kg/ha/yr", "Watershed", "National Nutrient Inventory"),
  c("N_livestock_Waste", "Livestock Waste N", "kg/ha/yr", "Watershed", "National Nutrient Inventory"),
  c("N_CBNF", "Cultivated Crop Biological Nitrogen Fixation", "kg/ha/yr", "Watershed", "National Nutrient Inventory"),
  c("P_f_fertilizer", "Farm Fertilizer P", "kg/ha/yr", "Watershed", "National Nutrient Inventory"),
  c("P_livestock_Waste", "Livestock Waste P", "kg/ha/yr", "Watershed", "National Nutrient Inventory"),
  c("N_Human_Waste", "Human Waste N", "kg/ha/yr", "Watershed", "National Nutrient Inventory"),
  c("N_Fert_Urban", "Non-Farm Fertilizer N", "kg/ha/yr", "Watershed", "National Nutrient Inventory"),
  c("P_human_waste_kg", "Human Waste P", "kg/ha/yr", "Watershed", "National Nutrient Inventory"),
  c("P_nf_fertilizer", "Non-Farm Fertilizer P", "kg/ha/yr", "Watershed", "National Nutrient Inventory"),
  c("n_farm_inputs", "Total Farm N Inputs", "kg/ha/yr", "Watershed", "National Nutrient Inventory"),
   c("p_farm_inputs", "Total Farm P Inputs", "kg/ha/yr", "Watershed", "National Nutrient Inventory"),
   c("n_dev_inputs", "Total Developed N Inputs", "kg/ha/yr", "Watershed", "National Nutrient Inventory"),
   c("p_dev_inputs", "Total Developed P Inputs", "kg/ha/yr", "Watershed", "National Nutrient Inventory"),
  c("fst_ws", "Forested Land Cover", "percent", "Watershed", "NLCD 2011"),
  c("BFIWs", "Baseflow Index", "unitless", "Watershed", "LakeCat"),
  c("precip_mean_month", "Month Mean Precipitation", "millimeters", "Watershed", "LakeCat"),
  c("temp_mean_month", "Month Mean Temperature", "degC", "Watershed", "LakeCat"),
  c("Precip8110Ws", "Mean Annual Precipitation", "millimeters", "Watershed", "LakeCat"),
  c("Tmean8110Ws", "Mean Annual Temperature", "millimeters", "Watershed", "LakeCat")
)

summary_covariate_table <- do.call(rbind, lapply(vec_list, summerizer)) |>
  mutate(Type = c(rep("In-Lake Conditions", 10), 
                  rep("Lake Geometry", 2), 
                  rep("Nutrient Inputs", 14), 
                  rep("Geographic Setting", 5)), .before = "Variable")

options(digits = 1)
covar_sum_table <- summary_covariate_table |>
  flextable() |>
  colformat_num(j = c("Min","Med","Mean","Max"), digits = 2, part = "body") |>
  merge_v(part = "body", j = 1) |> 
  theme_booktabs(bold_header = TRUE) |>
  theme_box() |>
  align(align = "center", part = "header") |>
  align(align = "center", j = 1, part = "body") |>
  fontsize(size = 10, part = "body") |>
  fontsize(size = 10, part = "header")

```

Table S1. Summary statistics for response variable and covariates explored in model selection.
```{r varable summary table}
#| label: tbl-var-summary
covar_sum_table
```

```{r model selection tables}

# Create a table of model comparison process
tabs <- c("cyano_mod_compare_withlakedata.rds",
          "cyano_mod_compare_nolakedata.rds",
          "micx_iemod_compare_withlakedata.rds",
          "micx_iemod_compare_nolakedata.rds",
          "micx_spmod_compare_withlakedata.rds",
          "micx_spmod_compare_nolakedata.rds")

# Vector of strings to replace with covariate names
covar_labs <-  c("NTL" = "Total N",
                 "PTL" = "Total P",
                 "NITRATE_N" = "Nitrate",
                 "AMMONIA_N" = "Ammonium",
                 "DOC" = "DOC",
                 "TURB" = "Turbidity",
                 "PH" = "pH",
                 "EVAP_INFL" = "Evaporation/Inflow",
                 "MAXDEPTH" = "Lake Depth",
                 "lakemorpho_fetch" = "Lake Fetch",
                 "n_farm_inputs" = "Farm N Inputs",
                 "p_farm_inputs" = "Farm P Inputs",
                 "n_dev_inputs" = "Developed N Inputs",
                 "p_dev_inputs" = "Developed P Inputs",
                 "fst_ws" = "Forest Cover",
                 "BFIWs" = "Baseflow Index",
                 "Precip8110Ws" = "Annual Precip",
                 "Tmean8110Ws" = "Annual Air Temp",
                 "precip_mean_month" = "Monthly Precip",
                 "temp_mean_month" = "Monthly Air Temp",
                 "AG_ECO3PLNLOW" = "Ecoregion",
                 "AG_ECO3EHIGH" = "Ecoregion",
                 ":" = " * ")

# A few expressions end up being repeated when there are interactions with ecoregion
# rep_expr <- c("Total N * Ecoregion", "Farm N Inputs * Ecoregion", "Farm P Inputs * Ecoregion")

# The columns to be displayed from each table
cyano_cols   <- c("BIC", "bias", "RMSPE", "cor2")
micx_ie_cols <- c("BIC", "bias", "RMSPE", "AUC")
micx_sp_cols <- c("bias", "RMSPE", "AUC")

cyano_labs   <- c("BIC", "Bias", "RMSPE", "R^2")
micx_ie_labs <- c("BIC", "Bias", "RMSPE", "AUC")
micx_sp_labs <- c("Bias", "RMSPE", "AUC")

# Construct the tables
options(digits = 2)
mod_comp_tabs <- lapply(tabs, function(tab){

  # Columns to display in the table
  cols_sel <- if(grepl("cyano", tab)){list(cyano_cols, cyano_labs)
  } else if(grepl("micx_ie", tab)) {list(micx_ie_cols, micx_ie_labs)
  } else {list(micx_sp_cols, micx_sp_labs)}
  
  # Read in table and format
  dat <- readRDS(paste0(here(), "./inst/model_objects/", tab)) |>
    # Insert breaks so that variables are stacked vertically
    mutate(distinct_vars = gsub(", ", " \n", distinct_vars),
           common_vars = gsub(", ", " \n", common_vars),
           # Maps variable strings to the desired labels
           distinct_vars = str_replace_all(distinct_vars, covar_labs),
           common_vars = str_replace_all(common_vars, covar_labs),
           # Removes duplicated labels using regular expressions (note, this does not capture expressions that have an *)
           distinct_vars = str_replace_all(distinct_vars, "\\b(\\w+)\\s+\\1\\b", "\\1"),
           common_vars = str_replace_all(common_vars, "\\b(\\w+)\\s+\\1\\b", "\\1"))|>
    arrange(model) |>
    select(common_vars, distinct_vars, all_of(cols_sel[[1]]))
  
  # Set the header
  dat_header <- data.frame(
    col_keys = colnames(dat),
    line2 = c(rep("Model Fixed Effects", 2), cols_sel[[2]]),
    line3 = c("Common Set", "Test Set", cols_sel[[2]])
  )
  
  # Table caption builder
  inlake <- ifelse(grepl("nolakedata", tab), "absent", "present")
  error  <- ifelse(grepl("iemod", tab), "independent", "spatial")
  resp   <- ifelse(grepl("cyano", tab), "cyanobacteria", "microcystin")
  cap    <- paste("Model selection for the", resp, "model with in-lake conditions", inlake, "and a", error, "error structure. Fixed effects that are common to all candidate models are listed under Common Set and those that are unique to the model are listed under Test Set.")
  
  # Format the table
  flex_dat <- dat |>
    flextable() |>
    set_header_df(mapping = dat_header, key = "col_keys" ) |>
    merge_v(part = "header", j = c(3:length(dat))) |> 
    merge_h(part = "header", i = 1) |>
    merge_v(part = "body", j = 1) |>
    theme_booktabs(bold_header = TRUE) |>
    fontsize(size = 10, part = "body") |>
    fontsize(size = 10, part = "header") |>
    theme_box() |>
    align(align = "center", part = "header") |>
    autofit(add_w = 0, add_h = 0) |>
    paginate(init = TRUE, hdr_ftr = TRUE)
  
    return(list(cap, flex_dat))
})


```

\pagebreak

Table S2. `r mod_comp_tabs[[1]][[1]]` `r mod_comp_tabs[[1]][[2]]`

\pagebreak

Table S3. `r mod_comp_tabs[[2]][[1]]` `r mod_comp_tabs[[2]][[2]]`

\pagebreak

Table S4. `r mod_comp_tabs[[3]][[1]]` `r mod_comp_tabs[[3]][[2]]`

\pagebreak

Table S5. `r mod_comp_tabs[[5]][[1]]` `r mod_comp_tabs[[5]][[2]]`

\pagebreak

Table S6. `r mod_comp_tabs[[4]][[1]]` `r mod_comp_tabs[[4]][[2]]`

\pagebreak

Table S7. `r mod_comp_tabs[[6]][[1]]` `r mod_comp_tabs[[6]][[2]]`

```{r standarized residual maps}
#| label: std-resid-maps
#| fig-width: 9
#| fig-height: 6.5
#| fig-cap: "Standardized residuals for the models with in-lake conditions present (top row) for cyanobacteria abundance (a) and probability of microcystin detection (b) and models with in-lake conditions absent (bottom row) for cyanobacteria abundance (c) and probability of microcystin detection (d)."

# Augment the splm objects to add the standardized residuals
resp    <- rep(c("Cyanobacteria", "Microcystin"), 2)
in_lake <- c(rep("Present", 2), rep("Absent", 2))

auged_splms <- lapply(list(cyano_lake, micx_lake, cyano_nolake, micx_nolake), augment)

stresids <- lapply(seq_along(auged_splms), function(i){
  auged_splms[[i]] |>
    mutate(resp = resp[i],
           in_lake = in_lake[i]) |>
    select(resp, in_lake, .std.resid) |>
    st_transform(cyano_nolake$crs) |>
    mutate(rank = case_when(.std.resid > 4 ~ 4,
                            .std.resid > 3 & .std.resid < 4 ~ 3,
                            .std.resid < -2 ~ 2,
                            TRUE ~ 1)) |>
    arrange(rank)
})

stresid_maps <- lapply(seq_along(stresids), function(i){
  ggplot() + 
    geom_sf(data = conus, fill = "#e2e2e2", color = "white", lwd = 1) +
    geom_sf(data = stresids[[i]], 
            aes(fill = .std.resid), pch = 21, size = 1.5) +
    colorspace::scale_fill_continuous_divergingx(palette = "BrBG", 
                                                 mid = 0, 
                                                 name = "Standardized\nResidual") +
    ggtitle(paste(resp[i], in_lake[i])) +
    theme_void()
})

ggarrange(plotlist = stresid_maps, ncol = 2, nrow = 2, labels = "auto")

```


```{r spatial residulas maps for in-lake models}
#| label: spcov-maps-inlake
#| fig-width: 6
#| fig-height: 7
#| fig-cap: "Spatial residuals for the cyanobacteria abundance (a) and probability of microcystin detection (b) models with in-lake conditions present."

cyano_lake_aug <- augment(cyano_lake) |>
  mutate(spde = fitted(cyano_lake, type = "spcov")$de,
         resp = "Cyanobacteria") |>
  select(resp, spde)

micx_lake_aug <- augment(micx_lake) |>
  mutate(spde = fitted(micx_lake, type = "spcov")$de,
         resp = "Microcystin") |>
  select(resp, spde) |>
  st_transform(st_crs(cyano_lake_aug))
  
spde <- rbind(cyano_lake_aug, micx_lake_aug)

cyan_lake_spde_map <- ggplot() + 
  geom_sf(data = conus, fill = "#e2e2e2", color = "white", lwd = 1) +
  geom_sf(data = cyano_lake_aug, 
          aes(fill = spde), pch = 21, size = 1.5) +
  colorspace::scale_fill_continuous_divergingx(palette = "BrBG", 
                                               mid = 0, 
                                               name = "Spatial\nResiduals") +
    theme_void()

micx_lake_spde_map <- ggplot() + 
  geom_sf(data = conus, fill = "#e2e2e2", color = "white", lwd = 1) +
  geom_sf(data = micx_lake_aug, 
          aes(fill = spde), pch = 21, size = 1.5) +
  colorspace::scale_fill_continuous_divergingx(palette = "BrBG", 
                                               mid = 0, 
                                               name = "Spatial\nResiduals") +
    theme_void()

ggarrange(plotlist = list(cyan_lake_spde_map, micx_lake_spde_map), ncol = 1, nrow = 2, labels = "auto")

```


```{r high and low nutrient watersheds}
#| label: nut-input-map
#| fig-width: 6
#| fig-height: 4
#| fig-cap: "Annual anthropogenic nitrogen and phosphorus inputs to the 124,529 lake watersheds for which predictions of cyanoHABs were generated. Inputs consist of the sum of farm fertilizer, manure, developed landscape fertilizer, and human waste for each nutrient. Nitrogen has an additional term for cultivated crop biological nitrogen fixtation. High nutrient inputs consist of at least 10 kg N/ha/yr or 4 kg P/ha/yr inputs."

nut_inputs <- PredData |>
  mutate(ws_nut_inputs = ifelse((n_farm_inputs + n_dev_inputs) >= 10 | 
                                (p_farm_inputs + p_dev_inputs) >= 4, "HIGH", "LOW"),
         ws_nut_inputs = factor(ws_nut_inputs, levels = c("LOW", "HIGH"))) |>
  drop_na(ws_nut_inputs) |>
  arrange(ws_nut_inputs)

ggplot(nut_inputs, aes(color = ws_nut_inputs)) +
  geom_sf(size = 0.3) +
  scale_color_manual(values = c("#4e8562", "#9c0082"),
                    labels = c("Low", "High"),
                    name = "Annual \nAnthropogenic \nWatershed \nNutrient \nInputs") +
  geom_sf(data = states, fill = NA, color = "black", lwd = 0.1) +
  guides(color = guide_legend(override.aes = list(size = 2))) +
  theme_void()

```

Table S8. Final model fixed effect coefficient estimates and standard errors with p-values (ns \>0.05, \* \<0.05, \*\* \<0.01, \*\*\*\* \< 0.001) for cyanobacteria (Cyano) and microcystin (Micx) models. Models where in-lake data were present or absent are included. Grey cells are covariates that were excluded from model development. Empty cells are covariates that were not included in the finla model. Brighter colors denote a lower p-value for either positive (pink) or negative (blue) relationships. Note the scale and range of the covariates in Table S1.
```{r covariate table with coefficient values}

# Table is identical to covariate table in main text, but included the coefficient mean and standard error.

est_and_sign <- fixed_df |>
  filter(!fixed_effect == "(Intercept)") |>
  mutate(est_stderr = paste(signif(estimate, 3), "±", signif(Std_Error, 3)),
         sig = case_when(p >= 0.05 ~ "(ns)",
                         p < 0.05 & p >= 0.01 ~ "*",
                         p < 0.01 & p >= 0.001 ~ "**",
                         p < 0.001 ~ "***"),
         est_sig = paste0(est_stderr, sig),
         fixed_effect = factor(fixed_effect, 
                               levels = c("NTL",
                                          "NITRATE_N",
                                          "AMMONIA_N",
                                          "DOC",
                                          "TURB",
                                          "PH",
                                          "EVAP_INFL",
                                          "n_farm_inputs",
                                          "p_farm_inputs",
                                          "n_dev_inputs",
                                          "p_dev_inputs",
                                          "fst_ws",
                                          "MAXDEPTH",
                                          "lakemorpho_fetch",
                                          "BFIWs",
                                          "Precip8110Ws",
                                          "Tmean8110Ws",
                                          "AG_ECO3PLNLOW",
                                          "AG_ECO3EHIGH",
                                          "NTL:AG_ECO3PLNLOW",
                                          "NTL:AG_ECO3EHIGH"))
         ) |>
  select(response_var:fixed_effect, est_sig) |>
  pivot_wider(names_from = response_var:lake_data,
              values_from = est_sig,
              values_fill = "") |>
  arrange(fixed_effect) |>
  relocate(fixed_effect, cyano_present, micx_present, cyano_absent, micx_absent) |>
  mutate(fixed_effect = c("Total N",
                       "Nitrate",
                       "Ammonium",
                       "DOC",
                       "Turbidity",
                       "pH",
                       "Evaporation/Inflow",
                       "Farm N Inputs",
                       "Farm P Inputs",
                       "Developed N Inputs",
                       "Developed P Inputs",
                       "Forest Cover",
                       "Lake Depth",
                       "Lake Fetch",
                       "Baseflow Index",
                       "Annual Precip",
                       "Annual Air Temp",
                       "Ecoregion PLNLOW",
                       "Ecoregion EHIGH",
                       "Total N * PLNLOW",
                       "Total N * EHIGH"),
         Type = c(rep("In-Lake Conditions", 7),
                  rep("Nutrient Inputs", 5),
                  rep("Lake Geometry", 2),
                  rep("Geographic Setting", 5),
                  rep("Interactions", 2)), .before = fixed_effect
            ) |>
  rename(Covariates = fixed_effect)

colorer_eststderr <- function(i){
  hex <- case_when(grepl("-", i) & grepl("\\*{3}", i) ~ pal[1],
                   grepl("-", i) & grepl("\\*{2}", i) ~  pal[2],
                   grepl("-", i) & grepl("\\*{1}", i) ~   pal[3],
                   grepl("-", i) & grepl("(ns)", i) ~  pal[4],
                   i == "" ~        pal[5],
                   !grepl("-", i) & grepl("(ns)", i) ~  pal[6],
                   !grepl("-", i) & grepl("\\*{1}", i) ~   pal[7],
                   !grepl("-", i) & grepl("\\*{2}", i) ~  pal[8],
                   !grepl("-", i) & grepl("\\*{3}", i) ~ pal[9])
}

est_header <- data.frame(
  col_keys = colnames(est_and_sign),
  line2 = c(rep("Model", 2), rep("In-Lake Conditions", 4)),
  line3 = c(rep("Model", 2), c(rep("Present", 2), rep("Absent", 2))),
  line4 = c("Type", "Covariates", rep(c("Cyano", "Micx"), 2))
)

covar_tbl <- est_and_sign |>
  flextable() |>
  set_header_df(mapping = est_header, key = "col_keys" ) |>
  merge_v(part = "header", j = c(1:2)) |> 
  merge_v(part = "body", j = 1) |> 
  merge_h(part = "header", i = c(1:2)) |> 
  theme_booktabs(bold_header = TRUE) |>
  bg(bg = colorer_eststderr,
     j = 3:6, # All columns in the body except for the first one
     part = "body") |>
  bg(j = c(5:6), i = c(1:7), bg = "#606060") |> # Covariates that weren't available to the models
  theme_box() |>
  align(align = "center", part = "header") |>
  fontsize(size = 10, part = "body") |>
  fontsize(size = 10, part = "header")

covar_tbl
```

```{r figure of covariate contributions}

att_cyan <- readr::read_csv(here::here("inst/source_data/cyano_nolake_attribution.csv")) |>
  mutate(resp = "Cyano") |>
  pivot_longer(c(n_farm_inputs:lakemorpho_fetch, de), names_to = "variable", values_to = "variable_contr") |>
  mutate(variable = factor(variable, levels = c("de",
                                                "Tmean8110Ws",
                                                "Precip8110Ws",
                                                "BFIWs",
                                                "lakemorpho_fetch",
                                                "MAXDEPTH",
                                                "p_dev_inputs",
                                                "n_farm_inputs"))
  ) |>
  arrange(fitted)

att_micx <- readr::read_csv(here::here("inst/source_data/micx_nolake_attribution.csv"))

cyan_attri_plot <- ggplot(att_cyan, aes(x = variable, y = variable_contr, color = fitted)) +
  geom_quasirandom(shape = 16, size = 0.75, groupOnX = TRUE) +
  scale_color_gradientn(colors = c("#21618C","#5499C7","#A9CCE3","#EDBB99","#DC7633","#A04000"),
                        name = "Fitted \nCyanobacteria \nAbundance \n(cell/mL)",
                        breaks = c(log10(3000+1000), log10(10000+1000), log10(30000+1000), log10(100000+1000)),
                        labels = c("3,000", "10,000", "30,000", "100,000")) +
  scale_x_discrete(labels = c("n_farm_inputs" = "Farm N Inputs", 
                              "p_dev_inputs" = "Farm P Inputs", 
                              "MAXDEPTH" = "Lake Depth",
                              "lakemorpho_fetch" = "Lake Fetch",
                              "Precip8110Ws" = "Annual Precip",
                              "Tmean8110Ws" = "Annual Temp",
                              "de" = "Spatial Residual"),
                   name = "") +
  labs(y = "Variable Contribution to Fitted Value (standardized)") +
  coord_flip() +
  theme_minimal()


mods <- list(cyano_lake, micx_lake, cyano_nolake, micx_nolake)

# Note that this takes prohibitively long to run on Amalia's machine. Moving to use the data the files that Melanie generated for this for Robert's analysis.

Sys.time()

terms_contr <- lapply(mods, function(mod){
  cols <- colnames(mod$obdata)
  cols <- cols[-c(length(cols), length(cols) - 1)]
  dat  <- habs |>
    select(all_of(cols)) |>
    drop_na()
  predict(mod, newdata = dat, terms = "terms")
})

Sys.time()

```

